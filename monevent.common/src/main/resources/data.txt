

import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;



import java.io.Serializable;

import java.util.*;



/**

* Created by Stephane on 06/12/2014.

*/

public class Chain extends Queryable implements Serializable {

    /**

     * DateTime : beginning of the sequence

     */

    public static String start = "start";

    public static String steps = "steps";

    public static String latencies = "latencies";

    public static String deleted = "deleted";



    public Chain(String name) {

        super(name, "chain");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Chain.steps, Collections.synchronizedList(new ArrayList<ChainStep>()));

        put(Chain.latencies, Collections.synchronizedList(new ArrayList<Latency>()));

    }



    public Chain(Map data) {

        super(data);

        if(data.get(Chain.steps) instanceof ArrayList || data.get(Chain.steps) == null )

            this.put(Chain.steps, ChainStep.transformToList((ArrayList) data.get(Chain.steps), ChainStep.class));

        if(data.get(Chain.latencies) instanceof ArrayList || data.get(Chain.latencies) == null )

            this.put(Chain.latencies, Queryable.transformToList((ArrayList) data.get(Chain.latencies), Latency.class));

   }



    public Chain(Chain data) {

        super(data);

        this.put(Chain.steps, ChainStep.transformToList(data.getSteps(), ChainStep.class));

        this.put(Chain.latencies, Queryable.transformToList(data.getLatencies(), Latency.class));

    }



    public Chain() {

        super("chain");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Chain.steps, Collections.synchronizedList(new ArrayList<ChainStep>()));

        put(Chain.latencies, Collections.synchronizedList(new ArrayList<Latency>()));

    }



    public List<ChainStep> getSteps() {

        return (List<ChainStep>) get(Chain.steps);

    }



    public List<Latency> getLatencies() {

        return (List<Latency>) get(Chain.latencies);

    }



    // !!! returns FIST occurence only



    public synchronized ChainStep getUniqueStep(String name) throws WorkerException {

        List<ChainStep> steps = getSteps(name);



        if (steps.size() > 1) {

            throw new WorkerException("Found more than one chain step  : " + steps.size());

        }



        if (steps.size() == 0) {

            return null;

        }



        return steps.get(0);

    }



    public synchronized ChainStep getStep(String name) {

        IQuery query = new Query();

        query.addCriterion(ChainStep.name, name, QueryCriterionType.Is);



        for (ChainStep chainStep : getSteps()) {

            if (query.match(chainStep)) {

                return chainStep;

            }

        }

        return null;

    }



    public synchronized List<ChainStep> getSteps(String name) {

        IQuery query = new Query();

        query.addCriterion(ChainStep.name, name, QueryCriterionType.Is);



        ImmutableList.Builder<ChainStep> builder = new ImmutableList.Builder<>();

        for (ChainStep chainStep : getSteps()) {

            if (query.match(chainStep)) {

                builder.add(chainStep);

            }

        }

        return builder.build();

    }



    public synchronized ChainStep getStep(UUID stepId) {

        String stepIdasString = stepId.toString();

        for (ChainStep chainStep : getSteps()) {

            if (stepIdasString.equals(chainStep.getId())) {

                return chainStep;

            }

        }

        return null;

    }



    public synchronized ChainStep getStep(IQuery query) {

        for (ChainStep chainStep : getSteps()) {

            if (query.match(chainStep)) {

                return chainStep;

            }

        }

        return null;

    }



    public synchronized Chain insertStep(ChainStep step) {

        List<ChainStep> chainSteps = getSteps();

        step.setChain(getId());

        for (ChainStep chainStep : chainSteps) {

            if (chainStep.getId().equals(step.getId())) {

                return this;

            }

        }

        chainSteps.add(step);

        return this;

    }



    public Chain promoteAs(Queryable other, boolean overrideIfPresent, String chainField, String fieldToCopy) {

        copyField(other, overrideIfPresent, chainField, fieldToCopy);

        return this;

    }



    public synchronized boolean checkStepStatus(String status) {

        List<ChainStep> chainSteps = getSteps();

        for (ChainStep chainStep : chainSteps) {

            if (!chainStep.getStatus().equals(status)) {

                return false;

            }

        }

        return true;

    }



    public DateTime getStart() {

        return getValueAsDateTime(Chain.start);

    }



    public void setStart(DateTime start) {

        if (start != null) {

            put(Chain.start, start);

        }

    }

}package sgcib.tmon.worker.chain;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.TimerTask;

import java.util.concurrent.ArrayBlockingQueue;

import java.util.concurrent.BlockingQueue;



import org.elasticsearch.common.lang3.StringUtils;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.chain.IChainStore;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;

import sgcib.tmon.worker.common.store.queryable.MemoryQueryableStore;



/**

* Created by Stephane on 12/04/2015.

*/

public class ChainManager extends ManageableBase implements IChainManager {



    protected IChainStore shortTermStore;

    protected final IChainStore longTermStore;

    protected final IQueryableStore itemStore;

    private final BlockingQueue<Chain> chains;

    private final BlockingQueue<ChainStep> steps;

    private java.util.Timer timer;



    public ChainManager(IChainStore shortTermStore, IChainStore longTermStore) {

        super("ChainManager");

        this.shortTermStore = shortTermStore;

        this.longTermStore = longTermStore;

        this.itemStore = new MemoryQueryableStore();

        this.chains = new ArrayBlockingQueue<Chain>(50000);

        this.steps = new ArrayBlockingQueue<ChainStep>(50000);

    }



    @Override

    public Chain getChain(String id) throws WorkerException {

        return shortTermStore.readChain(id);

    }



    @Override

    public List<Chain> getChain(IQuery query) throws WorkerException {

        return shortTermStore.fetchChain(query);

    }



    @Override

    public Chain getOrCreateChain(IQuery query) throws WorkerException {



        List<Chain> found = shortTermStore.fetchChain(query);

        if (null == found || found.isEmpty()) {

            return createChain(query);

        }



        if (found.size() > 1) {

            for (Chain chain : found) {

                for (Map.Entry entry : chain.entrySet()) {

                    getLogger().debug(String.format("%s-%s", entry.getKey(), entry.getValue()));

                }

            }

            throw new WorkerException("getOrCreateChain query returns more than one chain");

        }

        return found.get(0);

    }



    public Chain createChain(IQuery query) {

        Chain chain = new Chain();

        chain.importCriteria(query);

        return chain;

    }



    @Override

    public void saveChain(Chain chain) throws WorkerException {

        getLogger().debug("Saving chain ... ");

        if (chain != null) {

            getLogger().debug(String.format("Chain : %s steps : %d id : %d", chain.getId(), chain.getSteps().size(), chain.hashCode()));

            if (shortTermStore != null) {

                this.shortTermStore.createChain(chain);

            }

            chains.offer(new Chain(chain));

        }

        getLogger().debug("Chain saved ... ");

    }



    @Override

    public ChainStep getStep(String id) throws WorkerException {

        return shortTermStore.readStep(id);

    }



    @Override

    public List<ChainStep> getStep(IQuery query) throws WorkerException {

        return shortTermStore.fetchStep(query);

    }



    @Override

    public void saveStep(ChainStep step) throws WorkerException {

        if (step != null) {

            if (shortTermStore != null) {

                this.shortTermStore.createStep(step);

            }

            steps.offer(new ChainStep(step));

        }

    }



    @Override

    public ChainStep getOrCreateStep(String name, IQuery query) throws WorkerException {



        query.addCriterion(Queryable.name, name, QueryCriterionType.Is);

        List<ChainStep> found = shortTermStore.fetchStep(query);

        if (null == found || found.isEmpty()) {

            return createStep(name, query);

        }



        if (found.size() > 1) {

            throw new WorkerException("getOrCreateStep query returns more than one step");

        }



        if (!found.get(0).hasId()) {

            throw new WorkerException("step should have an Id");

        }



        return found.get(0);

    }



    @Override

    public ChainStep getOrCreateStepOfChain(Chain chain, String stepName, IQuery queryNextStep) {



        if (chain == null) {

            throw new WorkerException("Chain is null. Can not get or create step.");

        }

        if (StringUtils.isBlank(stepName)) {

            throw new WorkerException("StepName is null. Can not get or create step.");

        }

        if (queryNextStep == null) {

            throw new WorkerException("Query is null. Can not get or create step.");

        }



        IQuery query = new Query(queryNextStep);

        query.addCriterion(ChainStep.name, stepName, QueryCriterionType.Is);

        List<ChainStep> found = getStep(query);

        if (found.size() > 1) {

            throw new WorkerException("more than one chainStep found for " + query);

        }

        if (found.size() == 1) {

            // check the chainStep is in the chain

            ChainStep inChain = chain.getStep(queryNextStep);

            if (inChain == null) {

                chain.insertStep(found.get(0));

            }

            // TODO check found.get(0) == inChain

            return found.get(0);

        } else {

            ChainStep newOne = createStep(stepName, queryNextStep);

            chain.insertStep(newOne);

            return newOne;

        }

    }



    @Override

    public void deleteChain(Chain chain) {

        if (chain != null) {

            if (shortTermStore != null) {

                this.shortTermStore.deleteChain(chain);

            }

            // do not delete from longterm store just update its status

            if (longTermStore != null) {

                chain.put(Chain.deleted, true);

                for (ChainStep chainStep : chain.getSteps()) {

                    chainStep.put(Chain.deleted, true);

                    steps.offer(new ChainStep(chainStep));

                }

                chains.offer(new Chain(chain));

            }

        }

    }



    public ChainStep createStep(String name, IQuery query) {

        ChainStep chainStep = new ChainStep(name);

        chainStep.importCriteria(query);

        return chainStep;

    }



    @Override

    public void start() throws WorkerException {

        if (timer == null) {

            this.timer = new java.util.Timer();



            TimerTask timerTask = new TimerTask() {

                @Override

                public void run() {



                    List<Chain> chainsToStore = new ArrayList<Chain>();

                    chains.drainTo(chainsToStore);

                    longTermStore.storeChains(chainsToStore);



                    List<ChainStep> chainStepsToStore = new ArrayList<ChainStep>();

                    steps.drainTo(chainStepsToStore);

                    longTermStore.storeSteps(chainStepsToStore);

                }

            };

            timer.scheduleAtFixedRate(timerTask, 0, 200);

        }

    }



    @Override

    public void stop() throws WorkerException {

        if (timer != null) {

            timer.cancel();

        }

    }



    public List<Queryable> getItem(IQuery query) {

        return itemStore.fetch(query);

    }



    public synchronized Queryable getOrCreateItem(String itemType, IQuery query) {

        List<Queryable> found = itemStore.fetch(query);



        if (found.size() == 1) {

            return found.get(0);

        }



        if (found.size() > 1) {

            throw new WorkerException("Only one item expected for " + query);

        }



        return createItem(itemType, query);

    }



    private Queryable createItem(String itemType, IQuery query) {

        Queryable newOne = new Queryable();

        newOne.importCriteria(query);

        newOne.setType(itemType);

        return newOne;

    }



    public synchronized void saveItem(Queryable item) {

        this.itemStore.save(item);

    }



    @Override

    public synchronized void complete(Chain chain) {

        getLogger().debug("Complete chain ... ");

        if (chain != null) {

            if (shortTermStore != null) {

                this.shortTermStore.deleteChain(chain);

            }

            chains.offer(new Chain(chain));

        }

        getLogger().debug("Chain completed ... ");

    }



    public IChainStore getShortTermStore() {

        return shortTermStore;

    }

    public IChainStore getLongTermStore() {

        return longTermStore;

    }



    public void setShortTermStore(IChainStore shortTermStore) {

        this.shortTermStore = shortTermStore;

    }

}package sgcib.tmon.worker.chain;



import java.io.Serializable;

import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.UUID;

import java.util.concurrent.TimeUnit;



import org.elasticsearch.common.collect.ImmutableList;

import org.joda.time.DateTime;



import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;



/**

* Created by Stephane on 01/04/2015.

*/

public class ChainStep extends Queryable implements Serializable {



    public static String status = "status";

    /**

     * TimeUnit

     */

    public static String unit = "unit";

    /**

     * long : duration expressed in unit

     */

    public static String duration = "duration";

    /**

     * long : durationFromChainStart expressed in unit

     */

    public static String durationFromChainStart = "durationFromChainStart";

    /**

     * List of Queryable

     */

    public static String stepEvents = "stepEvents";

    /**

     * UUID : parent id (in the chain or the sequence)

     */

    public static String parent = "parent";

    /**

     * UUID : chain id

     */

    public static String chain = "chain";

    /**

     * DateTime : beginning of the sequence

     */

    public static String start = "start";

    /**

     * DateTime : end of the sequence

     */

    public static String stop = "stop";



    public ChainStep() {

        super("chainStep");

        setTimestamp(DateTime.now());

        setStepEvents(new ArrayList<Queryable>());

    }



    public ChainStep(Map data) {

        super(data);

        setType("chainStep");

        if (data.get(ChainStep.stepEvents) instanceof ArrayList || data.get(ChainStep.stepEvents) == null) {

            this.put(ChainStep.stepEvents, Queryable.transformToList((ArrayList) data.get(ChainStep.stepEvents), Queryable.class));

        }

    }



    public ChainStep(String name) {

        super(name, "chainStep");

        setId(UUID.randomUUID().toString());

        setUnit(TimeUnit.MILLISECONDS);

        setTimestamp(DateTime.now());

        setStepEvents(new ArrayList<Queryable>());

    }



    public ChainStep(String name, int duration, DateTime stop) {

        super(name, "chainStep");

        setId(UUID.randomUUID().toString());

        setStop(stop);

        setUnit(TimeUnit.MILLISECONDS);

        setDuration(duration);

        setStart(stop.minusMillis(duration));

        setTimestamp(DateTime.now());

        setStepEvents(new ArrayList<Queryable>());

    }



    public ChainStep(String name, DateTime start, int duration) {

        super(name, "chainStep");

        setId(UUID.randomUUID().toString());

        setStart(start);

        setUnit(TimeUnit.MILLISECONDS);

        setDuration(duration);

        setTimestamp(DateTime.now());

        setStepEvents(new ArrayList<Queryable>());

    }



    public DateTime getStart() {

        return this.getValueAsDateTime(ChainStep.start);

    }



    public void setStart(DateTime start) {

        if (start != null) {

            put(ChainStep.start, start);

            if (getStop() != null) {

                setDuration(getStop().getMillis() - getStart().getMillis());

            }

        }

    }



    public DateTime getStop() {

        return this.getValueAsDateTime(ChainStep.stop);

    }



    public void setStop(DateTime stop) {

        if (stop != null) {

            put(ChainStep.stop, stop);

            if (getStart() != null) {

                setDuration(getStop().getMillis() - getStart().getMillis());

            }

        }

    }



    public TimeUnit getUnit() {

        return (TimeUnit) get(ChainStep.unit);

    }



    public void setUnit(TimeUnit unit) {

        put(ChainStep.unit, unit);

   }



    public long getDuration() {

        if(get(ChainStep.duration) != null)

            return new Long(get(ChainStep.duration).toString());

        return 0;

    }



    public long getDurationFromStart() {

        if(get(ChainStep.durationFromChainStart) != null)

            return new Long(get(ChainStep.durationFromChainStart).toString());

        return 0;

    }



    public void setDuration(long duration) {

        put(ChainStep.duration, duration);

    }



    public String getChain() {

        return (String) get(ChainStep.chain);

    }



    public void setChain(String chainId) {

        put(ChainStep.chain, chainId);

    }



    public String getStatus() {

        return (String) get(ChainStep.status);

    }



    public void setStatus(String status) {

        put(ChainStep.status, status);

    }



    public ChainStep insertAsStepAndTouchDuration(Event received, String... fieldsToCopy) {

        return insertAsStep(received, fieldsToCopy).touchDuration();

    }



    public ChainStep insertAsStep(Event event, String... fieldsToCopy) {

        Queryable stepEvent = new Queryable();

        stepEvent.copyFields(event, true, fieldsToCopy);

        stepEvent.setTimestamp(event.getTimestamp());

        stepEvent.setId(event.getId());

        getStepEvents().add(stepEvent);

        return this;

    }



    public ChainStep touchDuration() {

        DateTime minTime = null;

        DateTime maxTime = null;



        List<Queryable> stepEvents = ImmutableList.copyOf(getStepEvents());

        if (null != stepEvents) {

            for (Queryable stepEvent : stepEvents) {

                DateTime timestamp = stepEvent.getTimestamp();



                if (minTime == null || minTime.isAfter(timestamp)) {

                    minTime = timestamp;

                }

                if (maxTime == null || maxTime.isBefore(timestamp)) {

                    maxTime = timestamp;

                }

            }

            if (minTime != null) {

                setStart(minTime);

            }

            if (maxTime != null) {

                setStop(maxTime);

            }

        }



        return this;

    }



    public ChainStep promote(Queryable other, boolean overrideIfPresent, String... fieldsToCopy) {

        copyFields(other, overrideIfPresent, fieldsToCopy);

        return this;

    }



    public synchronized ChainStep linkToParent(String parentStepName, Chain chain, IQuery query) {

        if (null == getParent()) {

            query.addCriterion(ChainStep.name, parentStepName, QueryCriterionType.Is);

            ChainStep parent = chain.getStep(query);

            if (parent != null) {

                setParent(parent.getId());

            }

        }

        return this;

    }



    public synchronized Queryable insertNewStep(DateTime timestamp, String type) {

        Queryable stepEvent = new Queryable();

        stepEvent.setTimestamp(timestamp);

        stepEvent.put(Queryable.type, type);

        getStepEvents().add(stepEvent);

        return stepEvent;

    }



    public List<Queryable> getStepEvents() {

        return (List<Queryable>) get(ChainStep.stepEvents);

    }



    public void setStepEvents(List<Queryable> stepEvents) {

        put(ChainStep.stepEvents, stepEvents);

    }



    public void setParent(String parentId) {

        put(ChainStep.parent, parentId);

    }



    public String getParent() {

        return (String) get(ChainStep.parent);

    }

}

package sgcib.tmon.worker.chain;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.store.chain.MemoryChainStore;



import java.util.List;



/**

* Created by Stephane on 01/04/2015.

*/

public interface IChainManager extends IManageable {



    /**

     * Return an instance of {@link Chain} according to the given ID {@code id}.

     *

     * @param id

     *            Unique ID.

     * @throws WorkerException

     */

    Chain getChain(String id) throws WorkerException;



    List<Chain> getChain(IQuery query) throws WorkerException;



    void saveChain(Chain chain) throws WorkerException;



    Chain getOrCreateChain(IQuery query) throws WorkerException;



    void deleteChain(Chain chain) throws WorkerException;



    ChainStep getStep(String id) throws WorkerException;



    List<ChainStep> getStep(IQuery query) throws WorkerException;



    void saveStep(ChainStep step) throws WorkerException;



    ChainStep getOrCreateStep(String name, IQuery query) throws WorkerException;



    ChainStep getOrCreateStepOfChain(Chain chain, String stepName, IQuery querynextStep);



    /**

     * Manage stores state according to the given chain {@code chain}. Long term

     * store can't be properly updated if short term store is cleaned just

     * before. For instance, if shortTermStore in an instance of

     * {@link MemoryChainStore} and longTermStore is an instance of

     * {@link MemoryChainStore} too, calling {@code deleteChain} has no sense.

     */

    void complete(Chain chain);





}

package sgcib.tmon.worker.chain;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.model.Queryable;



import java.util.Map;

import java.util.UUID;



/**

* Created by Stephane on 18/04/2015.

*/

public class Latency extends Queryable {

    public static String chain = "chain";

    public static String in = "in";

    public static String out = "out";

    public static String startTime = "startTime";

    public static String stopTime = "stopTime";

    public static String duration = "duration";





    public Latency(Map data) {

        super(data);

    }



    public Latency(String chain, String in, String out, DateTime startTime, DateTime stopTime, long duration) {

        super(in+"-"+out,"latency");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Latency.chain, chain.toString());

        put(Latency.in, in);

        put(Latency.out,out);

        put(Latency.startTime,startTime);

        put(Latency.stopTime,stopTime);

        put(Latency.duration, duration);

    }



    public Latency(String chain, String in, String out, DateTime startTime, int duration) {

        super(in + "-" + out, "latency");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Latency.chain, chain.toString());

        put(Latency.in, in);

        put(Latency.out,out);

        put(Latency.startTime,startTime);

        put(Latency.stopTime,startTime.plusMillis(duration));

        put(Latency.duration,duration);

    }



    public Latency(String chain, String in, String out, int duration, DateTime stopTime) {

        super(in+"-"+out,"latency");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Latency.chain, chain.toString());

        put(Latency.in, in);

        put(Latency.out,out);

        put(Latency.startTime,stopTime.minusMillis(duration));

        put(Latency.stopTime,stopTime);

        put(Latency.duration,duration);

    }



    public Latency(String chain, String in, String out, DateTime startTime, DateTime stopTime) {

        super(in + "-" + out, "latency");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        put(Latency.chain, chain.toString());

        put(Latency.in, in);

        put(Latency.out,out);

        put(Latency.startTime,startTime);

        put(Latency.stopTime,stopTime);

        if(null!=startTime && null!=stopTime)

            put(Latency.duration, stopTime.getMillis()-startTime.getMillis());

    }



    public String getChain() {

        return (String) get(Latency.chain);

    }



    public String getIn() {

        return (String) get(Latency.in);

    }



    public String getOut() {

        return (String) get(Latency.out);



    }



    public DateTime getStartTime() {

        return (DateTime) get(Latency.startTime);

    }

    public void setStartTime(DateTime startTime) {

        put(Latency.startTime, startTime);

        put(Latency.duration, getStopTime().getMillis()-startTime.getMillis());

    }



    public DateTime getStopTime() {

        return (DateTime) get(Latency.stopTime);

    }

    public void setStopTime(DateTime stopTime) {

        put(Latency.stopTime, stopTime);

        put(Latency.duration, stopTime.getMillis()-getStartTime().getMillis());

    }



    public long getDuration() {

        return (long) get(Latency.duration);

    }



}

package sgcib.tmon.worker.cluster;



import java.util.List;

import java.util.concurrent.CountDownLatch;

import java.util.concurrent.TimeUnit;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.locks.Lock;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;



import com.hazelcast.config.Config;

import com.hazelcast.config.JoinConfig;

import com.hazelcast.config.NetworkConfig;

import com.hazelcast.config.QueueConfig;

import com.hazelcast.config.QueueStoreConfig;

import com.hazelcast.core.Hazelcast;

import com.hazelcast.core.HazelcastInstance;

import com.hazelcast.core.IMap;

import com.hazelcast.core.IQueue;

import com.hazelcast.core.ITopic;

import com.hazelcast.core.Message;

import com.hazelcast.core.MessageListener;



/**

* Created by Stephane on 15/06/2015.

*/

public class ClusterManager extends ManageableBase implements IClusterManager, MessageProducer, MessageBroker {

    private int communicationPort;

    private List<String> members;

    private HazelcastInstance instance;

    private Thread masterThread;

    private AtomicBoolean isMaster;

    private CountDownLatch isRunning;



    public ClusterManager() {

        super("ClusterManager");

        this.communicationPort = getConfiguration().getClusterPort();

        this.members = getConfiguration().getMembers();



    }



    public ClusterManager(List<String> members, int communicationPort) {

        super("ClusterManager");

        this.communicationPort = communicationPort;

        this.members = members;

    }



    @Override

    public void start() throws WorkerException {

        getLogger().info("Starting StreamManager ...");

        if (this.instance != null) {

            stop();

        }

        try {

            getLogger().info("Creating distributed cache");

            Config configuration = buildConfig();

            this.instance = Hazelcast.newHazelcastInstance(configuration);

            this.isMaster = new AtomicBoolean(false);

            WorkerContext.getInstance().setMaster(false);

            this.isRunning = new CountDownLatch(1);



            this.masterThread = new Thread() {

                @Override

                public void run() {

                    try {

                        if (instance == null || isRunning.getCount() == 0) {

                            return;

                        }

                        do {

                            getLogger().debug("Trying to acquire master token ...");

                            Lock masterLock = instance.getLock("masterLock");



                            if (masterLock.tryLock(100, TimeUnit.MILLISECONDS)) {

                                try {

                                    isMaster.set(true);

                                    WorkerContext.getInstance().setMaster(true);

                                    getLogger().info("Master token acquired ...");

                                    isRunning.await();

                                } finally {

                                    masterLock.unlock();

                                    WorkerContext.getInstance().setMaster(false);

                                    isMaster.set(false);

                                }

                            } else {

                                WorkerContext.getInstance().setMaster(false);

                                isMaster.set(false);

                            }

                        } while (!isRunning.await(100, TimeUnit.MILLISECONDS));

                    } catch (InterruptedException error) {

                        getLogger().error("Interrupting master thread", error);

                        WorkerContext.getInstance().setMaster(false);

                        isMaster.set(false);

                    } finally {

                        WorkerContext.getInstance().setMaster(false);

                        isMaster.set(false);

                    }

                    getLogger().info("Leaving master thread");



                }

            };

            this.masterThread.start();

        } finally {

            getLogger().info("... StreamManager started.");

        }

    }



    private Config buildConfig() {

        Config configuration = new Config();



        if (this.communicationPort != 0) {

            configuration.getNetworkConfig().setPort(this.communicationPort);

            configuration.getNetworkConfig().setPortAutoIncrement(false);

        } else {

            configuration.getNetworkConfig().setPortAutoIncrement(true);

        }



        if (this.members != null) {

            NetworkConfig network = configuration.getNetworkConfig();

            JoinConfig join = network.getJoin();

            join.getMulticastConfig().setEnabled(false);

            for (String member : this.members) {

                join.getTcpIpConfig().addMember(member);

            }

            join.getTcpIpConfig().setEnabled(true);

        }



        return configuration;

    }



    @Override

    public void stop() throws WorkerException {

        if (this.instance != null) {

            this.isRunning.countDown();

            try {

                this.masterThread.join(1000);

            } catch (InterruptedException error) {

                getLogger().error("Error stopping master thread", error);

            }

            this.masterThread = null;

            this.instance.shutdown();

            this.instance = null;

        }

    }



    @Override

    public boolean isMaster() {

        return isMaster.get();

    }



    @Override

    public boolean isRunning() {

        return (isRunning.getCount() > 0);

    }



    private class Listener<T> implements MessageListener<T> {

        private final MessageConsumer consumer;



        public Listener(MessageConsumer consumer) {

            this.consumer = consumer;

        }



        @Override

        public void onMessage(Message<T> message) {

            if (this.consumer != null) {

                if (message != null && message.getSource() != null) {

                    this.consumer.onMessage(message.getSource().toString(), message.getMessageObject());

                }

            }

        }

    }



    @Override

    public void register(String topicName, MessageConsumer consumer) {

        if (topicName != null && consumer != null) {

            Listener<Object> listener = new Listener<Object>(consumer);

            if (instance != null) {

                ITopic<Object> topic = instance.getTopic(topicName);

                if (topic != null) {

                    topic.addMessageListener(listener);

                }

            }

        }

    }



    @Override

    public <T extends Queryable> IQueue<T> getQueue(String queueName, int maxSize, int backUpCount) {

        if (instance != null) {

            QueueConfig queueConfig = new QueueConfig();

            queueConfig.setName(getName()).setBackupCount(0).setAsyncBackupCount(backUpCount).setMaxSize(maxSize).setStatisticsEnabled(true);

            QueueStoreConfig queueStoreConfig = new QueueStoreConfig();

            queueStoreConfig.setEnabled(false);

            queueConfig.setQueueStoreConfig(queueStoreConfig);

            instance.getConfig().addQueueConfig(queueConfig);

            return instance.getQueue(queueName);

        }

        return null;

    }



    @Override

    public <T extends Queryable> IMap<String, T> getMap(String mapName) {

        if (instance != null) {

            return instance.getMap(mapName);

        }

        return null;

    }



    @Override

    public <T> void send(String topicName, T data) throws WorkerException {

        getLogger().info(String.format("Sending data to topic %s ...", topicName));

        if (this.instance != null) {

            try {

                ITopic<T> topic = instance.getTopic(topicName);

                if (topic != null) {

                    topic.publish(data);

                    getLogger().info(String.format("... data sent to topic %s", topicName));

                }

            } catch (Exception error) {

                throw new WorkerException("Sending message failed", error);

            } finally {

                getLogger().debug(String.format("Message sent on topic %s", topicName));

            }

        }

    }

}

package sgcib.tmon.worker.cluster;



import com.hazelcast.core.IMap;

import com.hazelcast.core.IQueue;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Queryable;



import java.util.concurrent.BlockingQueue;



/**

* Created by Stephane on 15/06/2015.

*/

public interface IClusterManager extends IManageable {



    boolean isMaster();



    boolean isRunning();



    <T extends Queryable> IQueue<T> getQueue(String queueName, int maxSize, int backUpCount);



    <T extends Queryable> IMap<String,T> getMap(String mapName);

}

package sgcib.tmon.worker.cluster;



/**

* Created by Stephane on 19/06/2015.

*/

public interface MessageBroker {

    void register(String topicName, MessageConsumer consumer);

}

package sgcib.tmon.worker.cluster;



/**

* Created by Stephane on 28/02/2015.

*/

public interface MessageConsumer {

    <T> void onMessage(String topicName, T data);

}

package sgcib.tmon.worker.cluster;



import sgcib.tmon.worker.common.exception.WorkerException;



/**

* Created by Stephane on 28/02/2015.

*/

public interface MessageProducer {

    <T> void send(String topicName, T data) throws WorkerException;

}

package sgcib.tmon.worker.cluster;



import java.util.concurrent.atomic.AtomicReference;



/**

* Context of Worker, state (master or not). Singleton with holder pattern is

* used.

*/

public class WorkerContext {



    private AtomicReference<Boolean> isMaster = new AtomicReference<Boolean>(false);

    private boolean clusterEnable;



    private WorkerContext() {

    }



    public void setMaster(boolean master) {

        isMaster.set(master);

    }



    /**

     * Return {@code true} if the current worker is master. The default value is

     * set to {@code false}.

     */

    public boolean isMaster() {

        return isMaster.get();

    }



    public static WorkerContext getInstance() {

        return WorkerContextHolder.instance;

    }



    public void setClusterEnable(boolean clusterEnable) {

        this.clusterEnable = clusterEnable;

    }



    public boolean getClusterEnable() {

        return clusterEnable;

    }



    private static class WorkerContextHolder {

        private final static WorkerContext instance = new WorkerContext();

    }

}

package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;



/**

* @author ablaszcz120213

*

*/

public class AlertManagerConfiguration {



    public static final long DEFAULT_ALERT_MANAGER_TTL = 5;

    public static final long DEFAULT_ALERT_MANAGER_SIZE = 1000;



    @JsonProperty

    private long ttl;



    @JsonProperty

    private long size;



    public AlertManagerConfiguration() {

    }



    public long getTTL() {

        return ttl == 0 ? DEFAULT_ALERT_MANAGER_TTL : ttl;

    }



    public void setTTL(long ttl) {

        this.ttl = ttl;

    }



    public long getSize() {

        return size == 0 ? DEFAULT_ALERT_MANAGER_SIZE : size;

    }



    public void setSize(long size) {

        this.size = size;

    }

}

package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;



/**

* @author ablaszcz120213

*

*/

public class AlertServiceConfiguration {



    public static final long DEFAULT_ALERT_SERVICE_TTL = 5;

    public static final long DEFAULT_ALERT_SERVICE_SIZE = 1000;



    @JsonProperty

    private long ttl;



    @JsonProperty

    private long size;



    public AlertServiceConfiguration() {

    }



    public long getTTL() {

        return ttl == 0 ? DEFAULT_ALERT_SERVICE_TTL : ttl;

    }



    public void setTTL(long ttl) {

        this.ttl = ttl;

    }



    public long getSize() {

        return size == 0 ? DEFAULT_ALERT_SERVICE_SIZE : size;

    }



    public void setSize(long size) {

        this.size = size;

    }

}

package sgcib.tmon.worker.configuration;



import io.dropwizard.Configuration;

import sgcib.tmon.worker.common.store.chain.AsyncChainStore;



import com.fasterxml.jackson.annotation.JsonProperty;



/**

* @author ablaszcz120213

*

*/

public class AsyncPollerConfiguration extends Configuration {



    /**

     * Default value of number of threads to poll event's blocking queue. This

     * is used in {@link AsyncChainStore}.

     */

    public static final int DEFAULT_ASYNC_THREADS = 5;



    /**

     * Default packet size of drained events each time

     */

    public static final int DEFAULT_PACKET_SIZE = 500;



    @JsonProperty

    private int threads;



    @JsonProperty

    private int size;



    public int getThreads() {

        return this.threads == 0 ? DEFAULT_ASYNC_THREADS : this.threads;

    }



    public void setThreads(int threads) {

        this.threads = threads;

    }



    public int getSize() {

        return this.size == 0 ? DEFAULT_PACKET_SIZE : this.size;

    }



    public void setSize(int size) {

        this.size = size;

    }

}

package sgcib.tmon.worker.configuration;



import java.util.Arrays;

import java.util.concurrent.TimeUnit;



import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Value;

import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;

import org.springframework.cache.CacheManager;

import org.springframework.cache.annotation.EnableCaching;

import org.springframework.cache.guava.GuavaCache;

import org.springframework.cache.support.SimpleCacheManager;

import org.springframework.context.annotation.Bean;

import org.springframework.context.annotation.Configuration;

import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;

import org.springframework.core.io.ClassPathResource;



import com.google.common.cache.CacheBuilder;



/**

* @author ablaszcz120213

*

*/

@Configuration

@EnableCaching

public class CacheConfiguration {



    private static final Logger logger = LoggerFactory.getLogger(CacheConfiguration.class);



    private static final String WORKER_YAML = "worker.yaml";



    // Cache names

    public static final String CACHE_ALERT = "alert";

    public static final String CACHE_ALERT_BY_ID = "alertById";



    // @Value attributes come from worker.yaml file. If not present, the default

    // value is used (after colon).



    @Value("${cache.alertService.ttl:5}")

    private long alertServiceTTL;



    @Value("${cache.alertService.size:1000}")

    private long alertServiceSize;



    @Value("${cache.alertManager.ttl:5}")

    private long alertManagerTTL;



    @Value("${cache.alertManager.size:1000}")

    private long alertManagerSize;



    /**

     * Specialization of PlaceholderConfigurerSupport that resolves ${...}

     * placeholders within bean definition property values and @Value

     * annotations against the current Spring Environment and its set of

     * PropertySources. Property values come from worker.yaml file.

     */

    @Bean

    public static PropertySourcesPlaceholderConfigurer properties() {

        PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = new PropertySourcesPlaceholderConfigurer();

        YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean();

        yaml.setResources(new ClassPathResource(WORKER_YAML));

        propertySourcesPlaceholderConfigurer.setProperties(yaml.getObject());

        return propertySourcesPlaceholderConfigurer;

    }



    /**

     * Spring's SimpleCacheManager wraps multiple Guava Caches.

     */

    @Bean

    public CacheManager cacheManager() {



        logger.info("Initializing Guava cache manager with Spring");



       SimpleCacheManager simpleCacheManager = new SimpleCacheManager();



        GuavaCache alert = new GuavaCache(CACHE_ALERT, CacheBuilder.newBuilder() //

                .expireAfterAccess(alertServiceTTL, TimeUnit.MINUTES) //

                .maximumSize(alertServiceSize) //

                .build());



        GuavaCache alertById = new GuavaCache(CACHE_ALERT_BY_ID, CacheBuilder.newBuilder() //

                .expireAfterAccess(alertManagerTTL, TimeUnit.MINUTES) //

                .maximumSize(alertManagerSize) //

                .build());



        simpleCacheManager.setCaches(Arrays.asList(alert, alertById));



        return simpleCacheManager;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;



import java.util.List;



/**

* Created by Stephane on 11/04/2015.

*/

public class ChainRuleConfiguration extends RuleConfiguration {

    public static String pollChain = "pollChain";

    public static String pollStep = "pollStep";

    public static String reloadQuery = "reloadQuery";



    public ChainRuleConfiguration() {

        super(TaskType.ChainRule);

        put(ChainRuleConfiguration.pollChain, false);

        put(ChainRuleConfiguration.pollStep, false);

    }



    public ChainRuleConfiguration(String name, List<String> rules, boolean pollChain, boolean pollStep) {

        super(name, rules, TaskType.ChainRule);

        put(ChainRuleConfiguration.pollChain, pollChain);

        put(ChainRuleConfiguration.pollStep, pollStep);

    }



    public ChainRuleConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public boolean getPollChain() {

        return (boolean) get(ChainRuleConfiguration.pollChain);

    }



    public String getReloadQuery() {

        return (String) get(ChainRuleConfiguration.reloadQuery);

    }



    public boolean getPollStep() {

        return (boolean) get(ChainRuleConfiguration.pollStep);

    }

}

package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;

import io.dropwizard.Configuration;

import org.hibernate.validator.constraints.NotEmpty;



import java.util.List;



/**

* Created with IntelliJ IDEA.

* User: slopes041604

* Date: 12/10/13

* Time: 2:36 PM

* To change this template use File | Settings | File Templates.

*/

public class ClusterConfiguration extends Configuration {



    @NotEmpty

    @JsonProperty

    private String name;



    @NotEmpty

    @JsonProperty

    private String bindAddress;



   @NotEmpty

    @JsonProperty

    private String bindPort;



    @NotEmpty

    @JsonProperty

    private String members;



    @JsonProperty

    private List<ParameterConfiguration> parameters;



    @JsonProperty

    private boolean concentrator;



    public ClusterConfiguration(String name, String bindAddress, String bindPort, String members, boolean concentrator) {

        this.name = name;

        this.bindAddress = bindAddress;

        this.bindPort = bindPort;

        this.members = members;

        this.concentrator = concentrator;

    }



    public ClusterConfiguration() {

        this.bindAddress = "127.0.0.1";

        this.bindPort = "12000";

        this.members = "127.0.0.1:12000";

        this.concentrator = false;

    }



    public String getName() {

        return name;

    }



    public String getBindAddress() {

        return bindAddress;

    }



    public String getBindPort() {

        return bindPort;

    }







    public List<ParameterConfiguration> getParameters() {

        return parameters;

    }



    public boolean isConcentrator() {

        return concentrator;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



/**

* Created by Stephane on 27/02/2015.

*/

public class ConverterConfiguration extends TaskConfiguration {

    public static String fieldsToConvert = "fieldsToConvert";



    public ConverterConfiguration() {

        super("", TaskType.Convert);

        put(ConverterConfiguration.fieldsToConvert,new ConcurrentHashMap<String, String>());

    }



    public ConverterConfiguration(String name, Map<String, String> fieldsToConvert) {

        super(name, TaskType.Convert);

        put(ConverterConfiguration.fieldsToConvert,fieldsToConvert);

    }



    public ConverterConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public Map<String, String> getFieldsToConvert() {

        return (Map<String, String>) get(ConverterConfiguration.fieldsToConvert);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.ArrayList;

import java.util.HashMap;





public class DropConfiguration extends TaskConfiguration {

    public static String dropQuery = "dropQuery";

    public static String eventDeclaration = "eventDeclaration";



    public DropConfiguration() {

        super("", TaskType.Drop);

        put(DropConfiguration.dropQuery, null);

    }



    public DropConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public DropConfiguration(String name, HashMap<String, String>  dropQuery) {

        super(name, TaskType.Drop);

        put(DropConfiguration.dropQuery, dropQuery);

    }



    public HashMap<String, String> getDropQuery()  {

        return (HashMap<String, String>)get(DropConfiguration.dropQuery);

    }



    public ArrayList getEventDeclaration(){



        if(get(DropConfiguration.eventDeclaration) instanceof ArrayList)

                return (ArrayList)get(DropConfiguration.eventDeclaration);



        return null;

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}

package sgcib.tmon.worker.configuration;



/**

* Created by pdedaran120210 on 29/06/2015.

*/

public  class EnumHelper {

    public static <T extends Enum<?>> T searchEnum(Class<T> enumeration,

                                                   String search) {

        for (T each : enumeration.getEnumConstants()) {

           if (each.name().compareToIgnoreCase(search) == 0) {

                return each;

            }

        }

        return null;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by slopes041604 on 29/05/2015.

*/

public class FeatureTrackingConfiguration extends TaskConfiguration {

    public static String dataEventType = "dataEventType";

    public static String dataFeatureField = "dataFeatureField";

    public static String ticketEventName = "ticketEventName";

    public static String ticketFeatureField = "ticketFeatureField";

    public static String initialStatus = "initialStatus";

    public static String releaseStatus = "releaseStatus";

    public static String synchroFrequencyInHour = "synchroFrequencyInHour";





    public FeatureTrackingConfiguration() {

        super("", TaskType.FeatureTracking);

        put(FeatureTrackingConfiguration.dataEventType, null);

        put(FeatureTrackingConfiguration.dataFeatureField, null);

        put(FeatureTrackingConfiguration.ticketEventName, null);

        put(FeatureTrackingConfiguration.ticketFeatureField, null);

        put(FeatureTrackingConfiguration.releaseStatus, null);

        put(FeatureTrackingConfiguration.initialStatus, null);

        put(FeatureTrackingConfiguration.synchroFrequencyInHour, 0);

    }



    public FeatureTrackingConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public FeatureTrackingConfiguration(String name, String featureEventName, String eventFeatureField, String ticketEventName, String ticketFeatureField,String initialStatus,String releaseStatus, int synchroFrequencyInHour) {

        super(name, TaskType.FeatureTracking);

        put(FeatureTrackingConfiguration.dataEventType, featureEventName);

        put(FeatureTrackingConfiguration.dataFeatureField, eventFeatureField);

        put(FeatureTrackingConfiguration.ticketEventName, ticketEventName);

       put(FeatureTrackingConfiguration.ticketFeatureField, ticketFeatureField);

        put(FeatureTrackingConfiguration.synchroFrequencyInHour, synchroFrequencyInHour);

        put(FeatureTrackingConfiguration.releaseStatus, releaseStatus);

        put(FeatureTrackingConfiguration.initialStatus, initialStatus);

    }



    public String getDataEventType() {

        return (String) get(FeatureTrackingConfiguration.dataEventType);

    }



    public String getDataEventField() {

        return (String) get(FeatureTrackingConfiguration.dataFeatureField);

    }



    public String getTicketEventName() {

        return (String) get(FeatureTrackingConfiguration.ticketEventName);

    }



    public String getTicketFeatureField() {

        return (String) get(FeatureTrackingConfiguration.ticketFeatureField);

    }



    public String getReleaseStatus() {

        return (String) get(FeatureTrackingConfiguration.releaseStatus);

    }



    public String getInitialStatus() {

        return (String) get(FeatureTrackingConfiguration.initialStatus);

    }



    public int getSynchroFrequencyInHour() {

        return Integer.parseInt(get(FeatureTrackingConfiguration.synchroFrequencyInHour).toString());

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.List;



/**

* Created by Stephane on 27/02/2015.

*/

public class FilterConfiguration extends TaskConfiguration {

    public static String fieldsToFilter = "fieldsToFilter";



    public FilterConfiguration() {

        super("", TaskType.Filter);

        put(FilterConfiguration.fieldsToFilter, null);

    }



    public FilterConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public FilterConfiguration(String name, List<String> fieldsToFilter) {

        super(name, TaskType.Filter);

        put(FilterConfiguration.fieldsToFilter, fieldsToFilter);

    }



    public List<String> getFieldsToFilter() {

        return (List<String>) get(FilterConfiguration.fieldsToFilter);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by adouangp012014 on 16/06/2015.

*/

public interface IConfiguration {



    CheckResult check();



}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.Map;



/**

* Created by Stephane on 27/02/2015.

*/

public class MapperConfiguration extends TaskConfiguration {

    public static String fieldsToMap = "fieldsToMap";



    public MapperConfiguration() {

        super("", TaskType.Map);

        put(MapperConfiguration.fieldsToMap,null);

    }



    public MapperConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public MapperConfiguration(String name, Map<String, String> fieldsToMap) {

        super(name, TaskType.Map);

        put(MapperConfiguration.fieldsToMap,fieldsToMap);

    }



    public Map<String, String> getFieldsToMap() {

        return (Map<String, String>) get(MapperConfiguration.fieldsToMap);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;

import org.hibernate.validator.constraints.NotEmpty;



/**

* Created with IntelliJ IDEA.

* User: slopes041604

* Date: 12/6/13

* Time: 1:55 PM

* To change this template use File | Settings | File Templates.

*/

public class ParameterConfiguration {

    @NotEmpty

    @JsonProperty

    private String key;



    @NotEmpty

    @JsonProperty

    private String value;



    @JsonProperty

    private String type;





    public String getKey() {

        return key;

    }



    public String getValue() {

        return value;

    }



    public String getType() {

        return type;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by Stephane on 15/03/2015.

*/

public class PublisherConfiguration extends TaskConfiguration {

    public static String publisherType = "publisherType";

    public static String topic = "topic";

    public static String poolSize = "poolSize";



    public PublisherConfiguration() {

        super("", TaskType.Publisher);

        put(PublisherConfiguration.publisherType, null);

        put(PublisherConfiguration.topic, null);

        put(PublisherConfiguration.poolSize, 1);

    }



    public PublisherConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public PublisherConfiguration(String name, PublisherConfigurationType publisherType, String topic, int poolSize) {

        super(name, TaskType.Publisher);

        put(PublisherConfiguration.publisherType, publisherType);

        put(PublisherConfiguration.topic, topic);

        put(PublisherConfiguration.poolSize, poolSize);

    }



    public PublisherConfigurationType getPublisherType() {

        return PublisherConfigurationType.valueOf(get(PublisherConfiguration.publisherType).toString());

    }



    public String getTopic() {

        return (String) get(PublisherConfiguration.topic);

    }



    public int getPoolSize() {

        return (Integer) get(PublisherConfiguration.poolSize);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}

package sgcib.tmon.worker.configuration;



/**

* Created by Stephane on 15/03/2015.

*/

public enum PublisherConfigurationType {

                Kafka, Rv, Mail, Ems, Geneos, Bem

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;



/**

* Created by Stephane on 21/06/2015.

*/

public class QueueConfiguration extends TaskConfiguration {



    public static final int MAX_EVENTS_PER_PERIOD = 500;

    public static final int BACKUP_COUNT = 2;

    public static final int QUEUE_MAX_SIZE = 1000000;



    public static String task = "task";

    public static String pollingPeriodInMilliseconds = "pollingPeriodInMilliseconds";

    public static String timeoutInSeconds = "timeoutInSeconds";

    public static String maxEventsPerPeriod = "maxEventsPerPeriod";

    public static String backUpCount = "backUpCount";

    public static String queueMaxSize = "queueMaxSize";



    public QueueConfiguration() {

        super("", TaskType.Queue);

        put(QueueConfiguration.task, null);

        put(QueueConfiguration.pollingPeriodInMilliseconds, 0);

        put(QueueConfiguration.timeoutInSeconds, 0);

        put(QueueConfiguration.maxEventsPerPeriod, MAX_EVENTS_PER_PERIOD);

        put(QueueConfiguration.backUpCount, BACKUP_COUNT);

        put(QueueConfiguration.queueMaxSize, QUEUE_MAX_SIZE);

    }



    public QueueConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public QueueConfiguration(String name, String task, int pollingPeriodInMilliseconds, int timeoutInSeconds, int maxEventsPerPeriod, int backUpCount, int queueMaxSize) {

        super(name, TaskType.Queue);

        put(QueueConfiguration.task, task);

        put(QueueConfiguration.pollingPeriodInMilliseconds, pollingPeriodInMilliseconds);

        put(QueueConfiguration.timeoutInSeconds, timeoutInSeconds);

        put(QueueConfiguration.maxEventsPerPeriod, maxEventsPerPeriod);

        put(QueueConfiguration.backUpCount, backUpCount);

        put(QueueConfiguration.queueMaxSize, queueMaxSize);

    }



    public String getTask() {

        return (String) get(QueueConfiguration.task);

    }



    public int getPollingPeriodInMilliseconds() {

        return Integer.parseInt(get(QueueConfiguration.pollingPeriodInMilliseconds).toString());

    }



    public int getTimeoutInSeconds() {

        return Integer.parseInt(get(QueueConfiguration.timeoutInSeconds).toString());

    }



    public int getMaxEventsPerPeriod() {

        return (int) java.util.Optional.ofNullable(get(QueueConfiguration.maxEventsPerPeriod)).orElse(MAX_EVENTS_PER_PERIOD);

    }



    public int getBackupCount() {

        return (int) java.util.Optional.ofNullable(get(QueueConfiguration.backUpCount)).orElse(BACKUP_COUNT);

    }



    public int getQueueMaxSize() {

        return (int) java.util.Optional.ofNullable(get(QueueConfiguration.queueMaxSize)).orElse(QUEUE_MAX_SIZE);

    }



}

package sgcib.tmon.worker.configuration;



/**

* Created by slopes041604 on 23/10/2015.

*/

public class ReportConfiguration {

    private String url;

    private String member;





    public ReportConfiguration() {

    }



    public ReportConfiguration(String url, String member) {

        this.url = url;

        this.member = member;

    }



    public String getUrl() {

        return url;

    }



    public void setUrl(String url) {

        this.url = url;

    }



    public String getMember() {

        return member;

    }



    public void setMember(String member) {

        this.member = member;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.List;



/**

* Created by Stephane on 31/03/2015.

*/

public class RuleConfiguration extends TaskConfiguration {

    public static String rules = "rules";



    public RuleConfiguration() {

        super("", TaskType.Rule);

        put(RuleConfiguration.rules, null);

    }



    protected RuleConfiguration(TaskType type) {

        super("", type);

        put(RuleConfiguration.rules, null);

    }



    public RuleConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public RuleConfiguration(String name, List<String> rules) {

        super(name, TaskType.Rule);

        put(RuleConfiguration.rules, rules);

    }



    protected RuleConfiguration(String name, List<String> rules, TaskType type) {

        super(name, type);

        put(RuleConfiguration.rules, rules);

    }



    public List<String> getRules() {

        return (List<String>) get(RuleConfiguration.rules);

    }



    @Override

    public CheckResult check() {

        //TODO implement the check like TransformConfiguration

        return new CheckResult();

    }



    @Override

    public void setName(String name)

    {

        super.setName(name);

        setId(name);

    }

}package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.Map;

import java.util.TreeMap;



/**

* Created by Stephane on 24/02/2015.

*/

public class SequenceConfiguration extends TaskConfiguration {

    public static String taskConfigurations = "taskConfigurations";



    public SequenceConfiguration() {

        super("", TaskType.Sequence);

        put(SequenceConfiguration.taskConfigurations, null);

    }



    public SequenceConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public SequenceConfiguration(String name, Map<Integer, String> taskConfigurations) {

        super(name, TaskType.Sequence);

        put(SequenceConfiguration.taskConfigurations, taskConfigurations);

    }



    public Map<Integer, String> getTaskConfigurations() {

         return new TreeMap<Integer, String>((Map<Integer, String>) get(SequenceConfiguration.taskConfigurations));

    }



    @Override

    public CheckResult check() {

        //TODO implement the check like TransformConfiguration

        return new CheckResult();

    }

}



package sgcib.tmon.worker.configuration;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



import java.util.HashMap;

import java.util.Map;



public class SettingsConfiguration extends TaskConfiguration {



    public static final String environment = "environment";

    public static final String version = "version";

    public static final String taskType = "taskType";

    public static final String name = "Settings";

    public static final String key = "key";



    public SettingsConfiguration() {

        setName(name);

        setType("taskConfiguration");

        put(SettingsConfiguration.key, name);

        put(SettingsConfiguration.taskType, "Settings");

        put(SettingsConfiguration.version, 0);

        setTimestamp(DateTime.now());

    }



    public SettingsConfiguration(HashMap<String, Object> data) {

        super(data);

        setTimestamp(DateTime.now());

    }



    public SettingsConfiguration(String name) {

        setName(name);

        setType("taskConfiguration");

        put(SettingsConfiguration.key, name);

        put(SettingsConfiguration.version, 0);

        put(SettingsConfiguration.environment, "DEV");

        setTimestamp(DateTime.now());

    }



    public void setId() {

        //To force usage of name as id

    }



    public String getName() {

        return (String) get(SettingsConfiguration.name);

    }



    public String getEnvironment() {

        return (String) get(SettingsConfiguration.environment);

    }



   @Override

    public CheckResult check() {

        return new CheckResult();

    }

}

package sgcib.tmon.worker.configuration;



import io.dropwizard.Configuration;



import com.fasterxml.jackson.annotation.JsonProperty;



/**

* @author ablaszcz120213

*

*/

public class SpringCacheConfiguration extends Configuration {



    private AlertManagerConfiguration alertManager;



    private AlertServiceConfiguration alertService;



    public SpringCacheConfiguration(@JsonProperty("alertManager") AlertManagerConfiguration alertManager, @JsonProperty("alertService") AlertServiceConfiguration alertService) {

        this.alertManager = alertManager;

        this.alertService = alertService;

    }



    public AlertManagerConfiguration getAlertManager() {

        return alertManager;

    }



    public void setAlertManager(AlertManagerConfiguration alertManager) {

        this.alertManager = alertManager;

    }



    public AlertServiceConfiguration getAlertService() {

        return alertService;

    }



    public void setAlertService(AlertServiceConfiguration alertService) {

        this.alertService = alertService;

    }

}

package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;

import org.hibernate.validator.constraints.NotEmpty;



import java.util.List;



public class StorageConfiguration {



    @NotEmpty

    @JsonProperty

    private String embedded;



    @NotEmpty

    @JsonProperty

    private String cluster;



    @NotEmpty

    @JsonProperty

    private String retentionPeriod;



    @JsonProperty

    private List<String> storageHosts;



    @JsonProperty

    private String[] reportingHosts;



    @JsonProperty

    private int reportingPeriod;



    @JsonProperty

    private List<String> parameters;



    @JsonProperty

    private String dataPath;



    public List<String> getStorageHosts() {

        return storageHosts;

    }



    public String[] getReportingHosts() {

        return reportingHosts;

    }



    public int getReportingPeriod() {

        return reportingPeriod;

    }



    public boolean isEmbedded() {

        return Boolean.valueOf(embedded);

    }



    public String getCluster() {

        return cluster;

    }



    public List<String> getParameters() {

        return parameters;

   }



    public int getRetentionPeriod() {

        return Integer.valueOf(retentionPeriod);

    }



    public String getDataPath() {

        return dataPath;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by Stephane on 18/01/2015.

*/

public class StoreConfiguration extends TaskConfiguration {



    public static String timeOutInMilliseconds = "timeOutInMilliseconds";

    public static String store = "store";



    public StoreConfiguration() {

        super("", TaskType.Store);

        put(StoreConfiguration.timeOutInMilliseconds, 0);

        put(StoreConfiguration.store, "MemoryEventStore");

    }



    public StoreConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public StoreConfiguration(String name, String store, int timeOutInMilliseconds) {

        super(name, TaskType.Store);

        put(StoreConfiguration.timeOutInMilliseconds, timeOutInMilliseconds);

        put(StoreConfiguration.store, store);

    }



    public int getTimeOutInMilliseconds() {

        return (Integer) get(StoreConfiguration.timeOutInMilliseconds);

    }

    public String getStore() {

        return (String) get(StoreConfiguration.store);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}

package sgcib.tmon.worker.configuration;



import java.util.Map;



import org.apache.commons.lang3.StringUtils;

import org.joda.time.DateTime;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.BoundType;

import sgcib.tmon.worker.common.task.StoredTaskFactory;

import sgcib.tmon.worker.common.task.TaskAffinity;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by Stephane on 18/01/2015.

*/

public class TaskConfiguration extends Queryable implements IConfiguration {



    private static final Logger LOGGER = LoggerFactory.getLogger(TaskConfiguration.class);



    public static String taskType = "taskType";

    // public static String version = "version";

    public static String boundType = "boundType";

    public static String runOnMaster = "runOnMaster";

    public static String affinity = "affinity";

    public static String factory = "factory";

    public static String processPoolSize = "processPoolSize";

    public static String processMultiplePoolSize = "processMultiplePoolSize";



    public TaskConfiguration() {

        setType("taskConfiguration");

        setTimestamp(DateTime.now());

    }



    public TaskConfiguration(TaskConfiguration other) {

        if (other != null) {

            this.putAll(other);

            setTimestamp(DateTime.now());

        }

    }



    public TaskConfiguration(Map data) {

        super(data);

        setTimestamp(DateTime.now());

    }



    public TaskConfiguration(String name, TaskType type) {

        super(name, "taskConfiguration");

        put(TaskConfiguration.key, name);

        put(TaskConfiguration.taskType, (type == null) ? "*" : type.toString());

        // put(TaskConfiguration.version, 0);

        put(TaskConfiguration.boundType, BoundType.cpu);

        put(TaskConfiguration.runOnMaster, false);

        put(TaskConfiguration.affinity, TaskAffinity.None);

        put(TaskConfiguration.factory, StoredTaskFactory.defaultFactory);

        setTimestamp(DateTime.now());

    }



    public void setId() {

        // To force usage of name as id

    }



    @Override

    public String getName() {

        return (String) get(TaskConfiguration.name);

    }



    public TaskType getTaskType() {

        return EnumHelper.searchEnum(TaskType.class, get(TaskConfiguration.taskType).toString());

    }



    /*

     * public int getVersion() { return (Integer)

     * get(TaskConfiguration.version); }

     */



    public BoundType getBoundType() {

        return EnumHelper.searchEnum(BoundType.class, get(TaskConfiguration.boundType).toString());

    }



    public Boolean runOnMaster() {

        if (get(TaskConfiguration.runOnMaster) == null || StringUtils.EMPTY.equals(get(TaskConfiguration.runOnMaster).toString().trim())) {

            // LOGGER.error("TaskConfiguration.runOnMaster is null or empty. Check your worker.yaml configuration.");

            return false;

        }

        return Boolean.valueOf(get(TaskConfiguration.runOnMaster).toString());

    }



    public TaskAffinity getAffinity() {

        return EnumHelper.searchEnum(TaskAffinity.class, get(TaskConfiguration.affinity).toString());

    }



    public void setAffinity(TaskAffinity affinity) {

        put(TaskConfiguration.affinity, affinity);

    }



    public int getProcessPoolSize() {

        Object processPoolSize = get(TaskConfiguration.processPoolSize);

        if (processPoolSize != null) {

            return Integer.valueOf(processPoolSize.toString());

        }

        return 10;

    }



    public void setProcessPoolSize(int processPoolSize) {

        put(TaskConfiguration.processPoolSize, processPoolSize);

    }



    public int getProcessMultiplePoolSize() {

        Object processMultiplePoolSize = get(TaskConfiguration.processMultiplePoolSize);

        if (processMultiplePoolSize != null) {

            return Integer.valueOf(processMultiplePoolSize.toString());

        }

        return 10;

    }



    public void setFactory(String factory) {

        put(TaskConfiguration.factory, factory);

    }



    public String getFactory() {

        Object factory = get(TaskConfiguration.factory);

        if (factory != null) {

            return factory.toString();

        }

        return StoredTaskFactory.defaultFactory;

    }



    public void setProcessMultiplePoolSize(int processMultiplePoolSize) {

        put(TaskConfiguration.processMultiplePoolSize, processMultiplePoolSize);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}

package sgcib.tmon.worker.configuration;



import com.fasterxml.jackson.annotation.JsonProperty;

import io.dropwizard.Configuration;

import org.hibernate.validator.constraints.NotEmpty;



import java.util.List;



public class TibcoConfiguration extends Configuration {

                @NotEmpty

                @JsonProperty

                private boolean enabled = false;



                @NotEmpty

                @JsonProperty

                private String service;



                @NotEmpty

                @JsonProperty

                private String network;



                @NotEmpty

                @JsonProperty

                private String daemon;



                @NotEmpty

                @JsonProperty

                private String subject;



                @JsonProperty

                private List<String> whiteList;



                private GenericProcessorConfiguration genericProcessor;



                public boolean isEnabled() {

                                return enabled;

                }



                public void setEnabled(boolean enabled) {

                                this.enabled = enabled;

                }



                public String getService() {

                                return service;

                }



                public void setService(String service) {

                                this.service = service;

                }



                public String getNetwork() {

                                return network;

                }



                public void setNetwork(String network) {

                                this.network = network;

                }



                public String getDaemon() {

                                return daemon;

                }



                public void setDaemon(String daemon) {

                                this.daemon = daemon;

                }



                public String getSubject() {

                                return subject;

                }



                public void setSubject(String subject) {

                                this.subject = subject;

                }



                public List<String> getWhiteList() {

                                return whiteList;

                }



                public void setWhiteList(List<String> whiteList) {

                                this.whiteList = whiteList;

                }



                public GenericProcessorConfiguration getGenericProcessor() {

                                return genericProcessor;

                }



                public void setGenericProcessor(GenericProcessorConfiguration genericProcessor) {

                                this.genericProcessor = genericProcessor;

                }



                public static class GenericProcessorConfiguration extends Configuration {

                                @NotEmpty

                                @JsonProperty

                                private boolean enabled = false;



                                @JsonProperty

                                private List<String> ignoredFields;



                                public boolean isEnabled() {

                                                return enabled;

                                }



                                public void setEnabled(boolean enabled) {

                                                this.enabled = enabled;

                                }



                                public List<String> getIgnoredFields() {

                                                return ignoredFields;

                                }



                                public void setIgnoredFields(List<String> ignoredFields) {

                                                this.ignoredFields = ignoredFields;

                                }

                }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;

import sgcib.tmon.worker.common.utils.VelocityUtils;



/**

* Created by Stephane on 04/01/2015.

*/

public class TransformConfiguration extends TaskConfiguration {

    public static String template = "template";



    public TransformConfiguration() {

        super("", TaskType.Transform);

        put(TransformConfiguration.template, null);

    }



    public TransformConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public TransformConfiguration(String name, String template) {

        super(name, TaskType.Transform);

        put(TransformConfiguration.template, template);

    }



    public String getTemplate() {

        return (String) get(TransformConfiguration.template);

    }



    @Override

    public CheckResult check() {

        CheckResult result = new CheckResult();



        try {

            VelocityUtils.validate(getTemplate());

        } catch (Exception error) {

            result.setError(error);

        }



        return result;

    }

}

package sgcib.tmon.worker.configuration;



import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;



/**

* Created by Stephane on 27/02/2015.

*/

public class UserAgentParserConfiguration extends TaskConfiguration {

    public static String userAgentField = "userAgentField";



    public UserAgentParserConfiguration() {

        super("", TaskType.UserAgent);

        put(UserAgentParserConfiguration.userAgentField, null);

    }



    public UserAgentParserConfiguration(TaskConfiguration configuration) {

        super(configuration);

    }



    public UserAgentParserConfiguration(String name, String userAgentField) {

        super(name, TaskType.UserAgent);

        put(UserAgentParserConfiguration.userAgentField, userAgentField);

    }



    public String getUserAgentField() {

        return (String) get(UserAgentParserConfiguration.userAgentField);

    }



    @Override

    public CheckResult check() {

        return new CheckResult();

    }

}package sgcib.tmon.worker.configuration;



import io.dropwizard.Configuration;



import java.net.InetAddress;

import java.net.UnknownHostException;

import java.util.List;

import java.util.Optional;



import org.hibernate.validator.constraints.NotEmpty;

import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormat;

import org.joda.time.format.DateTimeFormatter;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.common.store.chain.AsyncChainStore;

import sgcib.tmon.worker.service.Mode;



import com.fasterxml.jackson.annotation.JsonProperty;



public class WorkerConfiguration extends Configuration {



    private final static Logger logger = LoggerFactory.getLogger(WorkerConfiguration.class);



    // Mode

    @NotEmpty

    @JsonProperty

    private String mode;



    // Storage

    @JsonProperty

    private StorageConfiguration storage;



    @JsonProperty(required = true)

    private String configurationStore;



    @JsonProperty(required = true)

    private String errorStore;



    @JsonProperty

    private int timeoutInSeconds;



    @JsonProperty

    private String taskNameEntryPoint;



    @JsonProperty

    private int waitForCommit;



    @JsonProperty

    private List<String> members;



    @JsonProperty

    private String hostname;



    @JsonProperty

    private int clusterPort;



    @JsonProperty

    private int ioConcurrency;



    @JsonProperty

    private int networkConcurrency;



    @JsonProperty

    private int cpuConcurrency;



    @JsonProperty

    private String kibanaUrl;



    @JsonProperty

    private String environment;



    @JsonProperty

    private String reportUrl;



    @JsonProperty

    private String reportPort;



    // Tibco RV

    @JsonProperty

    private TibcoConfiguration tibco;



    private DateTimeFormatter formatter;



    /**

     * Parameters used by asynchronous chain store {@link AsyncChainStore}

     * instance.

     */

    @JsonProperty

    private AsyncPollerConfiguration asyncPoller;



    @JsonProperty

    private SpringCacheConfiguration cache;



    public WorkerConfiguration() {

        try {

            this.hostname = InetAddress.getLocalHost().getHostName();

        } catch (UnknownHostException error) {

            logger.error(error.getMessage(), error);

        }



        this.formatter = DateTimeFormat.forPattern("yyyy.MM.dd");



    }



   public Mode getMode() {

        return Enum.valueOf(Mode.class, mode);

    }



    public StorageConfiguration getStorageConfiguration() {

        return storage;

    }



    public String getKibanaUrl() {

        return kibanaUrl;

    }



    public int getTimeoutInSeconds() {

        return timeoutInSeconds;

    }



    public int getWaitForCommit() {

        return waitForCommit;

    }



    public List<String> getMembers() {

        return members;

    }



    public int getClusterPort() {

        return clusterPort;

    }



    public TibcoConfiguration getTibcoConfiguration() {

        return tibco;

    }



    public void setTibcoConfiguration(TibcoConfiguration tibcoConfiguration) {

        this.tibco = tibcoConfiguration;

    }



    public String getEnvironment() {

        return environment;

    }



    public void setAsyncPollerConfiguration(AsyncPollerConfiguration asyncPollerConfiguration) {

        this.asyncPoller = asyncPollerConfiguration;

    }



    public AsyncPollerConfiguration getAsyncPollerConfiguration() {

        return Optional.ofNullable(this.asyncPoller).orElse(new AsyncPollerConfiguration());

    }



    public void setSpringCacheConfiguration(SpringCacheConfiguration springCacheConfiguration) {

        this.cache = springCacheConfiguration;

    }



    public SpringCacheConfiguration getSpringCacheConfiguration() {

        return Optional.ofNullable(this.cache).orElse(new SpringCacheConfiguration(new AlertManagerConfiguration(), new AlertServiceConfiguration()));

    }



    public String getTaskNameEntryPoint() {

        return taskNameEntryPoint;

    }



    public void setReportPort(String reportPort) {

        this.reportPort = reportPort;

    }



    public String getReportPort() {

        return reportPort;

    }



    public String getReportUrl() {

        return reportUrl;

    }



    public String getChainUrl(String chainId) {

        return String.format("http://%s:%s/tmon/#/chain/%s", hostname, getReportPort(), chainId);

    }



    public String getChainStepDataUrl(String chainStepId, DateTime timestamp) {

        return String.format("%s/#/doc/[chain-]YYYY.MM.DD/chain-%s/chainStep/%s", this.kibanaUrl, this.formatter.print(timestamp), chainStepId);

    }



    public String getChainDataUrl(String chainId, DateTime timestamp) {

        return String.format("%s/#/doc/[chain-]YYYY.MM.DD/chain-%s/chain/%s", this.kibanaUrl, this.formatter.print(timestamp), chainId);

    }



    public String getAlertDataUrl(String alertId, DateTime timestamp) {

        return String.format("%s/#/doc/[alert-]YYYY.MM.DD/alert-%s/alert/%s", this.kibanaUrl, this.formatter.print(timestamp), alertId);

    }

}

package sgcib.tmon.worker.extension;



import com.fasterxml.jackson.core.JsonGenerator;

import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.JsonSerializer;

import com.fasterxml.jackson.databind.SerializerProvider;

import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;



import java.io.IOException;



/**

* Created by Stephane on 19/04/2015.

*/

public class DateSerializer extends JsonSerializer<DateTime> {



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    @Override

    public void serialize(DateTime value, JsonGenerator generator, SerializerProvider serializerProvider)

            throws IOException, JsonProcessingException {

        generator.writeString(dateTimeFormatter.print(value));

    }

}package sgcib.tmon.worker.extension;



import com.codahale.metrics.MetricRegistry;

import com.google.common.collect.ImmutableList;

import ro.fortsoft.pf4j.DefaultPluginManager;

import ro.fortsoft.pf4j.PluginClassLoader;

import ro.fortsoft.pf4j.PluginManager;

import ro.fortsoft.pf4j.PluginWrapper;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;





import java.util.HashMap;

import java.util.List;

import java.util.Map;



/**

* Created by Stephane on 08/01/2015.

*/

public class ExtensionManager extends ManageableBase implements IExtensionManager {

    private final PluginManager pluginManager;

    private final Map<String, PluginClassLoader> extensions;



    public ExtensionManager() {

        super("ExtensionManager");

        this.extensions = new HashMap<String, PluginClassLoader>();

        this.pluginManager = new DefaultPluginManager();

        this.pluginManager.loadPlugins();

    }



    @Override

    public void start() throws WorkerException {

        getLogger().info("Loading plugins ...");

        pluginManager.startPlugins();

        for (PluginWrapper plugin : pluginManager.getPlugins()) {

            getLogger().info("Found plugin :" + plugin.getPluginId());

            for (String extension : pluginManager.getExtensionClassNames(plugin.getPluginId())) {

                getLogger().info("Found extension :" + extension);

                this.extensions.put(extension, plugin.getPluginClassLoader());

            }

        }

        getLogger().info("... plugin loaded");

    }



    @Override

    public void stop() throws WorkerException {

        getLogger().info("Unloaded plugins ...");

        this.pluginManager.stopPlugins();

        this.extensions.clear();

        getLogger().info("... plugins unloaded");

    }





    @Override

    public <T extends ITaskFactoryBuilder> List<T> getExtensions(Class extensionClass) {

        getLogger().info(String.format("Get store : %s", extensionClass));

        List<T> extensionList = pluginManager.getExtensions(extensionClass);

        ImmutableList.Builder<T> builder = new ImmutableList.Builder<T>();

        for (T extension : extensionList) {

            builder.add(extension);

        }

        return builder.build();

    }



}

package sgcib.tmon.worker.extension;





package sgcib.tmon.worker.extension;



import ro.fortsoft.pf4j.ExtensionPoint;

import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.store.IStoreManager;

import sgcib.tmon.worker.common.task.ITaskFactory;

import sgcib.tmon.worker.common.task.ITaskManager;



/**

* Created by slopes041604 on 21/10/2015.

*/



package sgcib.tmon.worker.extension;



import com.codahale.metrics.MetricRegistry;

import org.apache.commons.configuration.Configuration;

import org.apache.commons.configuration.ConfigurationException;

import org.apache.commons.configuration.PropertiesConfiguration;

import ro.fortsoft.pf4j.Plugin;

import ro.fortsoft.pf4j.PluginWrapper;



import java.io.File;



/**

* Created by Stephane on 11/01/2015.

*/

public abstract class PluginBase extends Plugin {



    private Configuration configuration;



    /**

     * Constructor to be used by plugin manager for plugin instantiation.

     * Your plugins have to provide constructor with this exact signature to

     * be successfully loaded by manager.

     *

     * @param wrapper

     */

    protected PluginBase(PluginWrapper wrapper) {

        super(wrapper);

        String propertiesFileName = "plugins/" + getWrapper().getPluginId() + ".properties";

        File propertyFile = new File(propertiesFileName);

        try {



            if (propertyFile.exists() && propertyFile.isFile()) {

                this.configuration = new PropertiesConfiguration(propertiesFileName);

            } else {

                log.error("Cannot log property files : file not found");

                this.configuration = new PropertiesConfiguration();

            }

        } catch (ConfigurationException error) {

            log.error("Cannot log property files :" + error.getMessage(), error);

        }

    }



    protected Configuration getConfiguration() {

        return this.configuration;

    }

}

package sgcib.tmon.worker.extension;



import com.google.common.base.Function;

import com.google.common.collect.Maps;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.task.ITaskFactory;



import javax.annotation.Nullable;

import java.util.List;

import java.util.Map;



/**

* Created by Stephane on 14/03/2015.

*/

public class TaskFactoryExtension extends ManageableBase {

    private final IExtensionManager IExtensionManager;

    private final Map<String, ITaskFactory> factories;



    public TaskFactoryExtension(IExtensionManager IExtensionManager) {

        super("TaskFactoryExtension");

        this.IExtensionManager = IExtensionManager;

        this.factories = buildFactories();

    }



    private Map<String, ITaskFactory> buildFactories() {

        if (this.IExtensionManager != null) {

            List builders = this.IExtensionManager.getExtensions(ITaskFactoryBuilder.class);

            if (builders != null && builders.size() > 0) {

                return Maps.uniqueIndex(builders, new Function<ITaskFactoryBuilder, String>() {

                    @Nullable

                    @Override

                    public String apply(ITaskFactoryBuilder builder) {

                        return builder.getName();

                    }

                });

            }

        }

        return null;

    }





    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }

}

package sgcib.tmon.worker.resources;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;



import org.springframework.context.support.GenericXmlApplicationContext;



import sgcib.tmon.worker.common.lifecycle.IService;

import sgcib.tmon.worker.common.store.queryable.AsyncQueryableStore;

import sgcib.tmon.worker.service.Mode;



public class ContextManager {



    private final GenericXmlApplicationContext context;

    private final List<IService> workerServices;

    private final AsyncQueryableStore itemStore;



    public ContextManager(Mode mode) {

        this.context = new GenericXmlApplicationContext();

        this.context.setValidating(false);

        if (mode == Mode.Aggregator) {

            this.context.load(new String[] { "classpath:configuration/aggregator/*.xml", "classpath*:**/plugin-*.xml" });

        } else {

            this.context.load(new String[] { "classpath:configuration/worker/*.xml", "classpath*:**/plugin-*.xml" });

        }

        this.context.refresh();



        // StorageProcessor processor = context.getBean(StorageProcessor.class);



        Map<String, IService> services = this.context.getBeansOfType(IService.class);

        this.workerServices = new ArrayList<IService>();

        if (services != null && services.size() > 0) {

            for (IService service : services.values()) {

                this.workerServices.add(service);

            }

        }



        this.itemStore = (AsyncQueryableStore) this.context.getBean("asyncQueryableStore");



        // Add a shutdown hook for the above context. It works with

        // "PublisherTaskBase" abstract bean and destroy-method = "stop".

        this.context.registerShutdownHook();

    }



    public GenericXmlApplicationContext getContext() {

        return this.context;

    }



    public List<IService> getWorkerServices() {

        return workerServices;

    }



    public AsyncQueryableStore getItemStore() {

        return itemStore;

    }



}package sgcib.tmon.worker.service;



import java.util.List;

import java.util.concurrent.ExecutionException;

import java.util.concurrent.TimeUnit;



import javax.ws.rs.Consumes;

import javax.ws.rs.GET;

import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.PathParam;

import javax.ws.rs.Produces;

import javax.ws.rs.QueryParam;

import javax.ws.rs.core.MediaType;



import org.elasticsearch.common.joda.time.DateTime;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertStatus;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.ITaskManager;



import com.codahale.metrics.annotation.Timed;

import com.google.common.cache.CacheBuilder;

import com.google.common.cache.CacheLoader;

import com.google.common.cache.LoadingCache;



/**

* Created by ekolonis120213 on 11/03/14.

*/



@Path("/alert")

@Produces(MediaType.APPLICATION_JSON)

@Consumes(MediaType.APPLICATION_JSON)

public class AlertService extends ServiceBase implements IAlertService {



    private final int timeoutInSeconds;

    private final IAlertManager alertManager;

    private final ITaskManager taskManager;

    private final String taskNameEntryPoint;

    private long ttl;

    private long size;



    public AlertService(IAlertManager alertManager, ITaskManager taskManager) {

        super("AlertService");

        this.alertManager = alertManager;

        this.taskManager = taskManager;

        this.timeoutInSeconds = getConfiguration().getTimeoutInSeconds();

        this.taskNameEntryPoint = getConfiguration().getTaskNameEntryPoint();

        this.ttl = getConfiguration().getSpringCacheConfiguration().getAlertService().getTTL();

        this.size = getConfiguration().getSpringCacheConfiguration().getAlertService().getSize();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    /**

     * TODO : Create a cache for alerts. Spring CacheManager does not work with

     * Dropwizard.

     */

    private LoadingCache<String, Alert> alertCache = CacheBuilder.newBuilder().maximumSize(size) //

            .expireAfterAccess(ttl, TimeUnit.MINUTES) //

            .build(new CacheLoader<String, Alert>() {

                @Override

                public Alert load(String id) {

                    IQuery query = new Query();

                    query.addCriterion(Alert.key, id, QueryCriterionType.Is);

                    List<Alert> alerts = alertManager.getAlerts(query);

                    if (alerts != null && alerts.size() == 1) {

                        return alerts.get(0);

                    }

                    return null;

                }

            });



    @Override

    @GET

    @Timed

    @Path("/read/{id}")

    public Alert read(@PathParam("id") String id) {

        try {

            return alertCache.get(id);

        } catch (ExecutionException e) {

            getLogger().error(e.getMessage(), e);

            return null;

        }

    }



    @Override

    @POST

    @Timed

    @Path("/fetch")

    public List<Alert> fetch(IQuery query) {

        return alertManager.getAlerts(query);

    }



    @Override

    @GET

    @Timed

    @Path("/fetch")

    public List<Alert> fetch(@QueryParam("publisher") String publisher, @QueryParam("hours") int hours, @QueryParam("status") String status, @QueryParam("wait") Integer wait) {

        return getAlerts(publisher, hours, status, wait);

    }



    @Override

    @POST

    @Timed

    @Path("/update")

    public void update(@QueryParam("alertId") String alertId, @QueryParam("alertStatus") String alertStatus, @QueryParam("user") String user, @QueryParam("reason") String reason) {



        Event item = new Event(read(alertId));

        item.setValue(Alert.status, AlertStatus.valueOf(alertStatus));

        item.put("closingMode", "Manual");

        item.put("user", user);

        item.put("reason", reason);



        if (taskManager != null) {

            item.put(Queryable.ruleStartDate, org.joda.time.DateTime.now());

            this.taskManager.process(item, taskNameEntryPoint, timeoutInSeconds);

        }

    }



    @Override

    @GET

    @Timed

    @Path("/fetch/{publisher}")

    public List<Alert> getAlerts(@PathParam("publisher") String publisher, @QueryParam("hours") int hours, @QueryParam("status") String status, @QueryParam("wait") Integer wait) {



        int waitForCommit;

        if (wait == null) {

            waitForCommit = getConfiguration().getWaitForCommit();

        } else {

            waitForCommit = wait;

        }



        if (waitForCommit > 0) {

            try {

                Thread.sleep(waitForCommit);

            } catch (InterruptedException e) {

                getLogger().error("Error on wait for commit in getAlerts", e);

            }

        }



        IQuery query = new Query();



        DateTime date = DateTime.now().minusHours(hours);

        if (publisher != null) {

            query.addCriterion(Alert.publisher, publisher, QueryCriterionType.Is);

        }

        if (hours > 0) {

            query.addCriterion(Alert.timestamp, date, QueryCriterionType.GreaterThan);

        }

        if (status != null) {

            query.addCriterion(Alert.status, status, QueryCriterionType.Is);

        }

        List<Alert> alerts = alertManager.getAlerts(query);

        alerts.stream().forEach(a -> a.setValue("link", ManageableBase.getConfiguration().getAlertDataUrl(a.getId(), a.getTimestamp())));

        return alerts;

    }



    @Override

    @POST

    @Timed

    @Path("/raise")

    public void raise(Alert alert) {

        alertManager.raiseAlert(alert);

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }

}

package sgcib.tmon.worker.service;





import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.User;

import sgcib.tmon.worker.common.store.users.UserStore;

import sgcib.tmon.worker.common.utils.TokenUtils;



import javax.servlet.http.HttpServletRequest;

import javax.ws.rs.GET;

import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.Produces;

import javax.ws.rs.core.Context;

import javax.ws.rs.core.MediaType;

import javax.ws.rs.core.Response;

import java.util.List;

import java.util.Map;



/**

* Created with IntelliJ IDEA.

* User: adouangp012014

* Date: 21/05/14

* Time: 17:33

* To change this template use File | Settings | File Templates.

*/

@Path("/authentication")

@Produces(MediaType.APPLICATION_JSON)

public class AuthenticationService extends ServiceBase {



    private final UserStore userStore;

    private final DataService dataService;



    public AuthenticationService(String name, UserStore userStore, DataService dataService) {

        super(name);

        this.userStore = userStore;

        this.dataService = dataService;

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    //login, logout, current



    @POST

    @Path("/login")

    public User login(Map data/*, @Context HttpHeaders headers*/) {



        String email = (String) data.get("email");

        String password = (String) data.get("password");



        if (userStore.ckeckLogin(email, password)) {



            String token = TokenUtils.create(dataService, email);



            User user = userStore.read(email);

            user.put("username", email);

            user.setToken(token);



            return user;

        } else {

            return null; //checkLogin failed

        }





    }



    @GET

    @Path("/logout")

    public boolean logout(@Context HttpServletRequest request) {



        String token = request.getHeader("Authentication");



        return TokenUtils.delete(dataService, token);

    }



    @GET

    @Path("/current")

    public Response current(@Context HttpServletRequest request) {



        String token = request.getHeader("Authentication");



        String email = TokenUtils.check(this.dataService, token);



        if (email != null) {

            User user = this.userStore.read(email);

            user.put("username", email);

            return Response.status(200).entity(user).build();

        } else {

            return Response.status(500).entity(null).build();



        }

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }





}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.processor.metric.Capacity;

import sgcib.tmon.worker.common.processor.metric.CapacityProcessor;

import sgcib.tmon.worker.common.store.event.IEventStore;



import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.Produces;

import javax.ws.rs.core.MediaType;

import java.util.List;



/**

* Date: 28/10/13

* Time: 14:40

* This file is part of biopsy.

* biopsy is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* biopsy is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with biopsy.  If not, see <http://www.gnu.org/licenses/>.

*/

@Path("/capacity")

@Produces(MediaType.APPLICATION_JSON)

public class CapacityService extends ServiceBase {



    private final String name;

    private final CapacityProcessor processor;

    private final IEventStore store;



    public CapacityService(String name, IEventStore store) {

        super(name);

        this.name = name;

        this.store = store;

        processor = new CapacityProcessor(name,store);

    }



     @POST

     @Timed

     @Path("/compute")

     public Capacity compute(Capacity capacity) {

        processor.process(capacity);

        return capacity;

    }



    @POST

    @Timed

    @Path("/estimate")

    public Capacity estimate(Capacity capacity) {

        processor.process(capacity);

        return capacity;

    }



    @Override

    public String getName() {

        return name;

    }



    @Override

    public void start() throws WorkerException {

        processor.start();

    }



    @Override

    public void stop() throws WorkerException {

        processor.stop();

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }

}

package sgcib.tmon.worker.service;



import java.util.ArrayList;

import java.util.List;



import javax.ws.rs.DELETE;

import javax.ws.rs.GET;

import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.PathParam;

import javax.ws.rs.Produces;

import javax.ws.rs.WebApplicationException;

import javax.ws.rs.core.MediaType;

import javax.ws.rs.core.Response;



import sgcib.tmon.worker.cluster.MessageProducer;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.store.configuration.ApplicationSettings;

import sgcib.tmon.worker.common.store.configuration.ITaskConfigurationStore;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.utils.CheckResult;

import sgcib.tmon.worker.configuration.ChainRuleConfiguration;

import sgcib.tmon.worker.configuration.ConverterConfiguration;

import sgcib.tmon.worker.configuration.DropConfiguration;

import sgcib.tmon.worker.configuration.FeatureTrackingConfiguration;

import sgcib.tmon.worker.configuration.FilterConfiguration;

import sgcib.tmon.worker.configuration.MapperConfiguration;

import sgcib.tmon.worker.configuration.PublisherConfiguration;

import sgcib.tmon.worker.configuration.QueueConfiguration;

import sgcib.tmon.worker.configuration.ReportConfiguration;

import sgcib.tmon.worker.configuration.RuleConfiguration;

import sgcib.tmon.worker.configuration.SequenceConfiguration;

import sgcib.tmon.worker.configuration.SettingsConfiguration;

import sgcib.tmon.worker.configuration.StoreConfiguration;

import sgcib.tmon.worker.configuration.TaskConfiguration;

import sgcib.tmon.worker.configuration.TransformConfiguration;

import sgcib.tmon.worker.configuration.UserAgentParserConfiguration;



import com.codahale.metrics.annotation.Timed;

import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 31/01/2015.

*/

@Path("/configuration")

@Produces(MediaType.APPLICATION_JSON)

public class ConfigurationService extends ServiceBase {

    private final ITaskConfigurationStore configurationStore;

    private final MessageProducer monitorProducer;



    public ConfigurationService(ITaskConfigurationStore configurationStore, MessageProducer messageProducer) {

        super("ConfigurationService");

        this.monitorProducer = messageProducer;

        this.configurationStore = configurationStore;

    }



    @GET

    @Timed

    @Path("type/{configurationType}")

    public List<TaskConfiguration> readAllEventTransformerConfiguration(@PathParam("configurationType") String type) {

        if (this.configurationStore != null) {

            try {

                return this.configurationStore.readAll(TaskType.valueOf(type));

            } catch (WorkerException error) {

                getLogger().error(error.getMessage(), error);

            }

        }

        return null;

    }



    @GET

    @Timed

    @Path("/publishers")

    public List<TaskConfiguration> getPublishers() {

        if (this.configurationStore != null) {

            try {

                return this.configurationStore.readAll(TaskType.Publisher);

            } catch (WorkerException error) {

                getLogger().error(error.getMessage(), error);

            }

        }

        return null;

    }



    @GET

    @Timed

    @Path("{configurationName}")

    public TaskConfiguration readConfigurationEventTransformerConfiguration(@PathParam("configurationName") String name) {

        if (this.configurationStore != null) {

            try {

                return this.configurationStore.readConfiguration(name);

            } catch (WorkerException error) {

                getLogger().error(error.getMessage(), error);

            }

        }

        return null;

    }



    @POST

    @Timed

    @Path("{configurationName}")

    public void saveConfiguration(@PathParam("configurationName") String configurationName, TaskConfiguration configuration) throws WorkerException {



        CheckResult check = check(configuration);



        if (this.configurationStore != null && check.isValid()) {

            this.configurationStore.saveConfiguration(configuration);

            if (this.monitorProducer != null) {

                monitorProducer.send(ServiceTopics.TaskConfigurationCreated, configuration);

            }

        } else {

            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(check.getError().getMessage()).type(MediaType.TEXT_PLAIN).build());

        }

    }



    @GET

    @Timed

    @Path("settings/reportUrls")

    public List<ReportConfiguration> reportUrls() throws WorkerException {



        String reportUrl = ManageableBase.getConfiguration().getReportUrl();

        List<ReportConfiguration> reportUrls = new ArrayList<ReportConfiguration>();

        if (reportUrl == null) {

            return reportUrls;

        }



        for (String member : ManageableBase.getConfiguration().getMembers()) {

            ReportConfiguration configuration = new ReportConfiguration();

            configuration.setMember(member);

            configuration.setUrl(String.format("%s?stream=http://%s:%s/hystrix.stream", ManageableBase.getConfiguration().getReportUrl(), member, ManageableBase.getConfiguration().getReportPort()));

            reportUrls.add(configuration);

        }



        return reportUrls;

    }



    @POST

    @Timed

    @Path("settings/{configurationName}")

    public void saveSettingsConfiguration(@PathParam("configurationName") String configurationName, TaskConfiguration configuration) throws WorkerException {



        if (this.configurationStore != null) {

            this.configurationStore.saveConfiguration(configuration);

            if (ApplicationSettings.configuration() == null || ApplicationSettings.get(SettingsConfiguration.environment).equals(configuration.get(SettingsConfiguration.environment))) {

                ApplicationSettings.setConfiguration(new SettingsConfiguration(configuration));

            }

        } else {

            throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).type(MediaType.TEXT_PLAIN).build());

        }

    }



    private CheckResult check(TaskConfiguration configuration) {

        ObjectMapper m = new ObjectMapper();



        String s = null;

        try {

            s = m.writeValueAsString(configuration);

            getLogger().info(s);

        } catch (JsonProcessingException e) {

            getLogger().error("cannot serialize", e);

        }



        switch (configuration.getTaskType()) {



        case Transform:

            return new TransformConfiguration(configuration).check();

        case Store:

            return new StoreConfiguration(configuration).check();

        case Sequence:

            return new SequenceConfiguration(configuration).check();

        case UserAgent:

            return new UserAgentParserConfiguration(configuration).check();

        case Map:

            return new MapperConfiguration(configuration).check();

        case Filter:

            return new FilterConfiguration(configuration).check();

        case Convert:

            return new ConverterConfiguration(configuration).check();

        case Rule:

            return new RuleConfiguration(configuration).check();

        case Publisher:

            return new PublisherConfiguration(configuration).check();

        case ChainRule:

            return new ChainRuleConfiguration(configuration).check();

        case FeatureTracking:

            return new FeatureTrackingConfiguration(configuration).check();

        case Drop:

            return new DropConfiguration(configuration).check();

        case Queue:

            return new QueueConfiguration(configuration).check();

        default:

            break;

        }

        return configuration.check();

    }



    @POST

    @Timed

    @Path("update")

    public void updateConfiguration(TaskConfiguration configuration) throws WorkerException {

        if (this.configurationStore != null) {

            this.configurationStore.updateConfiguration(configuration);

            if (this.monitorProducer != null) {

                monitorProducer.send(ServiceTopics.TaskConfigurationUpdated, configuration);

            }

        }

    }



    @DELETE

    @Timed

    @Path("{configurationName}")

    public void deleteConfiguration(@PathParam("configurationName") String name) throws WorkerException {

        if (this.configurationStore != null) {

            this.configurationStore.deleteConfiguration(name);

            if (this.monitorProducer != null) {

                monitorProducer.send(ServiceTopics.TaskConfigurationDeleted, name);

            }

        }

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    protected List<String> getServicesToWatch() {

        ImmutableList.Builder<String> builder = new ImmutableList.Builder<String>();

        builder.add("readAll");

        builder.add("read");

        builder.add("save");

        builder.add("update");

        builder.add("delete");

        return builder.build();

    }



}

package sgcib.tmon.worker.service;



import java.util.Map;



/**

* Date: 02/11/13

* Time: 15:26

* This file is part of assets.tmon-worker.

* assets.tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* assets.tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with assets.tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public class DataContext {

    private String[] indices;

    private String type;

    private String id;

    private String field;

    private Map<String,Object> item;



    public String[] getIndices() {

        return indices;

    }



    public void setIndices(String[] indices) {

        this.indices = indices;

    }



    public String getType() {

        return type;

    }



    public void setType(String type) {

        this.type = type;

    }



    public String getId() {

        return id;

    }



    public void setId(String id) {

        this.id = id;

    }



    public Map<String, Object> getItem() {

        return item;

    }



    public void setItem(Map<String, Object> item) {

        this.item = item;

    }



    public String getField() {

        return field;

    }



    public void setField(String field) {

        this.field = field;

    }

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import com.fasterxml.jackson.databind.ObjectMapper;

import org.elasticsearch.action.delete.DeleteResponse;

import org.elasticsearch.action.get.GetResponse;

import org.elasticsearch.action.index.IndexResponse;

import org.elasticsearch.action.search.SearchResponse;

import org.elasticsearch.action.search.SearchType;

import org.elasticsearch.client.Client;

import org.elasticsearch.cluster.ClusterState;

import org.elasticsearch.cluster.metadata.IndexMetaData;

import org.elasticsearch.cluster.metadata.MappingMetaData;

import org.elasticsearch.common.collect.ImmutableOpenMap;

import org.elasticsearch.common.collect.UnmodifiableIterator;

import org.elasticsearch.index.query.QueryBuilder;

import org.elasticsearch.index.query.QueryBuilders;

import org.elasticsearch.search.facet.FacetBuilders;

import org.elasticsearch.search.facet.terms.TermsFacet;

import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.StoreManager;

import sgcib.tmon.worker.common.store.alert.IAlertStore;

import sgcib.tmon.worker.common.store.chain.IChainStore;

import sgcib.tmon.worker.service.chain.ChainGraph;



import javax.ws.rs.*;

import javax.ws.rs.core.MediaType;

import java.io.IOException;

import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.UUID;



/**

* Date: 01/11/13

* Time: 18:11

* This file is part of assets.tmon-worker.

* assets.tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* assets.tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with assets.tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

@Path("/data")

@Produces(MediaType.APPLICATION_JSON)

public class DataService extends ServiceBase {

    private final ObjectMapper mapper;

    private final Client client;

    private final String dataIndex;

    private final IChainStore chainStore;

    private final IAlertStore alertStore;



    public DataService(String name, StorageManager storageManager, StoreManager storeManager, String dataIndex) {

        super(name);

        this.dataIndex = dataIndex;

        this.client = storageManager.getClient();

        this.mapper = new ObjectMapper();

        this.chainStore = storeManager.getChainStore();

        this.alertStore = storeManager.getAlertStore();

    }



    @Override

    public void start() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @Override

    public void stop() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @POST

    @Timed

    @Path("/read")

    public Map<String, Object> read(DataContext context) {

        try {

            GetResponse response = client.prepareGet(context.getIndices()[0], context.getType(), context.getId())

                    .execute()

                    .actionGet();

            return response.getSourceAsMap();

        } catch (Exception error) {

            getLogger().error("Item get failed", error);

        }

        return null; // TODO : No better option right now. Find better success criteria

    }



    @POST

    @Timed

    @Path("/create")

    public boolean create(DataContext context) {

        try {

            IndexResponse response = null;



            boolean result = true;

            for (String indice : context.getIndices()) {

                if (indice != null) {

                    if (context.getId() != null) {

                        response = client.prepareIndex(indice, context.getType(), context.getId())

                                .setSource(context.getItem())

                                .execute()

                                .actionGet();

                    } else {

                        response = client.prepareIndex(indice, context.getType())

                                .setSource(context.getItem())

                                .execute()

                                .actionGet();

                    }

                    result &= response.getVersion() == 1; // TODO : No better option right now. Find better success criteria

                }

            }

            return result;

        } catch (Exception error) {

            getLogger().error("Item creation failed", error);

        }

        return false;

    }



    @POST

    @Timed

    @Path("/update")

    public boolean update(DataContext context) {

        try {

            boolean result = true;

            for (String indice : context.getIndices()) {

                if (indice != null) {

                    IndexResponse response = client.prepareIndex(indice, context.getType(), context.getId())

                            .setSource(context.getItem())

                            .execute()

                            .actionGet();

                    result &= response.getVersion() == 1; // TODO : No better option right now. Find better success criteria

                }

            }

            return result;

        } catch (Exception error) {

            getLogger().error("Item update failed", error);

        }

        return false;

    }



    @GET

    @Timed

    @Path("/chain/{id}")

    public ChainGraph readChain(@PathParam("id") String id) {

        if (alertStore == null) return null;

        try {

            Chain chain = chainStore.readChain(id);

            if (chain != null) {

                ChainGraph graph =  new ChainGraph(chain,readChainSteps(id));

                return graph;

            }

        } catch (Exception error) {

            getLogger().error("Cannot read chain", error);

        }

        return null;

    }



    @GET

    @Timed

    @Path("/chainStep/{id}")

    public ChainStep readChainStep(@PathParam("id") String id) {

        if (alertStore == null) return null;

        try {

            return chainStore.readStep(id);

        } catch (Exception error) {

            getLogger().error("Cannot read chain steps", error);

        }

        return null;

    }



    @GET

    @Timed

    @Path("/chainSteps/{id}")

    public List<ChainStep> readChainSteps(@PathParam("id") String id) {

        if (chainStore == null) return null;

        try {

            IQuery query = new Query();

            query.addCriterion(ChainStep.chain, id, QueryCriterionType.Is);

            return chainStore.fetchStep(query);

        } catch (Exception error) {

            getLogger().error("Cannot read chain steps", error);

        }

        return null;

    }



    @GET

    @Timed

    @Path("/alert/{id}")

    public Alert readAlert(@PathParam("id") String id) {

        if (alertStore == null) return null;

        try {

            return alertStore.read(id);

        } catch (Exception error) {

            getLogger().error("Cannot read chain steps", error);

        }

        return null;

    }



    @POST

    @Timed

    @Path("/delete")

    public boolean delete(DataContext context) {

        try {

            boolean result = true;

            for (String indice : context.getIndices()) {

                if (indice != null) {

                    DeleteResponse response = client.prepareDelete(indice, context.getType(), context.getId())

                            .execute()

                            .actionGet();

                }

            }

            return true; // TODO : No better option right now. Find better success criteria

        } catch (Exception error) {

            getLogger().error("Item deletion failed", error);

        }

        return false;

    }



    @POST

    @Timed

    @Path("/terms")

    public List<String> searchTerms(DataContext context) {

        QueryBuilder query = QueryBuilders.matchAllQuery();

        try {

            final SearchResponse response = client.prepareSearch()

                    .setIndices(context.getIndices())

                    .setTypes(context.getType())

                    .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)

                    .setQuery(query)

                    .setSize(0)

                    .addFacet(FacetBuilders.termsFacet("terms").field(context.getField()))

                    .execute()

                    .actionGet();

            int hitCount = (int) response.getHits().totalHits();

            List<String> terms = new ArrayList<String>();

            if (hitCount > 0) {

                TermsFacet result = (TermsFacet) response.getFacets().facetsAsMap().get("terms");

                for (TermsFacet.Entry termEntry : result.getEntries()) {

                    terms.add(termEntry.getTerm().string());

                }

            }

            return terms;

        } catch (Exception error) {

            getLogger().error("Search terms failed", error);

        }

        return null;

    }



    @GET

    @Timed

    @Path("/numericMappings")

    public List<NumericMapping> numericMappings() {

        List<NumericMapping> numericMappings = new ArrayList<NumericMapping>();

        try {

            //ClusterState clusterState = client.admin().cluster().prepareState().setFilterIndices("_all").execute().actionGet().getState();

            ClusterState clusterState = client.admin().cluster().prepareState().setIndices("_all").execute().actionGet().getState();

            if (clusterState != null) {



                ImmutableOpenMap<String, IndexMetaData> metadata = clusterState.getMetaData().indices();

                UnmodifiableIterator<String> indexKeys = metadata.keysIt();

                while (indexKeys.hasNext()) {

                    String indexKey = indexKeys.next();

                    if (indexKey.contains(this.dataIndex)) {

                        ImmutableOpenMap<String, MappingMetaData> mappings = metadata.get(indexKey).getMappings();

                        UnmodifiableIterator<String> mappingKeys = mappings.keysIt();

                        while (mappingKeys.hasNext()) {

                            String mappingKey = mappingKeys.next();

                            Map<String, Object> properties = getProperties(mappings.get(mappingKey));

                            for (Map.Entry property : properties.entrySet()) {

                                if (((Map) property.getValue()).containsKey("type")) {

                                    String type = ((Map) property.getValue()).get("type").toString();

                                    if (type.equals("long") || type.equals("double") || type.equals("float") || type.equals("int")) {

                                        NumericMapping numericMapping = getMapping(numericMappings, mappingKey);

                                        numericMapping.addField(property.getKey().toString());

                                        numericMapping.addIndex(indexKey);

                                    }

                                }

                            }

                        }

                    }

                }

            }

        } catch (Exception error) {

            getLogger().error("Numeric mapping request failed !", error);

            throw new WorkerException("Numeric mappings request failed !", error);

        }

        return numericMappings;

    }





    private Map getProperties(MappingMetaData mappingMetaData) throws IOException {

        return (Map) mappingMetaData.getSourceAsMap().get("properties");

    }



    private NumericMapping getMapping(List<NumericMapping> numericMappings, String eventType) {

        for (NumericMapping numericMapping : numericMappings) {

            if (numericMapping.getType().equals(eventType)) return numericMapping;

        }

        NumericMapping numericMapping = new NumericMapping();

        numericMapping.setType(eventType);

        numericMappings.add(numericMapping);

        return numericMapping;

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }



}

package sgcib.tmon.worker.service;



import java.util.List;



import javax.jms.JMSException;

import javax.jms.MapMessage;

import javax.jms.Message;

import javax.jms.TextMessage;



import org.elasticsearch.common.joda.time.DateTime;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.arc.eai.jms.JMSWrapper;

import sgcib.arc.eai.jms.RequestResponseService;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertStatus;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;



import com.fasterxml.jackson.databind.ObjectMapper;



public class EmsRequestResponseService implements RequestResponseService {



    private final Logger logger;

    private final IAlertManager alertManager;

    private final String publisherName;



    public EmsRequestResponseService(IAlertManager alertManager, String publisherName) {

        this.alertManager = alertManager;

        this.publisherName = publisherName;

        this.logger = LoggerFactory.getLogger(publisherName);

    }



    @Override

    public Message call(JMSWrapper jmsWrapper, Message message) throws JMSException {

        logger.info("Request received in EmsRequestResponseService ");

        ObjectMapper mapper = new ObjectMapper();

        MapMessage alertList = jmsWrapper.createMapMessage();

        Query cond = null;

        try {

            if (message != null && message instanceof TextMessage && ((TextMessage) message).getText() != null) {

                cond = mapper.readValue(((TextMessage) message).getText(), Query.class);

            } else {

                cond = new Query();

                cond.addCriterion(Alert.publisher, publisherName, QueryCriterionType.Is);

                cond.addCriterion(Alert.status, AlertStatus.Open.toString(), QueryCriterionType.Is);

                cond.addCriterion(Alert.timestamp, DateTime.now().minusHours(24), QueryCriterionType.GreaterThan);

            }

            List<Alert> alerts = alertManager.getAlerts(cond);

            if (alerts != null) {

                for (Alert alert : alerts) {

                    alertList.setObject(alert.getId(), alert.toJSON());

                }

            }



        } catch (Exception e) {

            getLogger().error("Error while sending response from Ems", e);

        }

        return alertList;

    }



    protected Logger getLogger() {

        return logger;

    }

}

package sgcib.tmon.worker.service;



import sgcib.tmon.worker.common.exception.WorkerException;



import javax.ws.rs.GET;

import javax.ws.rs.Path;

import java.util.List;



@Path("/external")

public class ExternalURLService extends ServiceBase {



    public ExternalURLService() {

        super("ExternalURLService");

    }



    @Override

    public void start() throws WorkerException {

    }



    @Override

    public void stop() throws WorkerException {

    }



    @GET

    @Path("/kibana")

    public String kibanaUrl() {

        return getConfiguration().getKibanaUrl();

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }

}

package sgcib.tmon.worker.service;



import java.util.List;



import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IQuery;



/**

* @author ablaszcz120213

*

 *         IAlertService implementation uses cache with @Cacheable (cache spring

*         annotations require an interface).

*

*/

public interface IAlertService {



    /**

     * Return an {@link Alert} instance according to the given identifier

     * {@code id}. If the alert does not exist, {@code null} is returned.

     *

     * @param id

     *            Alert idientifier.

     */

    Alert read(String id);



    List<Alert> fetch(IQuery query);



    List<Alert> fetch(String publisher, int hours, String status, Integer wait);



    void update(String alertId, String alertStatus, String user, String reason);



    List<Alert> getAlerts(String publisher, int hours, String status, Integer wait);



    void raise(Alert alert);

}package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import org.joda.time.DateTime;

import org.joda.time.DateTimeZone;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.job.*;

import sgcib.tmon.worker.common.store.job.IJobStore;



import javax.ws.rs.*;

import javax.ws.rs.core.MediaType;

import javax.ws.rs.core.Response;

import java.util.List;



/**

* Created with IntelliJ IDEA.

* User: adouangp012014

* Date: 25/08/14

* Time: 11:19

* To change this template use File | Settings | File Templates.

*/

@Path("/job")

@Produces(MediaType.APPLICATION_JSON)

public class JobService extends ServiceBase {



    private final IJobStore jobStore;



    public JobService(IJobStore jobStore) {

        super("JobService");

        this.jobStore = jobStore;

    }





    @Override

    public void start() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @Override

    public void stop() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @GET

    @Timed

    @Path("{jobName}")

    public Job read(@PathParam("jobName") String jobName) {

        return this.jobStore.read(jobName);

    }



    @POST

    @Timed

    @Path("{jobName}")

    //public void save(@PathParam("jobName") String jobName, HashMap<String, Object> job, @Context HttpServletResponse response) throws WorkerException {

    public void save(@PathParam("jobName") String jobName, Job job) throws WorkerException {

        WorkerJob workerJob = null;

        switch (job.getJobType()) {



            case Database:

                workerJob = new DatabaseWorkerJob(job, null);

               break;

            case Clean:

                workerJob = new CleanWorkerJob(job, null);

                break;

            case Ssh:

                break;

        }



        if (workerJob != null) {

            String checkResult = workerJob.check(); //let exception propagate if check is invalid

            if (checkResult != null && !checkResult.equals("OK")) {

                throw new JobServiceException(checkResult);

            }

            job.setModificationDate(DateTime.now().toDateTime(DateTimeZone.UTC));

            this.jobStore.update(job);

        }

    }



    @DELETE

    @Timed

    @Path("{jobName}/{jobType}")

    public void delete(@PathParam("jobName") String jobName, @PathParam("jobType") JobType jobType) throws WorkerException {

        this.jobStore.delete(jobName,jobType);

    }



    @GET

    @Timed

    @Path("/type/{jobType}")

    public List<Job> readAll(@PathParam("jobType") JobType jobType) {

        List<Job> jobList = this.jobStore.getJobsByType(jobType);

        return jobList;



    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }



    public class JobServiceException extends WebApplicationException {



        public JobServiceException(String message) {

            super(Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(message).type(MediaType.TEXT_PLAIN).build());

        }



    }

}

package sgcib.tmon.worker.service;





public enum Mode {

      Worker,

      Agent,

      Aggregator

}

package sgcib.tmon.worker.service;



import java.util.ArrayList;

import java.util.List;



/**

* Date: 07/12/13

* Time: 23:24

* This file is part of tmon-worker.

* tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public class NumericMapping {

    private List<String> indices;

    private String type;

    private List<String> fields;



    public NumericMapping() {

        this.fields = new ArrayList<String>();

        this.indices = new ArrayList<String>();

    }



    public String getType() {

        return type;

    }



    public void setType(String type) {

        this.type = type;

   }



    public void addIndex(String index) {

        if (!indices.contains(index)) {

            this.indices.add(index);

        }

    }



    public void addField(String field) {

        if (!fields.contains(field)) {

            this.fields.add(field);

        }

    }



    public List<String> getIndices() {

        return indices;

    }



    public List<String> getFields() {

        return fields;

    }

}

package sgcib.tmon.worker.service;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;



/**

* Date: 01/11/13

* Time: 18:22

* This file is part of assets.tmon-worker.

* assets.tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* assets.tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with assets.tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public class PagingContext {



    private String[] indices;

    private String type;

    private int pagingSize;

    private int currentPage;

    private int pagingCount;

    private String sortField;

    private List<PagingCriterion> pagingCriteria;

    private List<Map<String,Object>> items;



    public PagingContext() {

    }



    public PagingContext(int pageSize) {

        this.pagingSize = pageSize;

        pagingCriteria = new ArrayList<PagingCriterion>();

        items = new ArrayList<Map<String,Object>>();

    }



    public String[] getIndices() {

        return indices;

    }



    public void setIndices(String[] indices) {

        this.indices = indices;

    }



    public String getType() {

        return type;

    }



    public void setType(String type) {

        this.type = type;

    }



    public String getSortField() {

        return sortField;

    }



    public void setSortField(String sortField) {

        this.sortField = sortField;

    }



    public int getPagingSize() {

        return pagingSize;

    }



    public void setPagingSize(int pagingSize) {

        this.pagingSize = pagingSize;

    }



    public int getCurrentPage() {

        return currentPage;

    }



    public void setCurrentPage(int currentPage) {

       this.currentPage = currentPage;

    }



    public int getPagingCount() {

        return pagingCount;

    }



    public void setPagingCount(int pagingCount) {

        this.pagingCount = pagingCount;

    }



    public List<PagingCriterion> getPagingCriteria() {

        return pagingCriteria;

    }



    public void setPageCriteria(List<PagingCriterion> pagingCriteria) {

        this.pagingCriteria = pagingCriteria;

    }



    public List<Map<String,Object>> getItems() {

        return items;

    }



    public void setItems(List<Map<String,Object>> items) {

        this.items = items;

    }

}

package sgcib.tmon.worker.service;



/**

* Date: 01/11/13

* Time: 18:28

* This file is part of assets.tmon-worker.

* assets.tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* assets.tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with assets.tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public class PagingCriterion {

    private String field;

    private String value;



    public PagingCriterion() {

    }



    public PagingCriterion(String field, String value) {

        this.field = field;

        this.value = value;

    }



    public String getField() {

        return field;

    }



    public void setField(String field) {

        this.field = field;

    }



    public String getValue() {

        return value;

    }



    public void setValue(String value) {

        this.value = value;

    }

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import com.fasterxml.jackson.databind.ObjectMapper;

import org.elasticsearch.action.search.SearchResponse;

import org.elasticsearch.client.Client;

import org.elasticsearch.index.query.BoolQueryBuilder;

import org.elasticsearch.index.query.QueryBuilder;

import org.elasticsearch.index.query.QueryBuilders;

import org.elasticsearch.search.SearchHit;

import org.elasticsearch.search.sort.SortBuilders;

import org.elasticsearch.search.sort.SortOrder;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.StorageManager;



import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.Produces;

import javax.ws.rs.core.MediaType;

import java.util.ArrayList;

import java.util.List;

import java.util.Map;



/**

* Date: 01/11/13

* Time: 18:21

* This file is part of assets.tmon-worker.

* assets.tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* assets.tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with assets.tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

@Path("/page")

@Produces(MediaType.APPLICATION_JSON)

public class PagingService extends ServiceBase {



    private final ObjectMapper mapper;

    private final Client client;



    public PagingService(String name, StorageManager storageManager) {

        super(name);

        this.client = storageManager.getClient();

        this.mapper = new ObjectMapper();

    }



    @Override

    public void start() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @Override

    public void stop() throws WorkerException {

        //To change body of implemented methods use File | Settings | File Templates.

    }







    @POST

    @Timed

    @Path("/read")

    public PagingContext readPage(PagingContext context) {



        QueryBuilder query = null;



        if (context.getPagingCriteria().size() == 0) {

            query = QueryBuilders.matchAllQuery();

        } else {

            query = QueryBuilders.boolQuery();

            for (PagingCriterion criterion : context.getPagingCriteria()) {

                //query = ((BoolQueryBuilder) query).must(QueryBuilders.fieldQuery(criterion.getField(), criterion.getValue()));

                //query = ((BoolQueryBuilder) query).must(QueryBuilders.inQuery(criterion.getField(), criterion.getValue()));

                //query = ((BoolQueryBuilder) query).must(QueryBuilders.fuzzyQuery(criterion.getField(), criterion.getValue()));

                query = ((BoolQueryBuilder) query).must(QueryBuilders.queryString(criterion.getField() + ":" + criterion.getValue()));

            }

        }



        try {

            final SearchResponse response = client.prepareSearch()

                    .setIndices(context.getIndices())

                    .setTypes(context.getType())

                    .setQuery(query)

                    .addSort(SortBuilders.fieldSort(context.getSortField()).order(SortOrder.DESC))

                    .setSize(context.getPagingSize())

                    .setFrom((context.getCurrentPage() - 1) * context.getPagingSize())

                    .setExplain(true)

                    .execute()

                    .actionGet();



            int hitCount = (int) response.getHits().totalHits();

            if (hitCount > 0) {

                context.setPagingCount(hitCount / context.getPagingSize());

                List<Map<String, Object>> items = new ArrayList<Map<String, Object>>();

                for (SearchHit hit : response.getHits().hits()) {

                    items.add(hit.getSource());

                }

                context.setItems(items);

                context.setPagingCount(hitCount / context.getPagingSize() + 1);

            }

        } catch (Exception error) {

            getLogger().error("Failed to read page", error);

        }

        return context;

    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }



}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import com.google.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;



import javax.ws.rs.GET;

import javax.ws.rs.Path;

import javax.ws.rs.Produces;

import javax.ws.rs.core.MediaType;

import java.util.List;



/**

* Created by adouangp012014 on 21/08/2015.

*/

@Path("/project")

@Produces(MediaType.APPLICATION_JSON)

public class ProjectPropertiesService extends ServiceBase {



    public ProjectPropertiesService() {

        super("ProjectPropertiesService");

    }



    @Override

    protected List<String> getServicesToWatch() {

        ImmutableList.Builder<String> builder = new ImmutableList.Builder<String>();

        builder.add("getVersion");

        return builder.build();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @GET

    @Timed

    @Path("/version")

    public String getVersion() {

        return this.getClass().getPackage().getImplementationVersion();

    }

}

package sgcib.tmon.worker.service;



import sgcib.tmon.worker.common.utils.TokenUtils;



import javax.servlet.*;

import javax.servlet.http.HttpServletRequest;

import javax.servlet.http.HttpServletResponse;

import java.io.IOException;



/**

* Created with IntelliJ IDEA.

* User: adouangp012014

* Date: 23/05/14

* Time: 14:40

* To change this template use File | Settings | File Templates.

*/

public class RequestInterceptor implements Filter {



    final private DataService dataService;



    public RequestInterceptor(DataService dataService) {

        this.dataService = dataService;

    }



    @Override

    public void init(FilterConfig filterConfig) throws ServletException {



    }



    @Override

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {



        HttpServletRequest httpRequest = (HttpServletRequest) request;

        String url = httpRequest.getRequestURL().toString();



        if (url.contains("/service/") && !url.contains("/authentication/") && !url.contains("/event/")) {



            String authenticationHeader = httpRequest.getHeader("Authentication");



            if (authenticationHeader == null || authenticationHeader.isEmpty()) {

                String msg = "Provided access token is either null or empty.";

                ((HttpServletResponse) response).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, msg);

            } else if (TokenUtils.check(this.dataService, authenticationHeader) == null) {

                String msg = "Provided access token does not have permissions to access this resource.";

                ((HttpServletResponse) response).sendError(HttpServletResponse.SC_UNAUTHORIZED, msg);

            }

            chain.doFilter(request, response);

        } else {

            chain.doFilter(request, response);

        }

    }



    @Override

    public void destroy() {



    }

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.health.HealthCheck;

import sgcib.tmon.worker.common.lifecycle.IService;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;



import java.util.List;



/**

* Created by Stephane on 14/03/2015.

*/

public abstract class ServiceBase extends ManageableBase implements IService {



    protected ServiceBase(String name) {

        super(name);

    }



    public HealthCheck getHealthCheck() {

        return new ServiceHealthCheck(null, getServicesToWatch());

    }



    protected abstract List<String> getServicesToWatch();

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.MetricRegistry;

import com.codahale.metrics.health.HealthCheck;



import java.util.List;



/**

* Created by Stephane on 09/03/2015.

*/

public class ServiceHealthCheck extends HealthCheck {



    private final MetricRegistry registry;

    private final List<String> servicesToWatch;



    public ServiceHealthCheck(MetricRegistry registry, List<String> servicesToWatch) {

        this.registry = registry;

        this.servicesToWatch = servicesToWatch;

    }





    @Override

    protected Result check() throws Exception {

        return Result.healthy();

    }

}

package sgcib.tmon.worker.service;



import java.util.List;



import javax.servlet.http.HttpServletResponse;

import javax.ws.rs.DELETE;

import javax.ws.rs.GET;

import javax.ws.rs.POST;

import javax.ws.rs.Path;

import javax.ws.rs.PathParam;

import javax.ws.rs.Produces;

import javax.ws.rs.core.Context;

import javax.ws.rs.core.MediaType;

import javax.ws.rs.core.Response;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.BasicServiceLevelAgreement;

import sgcib.tmon.worker.common.model.ServiceLevelAgreement;

import sgcib.tmon.worker.common.store.sla.IServiceLevelAgreementStore;



import com.codahale.metrics.annotation.Timed;



/**

* Created with IntelliJ IDEA. User: adouangp012014 Date: 07/05/14 Time: 14:21

* To change this template use File | Settings | File Templates.

*/

@Path("/serviceLevelAgreement")

@Produces(MediaType.APPLICATION_JSON)

public class ServiceLevelAgreementService extends ServiceBase {



    private final IServiceLevelAgreementStore serviceLevelAgreementStore;



    public ServiceLevelAgreementService(String name, IServiceLevelAgreementStore serviceLevelAgreementStore) {

        super(name);

        this.serviceLevelAgreementStore = serviceLevelAgreementStore;

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @GET

    @Timed

    @Path("{name}")

    public BasicServiceLevelAgreement read(@PathParam("name") String name) {

        return (BasicServiceLevelAgreement) this.serviceLevelAgreementStore.read(name);

    }



    @POST

    @Timed

    @Path("{name}")

    public BasicServiceLevelAgreement save(@PathParam("name") String name, BasicServiceLevelAgreement serviceLevelAgreement, @Context HttpServletResponse response) {

        try {

            // Handle create or update

            if (this.read(name) == null) {

                this.serviceLevelAgreementStore.create(serviceLevelAgreement);

            } else {

                this.serviceLevelAgreementStore.update(serviceLevelAgreement.getName(), serviceLevelAgreement);

            }

        } catch (WorkerException workerException) {

            getLogger().error(String.format("Error during update : %s", serviceLevelAgreement.getName()), workerException);

            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, workerException.getMessage());

            return null;

        } finally {

            return serviceLevelAgreement;

        }

    }



    @DELETE

    @Timed

    @Path("{name}")

    public Response delete(@PathParam("name") String name) {



        BasicServiceLevelAgreement sla = this.read(name);



        String returnMessage = "OK";



        try {

            this.serviceLevelAgreementStore.delete(sla);

        } catch (WorkerException workerException) {

            getLogger().error(String.format("Error during delete : %s", sla.getName()), workerException);

            returnMessage = workerException.getMessage();

            return Response.status(500).entity(returnMessage).build();

        } finally {

            return Response.status(200).entity(returnMessage).build();

        }



    }



    @GET

    @Timed

    public List<ServiceLevelAgreement> readAll() {



        List<ServiceLevelAgreement> jobList = this.serviceLevelAgreementStore.getAllAgreements();



        return jobList;



    }



    @Override

    protected List<String> getServicesToWatch() {

        return null;

    }



}

package sgcib.tmon.worker.service;



/**

* Created by Stephane on 28/02/2015.

*/

public class ServiceTopics {

    public static String TaskConfigurationCreated="TaskConfigurationCreated";

    public static String TaskConfigurationUpdated="TaskConfigurationUpdated";

    public static String TaskConfigurationDeleted="TaskConfigurationDeleted";

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;

import sgcib.tmon.worker.cluster.MessageBroker;

import sgcib.tmon.worker.cluster.MessageConsumer;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.ITask;

import sgcib.tmon.worker.common.task.ITaskManager;

import sgcib.tmon.worker.common.task.QueueTask;

import sgcib.tmon.worker.common.task.rules.ChainRuleTask;

import sgcib.tmon.worker.common.task.rules.RuleTask;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import javax.ws.rs.*;

import javax.ws.rs.core.MediaType;

import java.util.List;



@Path("/task")

@Produces(MediaType.APPLICATION_JSON)

public class TaskService extends ServiceBase implements MessageConsumer {

    private final int timeoutInSeconds;

    private final ITaskManager taskManager;



    public TaskService(ITaskManager taskManager, MessageBroker messageBroker) {

        super("TaskService");

        this.timeoutInSeconds = getConfiguration().getTimeoutInSeconds();

        this.taskManager = taskManager;

        messageBroker.register(ServiceTopics.TaskConfigurationCreated, this);

        messageBroker.register(ServiceTopics.TaskConfigurationUpdated, this);

        messageBroker.register(ServiceTopics.TaskConfigurationDeleted, this);

    }



    @POST

    @Timed

    @Path("/process/{taskName}")

    public void process(@PathParam("taskName") String taskName, Queryable item) throws WorkerException {

        if (taskManager != null) {

            item.put(Queryable.ruleStartDate, DateTime.now());

            this.taskManager.process(item, taskName, timeoutInSeconds);

        }

    }



    @POST

    @Timed

    @Path("/processMultiple/{taskName}")

    public void processMultiple(@PathParam("taskName") String taskName, List<Queryable> items) throws WorkerException {

        if (taskManager != null) {

            DateTime nowTime = DateTime.now();

            for (Queryable item : items) {

                item.put(Queryable.ruleStartDate, nowTime);

            }

            this.taskManager.processMultiple(items, taskName, timeoutInSeconds);

        }

    }



    @GET

    @Timed

    @Path("/dump/{taskName}")

    public String processMultiple(@PathParam("taskName") String taskName) throws WorkerException {

        if (taskManager != null) {

            ITask task = taskManager.getTask(taskName);

            if (task != null) {

                if (task.getClass().isAssignableFrom(RuleTask.class)) {

                    RuleTask ruleTask = (RuleTask) task;

                    if (ruleTask != null) {

                        return ruleTask.dump();

                    }

                }



                if (task.getClass().isAssignableFrom(ChainRuleTask.class)) {

                    ChainRuleTask ruleTask = (ChainRuleTask) task;

                    if (ruleTask != null) {

                        return ruleTask.dump();

                    }

                }



                if (task.getClass().isAssignableFrom(QueueTask.class)) {

                    QueueTask queueTask = (QueueTask) task;

                    if (queueTask != null) {

                        return queueTask.dump();

                    }

                }

            }

        }

        return "";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public <T> void onMessage(String topicName, T data) {

        if (data != null) {

            if (data instanceof TaskConfiguration) {

                TaskConfiguration configuration = (TaskConfiguration) data;

                if (ServiceTopics.TaskConfigurationCreated.equals(topicName)) {

                    this.taskManager.createTask(configuration);

                } else if (ServiceTopics.TaskConfigurationUpdated.equals(topicName)) {

                    this.taskManager.updateTask(configuration);

                } else if (ServiceTopics.TaskConfigurationUpdated.equals(topicName)) {

                    this.taskManager.deleteTask(configuration);

                }

            }

        }

    }



    @Override

    protected List<String> getServicesToWatch() {

        ImmutableList.Builder<String> builder = new ImmutableList.Builder<String>();

        builder.add("process");

        builder.add("processMultiple");

        return builder.build();

    }



}

package sgcib.tmon.worker.service;



import com.codahale.metrics.annotation.Timed;

import com.google.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.User;

import sgcib.tmon.worker.common.store.users.IUserStore;



import javax.servlet.http.HttpServletResponse;

import javax.ws.rs.*;

import javax.ws.rs.core.Context;

import javax.ws.rs.core.MediaType;

import javax.ws.rs.core.Response;

import java.util.List;



/**

* Created by ekolonis120213 on 03/02/14.

*/



@Path("/user")

@Produces(MediaType.APPLICATION_JSON)

public class UserService extends ServiceBase {



    private final IUserStore userStore;



    public UserService(String name, IUserStore userStore, String dataIndex) {

        super(name);

        this.userStore = userStore;

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @POST

    @Timed

    @Path("{email}")

    public User update(@PathParam("email") String email, User user, @Context HttpServletResponse response) {



        try {

            this.userStore.update(user);

        } catch (WorkerException workerException) {

            getLogger().error(String.format("Error during update : %s", user.getEmail()), workerException);

            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, workerException.getMessage());

            return null;

        } finally {

            return user;

        }



    }



    @GET

    @Timed

    @Path("{email}")

    public User read(@PathParam("email") String email) {



        return userStore.read(email);

    }



    @DELETE

    @Timed

    @Path("{email}")

    public Response delete(@PathParam("email") String email) {

        User user = this.userStore.read(email);



        String returnMessage = "OK";

        try {

            this.userStore.delete(user);

        } catch (WorkerException workerException) {

            getLogger().error(String.format("Error during delete : %s", user.getEmail()), workerException);

           returnMessage = workerException.getMessage();

            return Response.status(500).entity(returnMessage).build();

        } finally {

            return Response.status(200).entity(returnMessage).build();

        }

    }



    @GET

    @Timed

    public List<User> getAllUsers() {

        return userStore.getAllUsers();

    }



    @Override

    protected List<String> getServicesToWatch() {

        ImmutableList.Builder<String> builder = new ImmutableList.Builder<String>();

        builder.add("delete");

        builder.add("read");

        builder.add("update");

        return builder.build();

    }



}

package sgcib.tmon.worker.service;



import java.util.HashMap;



/**

* Date: 01/01/14

* Time: 20:40

* This file is part of tmon-worker.

* tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public class WorkerMessage extends HashMap<String,Object> {

    public static String type = "type";

    public static String data = "data";





    public WorkerMessageType getMessageType() {

        return WorkerMessageType.valueOf((String) get(WorkerMessage.type));

    }



    public void setMessageType(WorkerMessageType messageType) {

        put(WorkerMessage.type, messageType.toString());

    }



    public String getData() {

        return (String) get(WorkerMessage.data);

    }



    public void setData(String data) {

        put(WorkerMessage.data, data);

    }





}

package sgcib.tmon.worker.service;



/**

* Date: 02/01/14

* Time: 08:25

* This file is part of tmon-worker.

* tmon-worker is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* tmon-worker is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with tmon-worker.  If not, see <http://www.gnu.org/licenses/>.

*/

public enum WorkerMessageType {

    COMPRESSION,

    CONCENTRATOR

}

package sgcib.tmon.worker.service;



import com.codahale.metrics.JmxReporter;

import com.codahale.metrics.MetricRegistry;

import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;

import com.netflix.hystrix.strategy.properties.HystrixPropertiesCommandDefault;

import com.netflix.hystrix.strategy.properties.HystrixPropertiesThreadPoolDefault;

import io.dropwizard.Application;

import io.dropwizard.assets.AssetsBundle;

import io.dropwizard.setup.Bootstrap;

import io.dropwizard.setup.Environment;

import org.elasticsearch.metrics.ElasticsearchReporter;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import sgcib.tmon.worker.common.lifecycle.IService;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.configuration.WorkerConfiguration;

import sgcib.tmon.worker.resources.ContextManager;



import java.io.IOException;

import java.util.concurrent.TimeUnit;



public class WorkerService extends Application<WorkerConfiguration> {

    private static final String DEFAULT_INDEX = "index.html";

    private Logger logger;

    private ContextManager contextManager;

    private ElasticsearchReporter esReporter;

    private JmxReporter jmxReporter;



    public WorkerService() {

        logger = LoggerFactory.getLogger("WorkerService");



    }



    public static void main(String[] args) throws Exception {

        new WorkerService().run(args);

    }



    @Override

    public void initialize(Bootstrap<WorkerConfiguration> bootstrap) {

        bootstrap.addBundle(new AssetsBundle("/assets/", "/", DEFAULT_INDEX));

    }



    @Override

    public void run(WorkerConfiguration configuration,

                    Environment environment) {



        ManageableBase.setConfiguration(configuration);

        MetricRegistry registry = environment.metrics();



        HystrixPropertiesCommandDefault.Setter()

                .withCircuitBreakerEnabled(false)

                .withExecutionTimeoutEnabled(true)

                .withRequestCacheEnabled(false)

                .withExecutionTimeoutInMilliseconds(configuration.getTimeoutInSeconds() * 1000);



        HystrixPropertiesThreadPoolDefault.Setter().withCoreSize(10);

        environment.getApplicationContext().addServlet(HystrixMetricsStreamServlet.class, "/hystrix.stream");



        if (registry != null) {

            jmxReporter = JmxReporter.forRegistry(registry).build();

            jmxReporter.start();

        }

        if (registry != null && configuration.getStorageConfiguration() != null) {



            String[] reportingHosts = configuration.getStorageConfiguration().getReportingHosts();



            if (reportingHosts != null) {

                try {



                    esReporter = ElasticsearchReporter.forRegistry(registry)

                            .hosts(reportingHosts)

                            .build();



                } catch (IOException error) {

                    logger.error("... metric reporter start failure.", error);

                }

                esReporter.start(configuration.getStorageConfiguration().getReportingPeriod(), TimeUnit.SECONDS);

                logger.info(String.format("... metric reporter started and reporting every %d seconds.", configuration.getStorageConfiguration().getReportingPeriod()));

            }

        } else {

            logger.warn("...  metric reporter is not started because no metric registry is registered.");

        }



        this.contextManager = new ContextManager(configuration.getMode());

        ManageableBase.setItemStore(this.contextManager.getItemStore());



        if (this.contextManager.getWorkerServices() != null) {

            for (IService service : this.contextManager.getWorkerServices()) {

                environment.jersey().register(service);

                environment.healthChecks().register("eventService", service.getHealthCheck());

                service.start();

            }

        }





    }



    @Override

    protected void finalize() throws Throwable {

        super.finalize();



        if (contextManager.getWorkerServices() != null) {

            for (IService service : contextManager.getWorkerServices()) {

                service.stop();

            }

        }



        if (esReporter != null) {

            esReporter.stop();

        }



        if (jmxReporter != null) {

            jmxReporter.stop();

        }



        logger.info("... plugins unloaded");

    }

}



package sgcib.tmon.worker.stream;





import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.IStoreManager;

import sgcib.tmon.worker.common.task.ITaskManager;



import java.util.List;



/**

* Created by Stephane on 14/02/2015.

*/

public class StreamManager extends ManageableBase {



    private IStoreManager storeManager;

    private IAlertManager alertManager;

    private ITaskManager taskManager;

    private IClusterManager clusterManager;



    public StreamManager(IClusterManager clusterManager, IStoreManager storeManager, IAlertManager alertManager, ITaskManager taskManager) {

        super("StreamManager");

        this.storeManager = storeManager;

        this.alertManager = alertManager;

        this.taskManager = taskManager;

        this.clusterManager = clusterManager;

    }



    @Override

    public void start() throws WorkerException {

    }



    @Override

    public void stop() throws WorkerException {

    }



    public IStoreManager getStoreManager() {

        return this.storeManager;

    }



    public IAlertManager getAlertManager() {

        return alertManager;

    }



    public ITaskManager getTaskManager() {

        return taskManager;

    }



    public IClusterManager getClusterManager() {

        return clusterManager;

    }

}

Gmail	Stephane Lopes-Bogalho <stephane.lopes.bogalho@gmail.com>
Review pour Vendredi
LOPES Stephane <stephane.lopes@sgcib.com>	19 novembre 2015 17:29
 : "stephane.lopes.bogalho@gmail.com" <stephane.lopes.bogalho@gmail.com>
package sgcib.tmon.worker.common.model.job;



/**

* Created by adouangp012014 on 26/03/14.

*/

public class CleanJob extends Job {



    public static String eventType = "eventType";

    public static String eventName = "eventName";

    public static String duration = "duration";

    public static String queryFilter = "queryFilter";

    public static String timeUnit = "timeUnit";



    public CleanJob() {

        super();

        setType(JobType.Clean.toString());



    }



    public CleanJob(String name) {

        super(name, JobType.Clean);

    }



    public String getEventType() {

        return (String) get(CleanJob.eventType);

    }



    public void setEventType(String eventType) {

        put(CleanJob.eventType, eventType);

    }



    public String getEventName() {

        return (String) get(CleanJob.eventName);

    }



    public void setEventName(String eventName) {

        put(CleanJob.eventName, eventName);

    }



    public String getDuration() {

        return (String) get(CleanJob.duration);

    }



    public void setDuration(String duration) {

        put(CleanJob.duration, duration);

    }



    public String getQueryFilter() {

        return (String) get(CleanJob.queryFilter);

    }



    public void setQueryFilter(String queryFilter) {

        put(CleanJob.queryFilter, queryFilter);

    }



    public String getTimeUnit() {

        return (String) get(CleanJob.timeUnit);

    }



    public void setTimeUnit(String timeUnit) {

        put(CleanJob.timeUnit, timeUnit);

    }



}package sgcib.tmon.worker.common.model.job;



import org.joda.time.DateTime;

import org.quartz.JobDataMap;

import org.quartz.JobDetail;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



import java.util.concurrent.TimeUnit;



import static org.quartz.JobBuilder.newJob;



/**

* Created by Stephane on 11/06/2015.

*/

public class CleanWorkerJob extends WorkerJob {



    public CleanWorkerJob(Job job, IQueryableStore store) {

        super(job, store);

    }



    @Override

    protected void doExecute(JobDataMap jobDataMap, IQueryableStore store) throws Exception {

        String eventType = jobDataMap.getString(CleanJob.eventType);

        String eventName = jobDataMap.getString(CleanJob.eventName);

        int duration = jobDataMap.getInt(CleanJob.duration);

        TimeUnit timeUnit = TimeUnit.valueOf(jobDataMap.getString(CleanJob.timeUnit));

        DateTime timeStamp = buidTimestamp(duration, timeUnit);

        String filterQuery = jobDataMap.getString(CleanJob.queryFilter);

        IQuery query = new Query();

        query.addCriterion(Queryable.type, eventType, QueryCriterionType.Is);

        query.addCriterion(Queryable.name, eventName, QueryCriterionType.Is);

        query.addCriterion(Queryable.timestamp, timeStamp, QueryCriterionType.LesserOrEqualThan);

        query.setQueryFilter(filterQuery);

        store.delete(query);

    }



    private DateTime buidTimestamp(int duration, TimeUnit timeUnit) {

        DateTime timestamp = DateTime.now();

        switch (timeUnit) {

            case NANOSECONDS:

            case MICROSECONDS:

            case MILLISECONDS:

            case SECONDS:

            case MINUTES:

                return timestamp.minusMinutes(duration);

            case HOURS:

                return timestamp.minusHours(duration);

            case DAYS:

                return timestamp.minusDays(duration);

        }

        return null;

    }



    @Override

    public JobDetail getDetail() {

        return newJob(CleanWorkerJob.class)

                .withIdentity(this.getName(), getGroup())

                .setJobData(new JobDataMap(getJob())).build();

    }





    @Override

    public String getGroup() {

        return "CleanJobs";

    }

}

package sgcib.tmon.worker.common.model.job;



import javax.validation.constraints.NotNull;



/**

* Created by adouangp012014 on 03/02/14.

*/

public class DatabaseJob extends Job {



    public static String connectionString = "connectionString";

    public static String user = "user";

    public static String password = "password";

    public static String sqlStatement = "sqlStatement";

    public static String typeDestination = "typeDestination";

    public static String id = "id";

    public static String indices = "indices";



    public DatabaseJob() {

        super();

        setType(JobType.Database.toString());

        setTypeDestination("databaseData");

    }



    public DatabaseJob(String name) {

        super(name, JobType.Database);

        setTypeDestination("databaseData");

    }





    @NotNull

    public String getTypeDestination() {

        return (String) get(DatabaseJob.typeDestination);

    }



    public void setTypeDestination(String typeDestination) {

        put(DatabaseJob.typeDestination, typeDestination);

    }



    @NotNull

    public String getConnectionString() {

        return (String) get(DatabaseJob.connectionString);

    }



    public void setConnectionString(String connectionString) {

        put(DatabaseJob.connectionString, connectionString);

    }



    @NotNull

    public String getUser() {

        return (String) get(DatabaseJob.user);

    }



    public void setUser(String user) {

        put(DatabaseJob.user, user);

    }



    @NotNull

    public String getPassword() {

        return (String) get(DatabaseJob.password);

    }



    public void setPassword(String password) {

        put(DatabaseJob.password, password);

    }



    @NotNull

    public String getSqlStatement() {

        return (String) get(DatabaseJob.sqlStatement);

    }



    public void setSqlStatement(String sqlStatement) {

        put(DatabaseJob.sqlStatement, sqlStatement);

    }



    @NotNull

    public String getId() {

        return (String) get(DatabaseJob.id);

    }



    public void setId(String id) {

        put(DatabaseJob.id, id);

    }



    @NotNull

    public String getIndices() {

        return (String) get(DatabaseJob.indices);

    }



    public void setIndices(String indices) {

        put(DatabaseJob.indices, indices);

    }



}

package sgcib.tmon.worker.common.model.job;



import static org.quartz.JobBuilder.newJob;



import java.math.BigDecimal;

import java.sql.Connection;

import java.sql.DriverManager;

import java.sql.ResultSet;

import java.sql.ResultSetMetaData;

import java.sql.SQLException;

import java.sql.Statement;

import java.util.UUID;



import org.quartz.JobDataMap;

import org.quartz.JobDetail;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.cluster.WorkerContext;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 11/06/2015.

*/

public class DatabaseWorkerJob extends WorkerJob {



    private final static Logger logger = LoggerFactory.getLogger(DatabaseWorkerJob.class);



    public DatabaseWorkerJob(Job job, IQueryableStore store) {

        super(job, store);

    }



    @Override

    protected void doExecute(JobDataMap jobDataMap, IQueryableStore store) throws Exception {



        WorkerContext workerContext = WorkerContext.getInstance();

        if (!workerContext.getClusterEnable() || workerContext.isMaster()) {



            String connectionString = jobDataMap.getString(DatabaseJob.connectionString);

            String user = jobDataMap.getString(DatabaseJob.user);

            String password = jobDataMap.getString(DatabaseJob.password);

            String sqlStatement = jobDataMap.getString(DatabaseJob.sqlStatement);

            String itemType = jobDataMap.getString(DatabaseJob.typeDestination);

            String itemName = jobDataMap.getString(DatabaseJob.name);

            // String id = jobDataMap.getString(DatabaseJob.id);

            Connection connection = null;

            Statement statement = null;



            try {

                connection = DriverManager.getConnection(connectionString, user, password);

                statement = connection.createStatement();

                ResultSet resultSet = statement.executeQuery(sqlStatement);



                while (resultSet.next()) {

                    ResultSetMetaData resultSetMetaData = resultSet.getMetaData();

                    int columnCount = resultSetMetaData.getColumnCount();

                    ImmutableList.Builder<Queryable> items = new ImmutableList.Builder<>();

                    if (columnCount >= 1) {

                        Queryable item = new Queryable(itemName, itemType);

                        item.setId(UUID.randomUUID().toString());

                        for (int indexColumn = 1; indexColumn <= columnCount; indexColumn++) {

                            String currentColumnName = resultSetMetaData.getColumnName(indexColumn);

                            Object currentValue = resultSet.getObject(currentColumnName);

                            // Todo : check for each type

                            if (currentValue instanceof BigDecimal) {

                                currentValue = Double.parseDouble(((BigDecimal) currentValue).toPlainString());

                            }

                            item.put(currentColumnName, currentValue);

                        }

                    }

                    store.save(items.build());

                }



            } finally {

                if (statement != null) {

                    statement.close();

                }

                if (connection != null) {

                    connection.close();

                }

            }

        }

    }



    @Override

    public String check() throws WorkerException {



        String returnMessage;



        returnMessage = super.check();

        if (returnMessage.equals("OK")) {

            returnMessage = checkConnectionStringAndSQL();

        }



        return returnMessage;

    }



    public String checkConnectionStringAndSQL() {



        String returnMessage = "OK";



        String connectionString = (String) getJob().getValue(DatabaseJob.connectionString);

        String sqlStatement = (String) getJob().getValue(DatabaseJob.sqlStatement);

        String user = (String) getJob().getValue(DatabaseJob.user);

        String password = (String) getJob().getValue(DatabaseJob.password);



        Connection connection = null;

        Statement statement = null;



        try {

            connection = DriverManager.getConnection(connectionString, user, password);

            statement = connection.createStatement();

            statement.executeQuery(sqlStatement);

        } catch (SQLException sqlException) {

            logger.error(sqlException.getMessage(), sqlException);

            returnMessage = sqlException.getMessage();

        } finally {

            try {

                if (statement != null) {

                    statement.close();

                }

                if (connection != null) {

                    connection.close();

                }

            } catch (SQLException sqlException) {

                logger.error(sqlException.getMessage(), sqlException);

                returnMessage = sqlException.getMessage();

            }

        }



        return returnMessage;

    }



    @Override

    public JobDetail getDetail() {



        // TODO add log information

        return newJob(DatabaseWorkerJob.class).withIdentity(this.getName(), getGroup()).setJobData(new JobDataMap(getJob())).build();



    }



    @Override

    public String getGroup() {

        return "DatabaseJobs";

    }

}

package sgcib.tmon.worker.common.model.job;



import org.joda.time.DateTime;

import org.quartz.Job;

import org.quartz.JobDetail;

import org.quartz.Trigger;

import sgcib.tmon.worker.common.exception.WorkerException;



/**

* Created by adouangp012014 on 03/02/14.

*/

public interface    IJob extends Job {



    JobType getJobType();



    String getName();



    String getComponent();



    String getKey();



    DateTime getCreationDate();



    DateTime getModificationDate();



    DateTime getDeletionDate();



    String check() throws WorkerException;



    void setModificationDate(DateTime updateDate);



    JobDetail getDetail();



    Trigger getTrigger();



    String getGroup();

}

package sgcib.tmon.worker.common.model.job;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import sgcib.tmon.worker.common.model.Queryable;



import javax.validation.constraints.NotNull;

import java.util.Map;



/**

* Created by adouangp012014 on 03/02/14.

*/

public class Job extends Queryable {



    public static String creationDate = "creationDate";

    public static String modificationDate = "modificationDate";

    public static String deletionDate = "deletionDate";

    public static String component = "component";

    public static String frequency = "frequency";

    public static String className = "className";



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    public Job() {

        setCreationDate(DateTime.now());

    }



    public Job(String name, JobType type) {

        this();

        setId(name);

        setName(name);

        setValue(Job.type, type.toString());

    }



    public Job(Map map) {

        super(map);

    }



    public String getClassName() {

        return (String) get(className);

    }



    public void setClassName(String className) {

        put(Job.className, className);

    }



    public DateTime getCreationDate() {

        return dateTimeFormatter.parseDateTime((String) get(Job.creationDate));

    }



    public void setCreationDate(DateTime creationDate) {

        put(Job.creationDate, creationDate.toDateTimeISO().toString());

    }



    public DateTime getModificationDate() {

        if (get(Job.modificationDate) != null) {

            return dateTimeFormatter.parseDateTime((String) get(Job.modificationDate));

        } else {

            return null;

        }

    }



    public void setModificationDate(DateTime modificationDate) {

        put(Job.modificationDate, modificationDate.toDateTimeISO().toString());

    }



    public DateTime getDeletionDate() {

        if (get(Job.deletionDate) != null) {

            return dateTimeFormatter.parseDateTime((String) get(Job.deletionDate));

        } else {

            return null;

        }

    }



    public void setDeletionDate(DateTime suppressionDate) {

        put(Job.deletionDate, suppressionDate.toDateTimeISO().toString());

    }



    @NotNull

    public String getComponent() {

        return (String) get(Job.component);

    }



    public void setComponent(String component) {

        put(Job.component, component);

    }



    public JobType getJobType() {

        return JobType.valueOf((String) get(Job.type));

    }



    @NotNull

    public String getFrequency() {

        return (String) get(frequency);

    }



    public void setFrequency(String frequency) {

        put(Job.frequency, frequency);

    }



}

package sgcib.tmon.worker.common.model.job;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.model.StatusExecutionType;



import java.util.UUID;



/**

* Created by adouangp012014 on 06/02/14.

*/

public class JobStatusExecution extends Queryable {



    public static String jobName = "jobName";

    public static String executionDate = "executionDate";

    public static String status = "status";

    public static String message = "message";

    public static String executionTime = "executionTime";



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    public JobStatusExecution() {

        setId(UUID.randomUUID().toString());

        setType("statusJob");

    }



    public JobStatusExecution(String jobName, DateTime executionDateTime, StatusExecutionType status) {

        this(jobName, executionDateTime, status, status.toString());

        setId(UUID.randomUUID().toString());

        setType("statusJob");

        setName(jobName);

    }



    public JobStatusExecution(String jobName, DateTime executionDateTime, StatusExecutionType status, String message) {

        setId(UUID.randomUUID().toString());

        setType("statusJob");

        setName(jobName);

        setJobName(jobName);

        setExecutionDate(executionDateTime);

        setStatus(status);

        setMessage(message);

    }



    public String getJobName() {

        return (String) get(JobStatusExecution.jobName);

    }



    public void setJobName(String jobName) {

        put(JobStatusExecution.jobName, jobName);

    }



    public DateTime getExecutionDate() {

        return dateTimeFormatter.parseDateTime((String) get(JobStatusExecution.executionDate));

    }



    public void setExecutionDate(DateTime executionDate) {

        put(JobStatusExecution.executionDate, executionDate.toDateTimeISO().toString());

    }



    public String getStatus() {

        return (String) get(JobStatusExecution.status);

    }



    public void setStatus(StatusExecutionType status) {

        put(JobStatusExecution.status, status.toString());

    }



    public String getMessage() {

        return (String) get(JobStatusExecution.message);

    }



    public void setMessage(String message) {

        put(JobStatusExecution.message, message);

    }



    public long getExecutionTime() {

        return (Long) get(JobStatusExecution.executionTime);

    }



    public void setExecutionTime(long executionTime) {

        put(JobStatusExecution.executionTime, executionTime);

    }



}

package sgcib.tmon.worker.common.model.job;



/**

* Created by adouangp012014 on 03/02/14.

*/

public enum JobType {

    Database, Clean, Ssh

}

//package sgcib.tmon.worker.common.model.job;

//

//import com.socgen.deai.common.tmon.connect.exception.AgentException;

//import com.socgen.deai.common.tmon.connect.module.ssh.SshAgent;

//import com.socgen.deai.common.tmon.core.*;

//import com.socgen.deai.common.tmon.credential.Credential;

//import com.tibco.tibrv.TibrvException;

//import com.tibco.tibrv.TibrvMsg;

//import org.quartz.*;

//import sgcib.tmon.worker.common.exception.WorkerException;

//import sgcib.tmon.worker.common.model.Event;

//import sgcib.tmon.worker.common.store.event.EventStore;

//import sgcib.tmon.worker.service.DataService;

//import sgcib.tmon.worker.service.TibcoService;

//

//import java.util.HashMap;

//import java.util.Map;

//import java.util.UUID;

//import java.util.regex.Pattern;

//

//import static org.quartz.CronScheduleBuilder.cronSchedule;

//import static org.quartz.JobBuilder.newJob;

//import static org.quartz.TriggerBuilder.newTrigger;

//

///**

// * Created by adouangp012014 on 24/11/2014.

// */

//public class SshJob extends JobBase {

//

//    /*

//    public static String key = "key";

//    public static String type = "type";

//    public static String name = "name";

//    public static String creationDate = "creationDate";

//    public static String modificationDate = "modificationDate";

//    public static String deletionDate = "deletionDate";

//    public static String component = "component";

//    public static String frequency = "frequency";

//    public static String className = "className";

//     */

//

//    public static String host = "host";

//    public static String user = "user";

//    public static String password = "password";

//    public static String sshKey = "sshKey";

//

//    public static String instanceList = "instanceList";

//    public static String instanceType = "instanceType";

//    public static String instance = "instance";

//

//    public static String method = "method";

//    public static String sendTo = "sendTo"; //V2 or ES

//    public static String format = "format"; //tmon or regexp

//    public static String regexp = "regexp";

//    public static String group0 = "group0";

//    public static String group1 = "group1";

//    public static String group2 = "group2";

//    public static String group3 = "group3";

//    public static String group4 = "group4";

//    public static String group5 = "group5";

//

//    private DataService dataService;

//    private EventStore eventStore;

//

//    public SshJob() {

//        super();

//        setType(JobType.Ssh.toString());

//    }

//

//    public SshJob(String name) {

//        super(name);

//        setType(JobType.Ssh.toString());

//    }

//

//    public SshJob(DataService dataService, EventStore eventStore) {

//        this.dataService = dataService;

//        this.eventStore = eventStore;

//    }

//

//    public String getHost() {

//        return (String) get(SshJob.host);

//    }

//

//    public void setHost(String host) {

//        put(SshJob.host, host);

//    }

//

//    public String getUser() {

//        return (String) get(SshJob.user);

//    }

//

//    public void setUser(String user) {

//        put(SshJob.user, user);

//    }

//

//    public String getPassword() {

//        return (String) get(SshJob.password);

//    }

//

//    public void setPassword(String password) {

//        put(SshJob.password, password);

//    }

//

//    public String getSshKey() {

//        return (String) get(SshJob.sshKey);

//    }

//

//    public void setSshKey(String sshKey) {

//        put(SshJob.sshKey, sshKey);

//    }

//

//    public String getInstanceList() {

//        return (String) get(SshJob.instanceList);

//    }

//

//    public void setInstanceList(String instanceList) {

//        put(SshJob.instanceList, instanceList);

//    }

//

//    public String getInstance() {

//        return (String) get(SshJob.instance);

//    }

//

//    public void setInstance(String instance) {

//        put(SshJob.instance, instance);

//    }

//

//    public String getMethod() {

//        return (String) get(SshJob.method);

//    }

//

//    public void setMethod(String method) {

//        put(SshJob.method, method);

//    }

//

//    public String getSendTo() {

//        return (String) get(SshJob.sendTo);

//    }

//

//    public void setSendTo(String sendTo) {

//        put(SshJob.sendTo, sendTo);

//    }

//

//    public String getFormat() {

//        return (String) get(SshJob.format);

//    }

//

//    public void setFormat(String format) {

//        put(SshJob.format, format);

//    }

//

//    public String getInstanceType() {

//        return (String) get(SshJob.instanceType);

//    }

//

//    public void setInstanceType(String instanceType) {

//        put(SshJob.instanceType, instanceType);

//    }

//

//    public String getRegexp() {

//        return (String) get(SshJob.regexp);

//    }

//

//    public void setRegexp(String regexp) {

//        put(SshJob.regexp, regexp);

//    }

//

//    public String getGroup0() {

//        return (String) get(SshJob.group0);

//    }

//

//    public void setGroup0(String group0) {

//        put(SshJob.group0, group0);

//    }

//

//    public String getGroup1() {

//        return (String) get(SshJob.group1);

//    }

//

//    public void setGroup1(String group1) {

//        put(SshJob.group1, group1);

//    }

//

//    public String getGroup2() {

//        return (String) get(SshJob.group2);

//    }

//

//    public void setGroup2(String group2) {

//        put(SshJob.group2, group2);

//    }

//

//    public String getGroup3() {

//        return (String) get(SshJob.group3);

//    }

//

//    public void setGroup3(String group3) {

//        put(SshJob.group3, group3);

//    }

//

//    public String getGroup4() {

//        return (String) get(SshJob.group4);

//    }

//

//    public void setGroup4(String group4) {

//        put(SshJob.group4, group4);

//    }

//

//    public String getGroup5() {

//        return (String) get(SshJob.group5);

//    }

//

//    public void setGroup5(String group5) {

//        put(SshJob.group5, group5);

//    }

//

//

//    @Override

//    public String check() throws WorkerException {

//        return null;

//    }

//

//    @Override

//    public JobDetail getDetail() {

//

//        //TODO add log information

//        return newJob(SshJob.class)

//                .withIdentity(this.getName(), getGroup())

//                .setJobData(new JobDataMap(this)).build();

//

//    }

//

//    @Override

//    public Trigger getTrigger() {

//

//        //TODO add log information

//        String triggerName = "trigger_" + UUID.randomUUID().toString();

//

//        return newTrigger()

//                .withIdentity(triggerName, getGroup())

//                .startNow()

//                .withSchedule(cronSchedule(getFrequency()))

//                .build();

//

//    }

//

//    @Override

//    public String getGroup() {

//        return "SshJobs";

//    }

//

//    @Override

//    public void execute(JobExecutionContext context) throws JobExecutionException {

//

//        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

//

//        String name = jobDataMap.getString(SshJob.name);

//

//        String user = jobDataMap.getString(SshJob.user);

//        String password = jobDataMap.getString(SshJob.password);

//        String sshKey = jobDataMap.getString(SshJob.sshKey);

//

//        String host = jobDataMap.getString(SshJob.host);

//        String method = jobDataMap.getString(SshJob.method);

//        String sshJobInstanceType = jobDataMap.getString(SshJob.instanceType);

//        String format = jobDataMap.getString(SshJob.format);

//        String instanceList = jobDataMap.getString(SshJob.instanceList);

//        String instance = jobDataMap.getString(SshJob.instance);

//        String regexp = jobDataMap.getString(SshJob.regexp);

//        String group0 = jobDataMap.getString(SshJob.group0);

//        String group1 = jobDataMap.getString(SshJob.group1);

//        String group2 = jobDataMap.getString(SshJob.group2);

//        String group3 = jobDataMap.getString(SshJob.group3);

//        String group4 = jobDataMap.getString(SshJob.group4);

//        String group5 = jobDataMap.getString(SshJob.group5);

//

//        //get mapping group/indicator

//        Map<String, String> sshGroupList = new HashMap<String, String>();

//        sshGroupList.put(SshJob.group0, group0);

//        sshGroupList.put(SshJob.group1, group1);

//        sshGroupList.put(SshJob.group2, group2);

//        sshGroupList.put(SshJob.group3, group3);

//        sshGroupList.put(SshJob.group4, group4);

//        sshGroupList.put(SshJob.group5, group5);

//

//

//        // on parcours tous les mapping events

//        // pour voir si il y en a un qui correspond  l'instanceType renseign dans la configuration du SshJob

//        // et on rcupre le mapping

//        Map<String, String> mappingList = new HashMap<String, String>();

//        boolean mappingExistForCurrentTmonType = false;

//        mappingExistForCurrentTmonType = getMappingExitForCurrentTmonType(sshJobInstanceType, mappingList, mappingExistForCurrentTmonType);

//

//

//        if (mappingExistForCurrentTmonType) {

//

//            Credential credential = null;

//            try {

//                if (CoreUtils.isNullOrEmpty(sshKey)) {

//                    credential = new Credential(user, password, false);

//                } else {

//                    credential = new Credential(user, user, password, sshKey, false);

//                }

//

//            } catch (Exception ex) {

//                throw new WorkerException(ex);

//            }

//

//            try {

//                Object res = SshAgent.getSshAgent(host, credential).call(method, "sh -c 'PATH=$PATH:${path}:.;[ -d ${path} ] && cd ${path};${command}'", credential, true, null, null, false);

//

//                ReturnData result = (ReturnData) res;

//

//                if (result == null) {

//                    return;

//                }

//

//                String stdout = result.stdout;

//

//                if (format.equalsIgnoreCase("tmon")) {

//                    createMessageFromTmonFormat(stdout, mappingList);

//                } else {

//                    createMessageFromRegexpFormat(instanceList, instance, regexp, sshGroupList, mappingList, stdout);

//                }

//            } catch (AgentException e) {

//                e.printStackTrace();

//            }

//        } else {

//            throw new WorkerException("There is no mapping for instanceType: " + sshJobInstanceType);

//        }

//    }

//

//    private void createMessageFromRegexpFormat(String instanceList, String instance, String regexp, Map<String, String> sshGroupList, Map<String, String> mappingList, String stdout) {

//        Pattern pattern = Pattern.compile(regexp);

//

//        //remove line breaker of linux echo

//        if (stdout.endsWith("\n")) {

//            stdout = stdout.substring(0, stdout.length() - 1);

//        }

//

//        java.util.regex.Matcher matcher = pattern.matcher(stdout);

//

//        boolean bMatch = matcher.matches();

//

//        if (bMatch) {

//

//            Map<String, String> groupValueList = new HashMap<String, String>();

//

//            // pour chaque groupe

//            for (int i = 0; i <= matcher.groupCount(); i++) {

//                String groupKey = "group" + i;

//                groupValueList.put(groupKey, matcher.group(i));

//            }

//

//            TibrvMsg msg = null;

//            msg = new TibrvMsg();

//            try {

//                msg.setSendSubject(TibcoService.getConfigurationSingleton().getSubject());

//                msg.add("type", "instance");

//                msg.add("instanceList", instanceList);

//                msg.add("instance", instance);

//

//                for (Map.Entry<String, String> stringStringEntry : sshGroupList.entrySet()) {

//                    String currentGroup = stringStringEntry.getKey();

//                    String currentIndicator = stringStringEntry.getValue();

//                    if (!CoreUtils.isNullOrEmpty(currentIndicator)) {

//

//                        if (groupValueList.containsKey(currentGroup)) {

//                            String currentValue = groupValueList.get(currentGroup);

//

//                            Object valueConverted = convertValue(mappingList, currentIndicator, currentValue);

//

//                            addIndicator(msg, currentIndicator, valueConverted);

//

//                        }

//                    }

//                }

//

//                TibcoService.getTransportSingleton().send(msg);

//

//            } catch (TibrvException e) {

//                e.printStackTrace();

//            }

//        } else {

//            throw new WorkerException("The regex {" + regexp + "} doesn't  matches with {" + stdout + "}");

//        }

//    }

//

//    private boolean getMappingExitForCurrentTmonType(String sshJobInstanceType, Map<String, String> mappingList, boolean mappingExistForCurrentTmonType) {

//        //Event[] events = this.eventStore.read(MappingService.mappingType);

//        Event[] events = this.eventStore.read("*","mapping");

//

//        if (events.length > 0) {

//            for (int i = 0; i < events.length; i++) {

//                Event event = events[i];

//

//                String currentInstanceType = event.get("name").toString();

//

//                if (currentInstanceType.equals(sshJobInstanceType)) {

//

//                    mappingExistForCurrentTmonType = true;

//

//                    i = events.length;

//

//                    for (Map.Entry<String, Object> stringObjectEntry : event.entrySet()) {

//                        String key = stringObjectEntry.getKey();

//                        String value = stringObjectEntry.getValue().toString();

//

//                        mappingList.put(key, value);

//                    }

//                }

//

//            }

//        }

//        return mappingExistForCurrentTmonType;

//    }

//

//    private void createMessageFromTmonFormat(String string, Map<String, String> mappingList) {

//

//        string = string.replaceAll("\r\n", "\n");

//        String[] lines = string.split("\n");

//

//

//        EventQueue eventQueue = null;

//        AlertConnector alertConnector = null;

//

//        String instanceList;

//        String instance;

//

//        for (String line : lines) {

//            StringParser parser = new StringParser();

//            parser.reset(line);

//            int i = 0;

//            try {

//                if (parser.checkToken("instanceList:")) {

//                    instanceList = parser.getName(";");

//                    if (CoreUtils.isNullOrEmpty(instanceList)) {

//                        throw new Exception("instance list value is missing");

//                    } else if (parser.checkToken("instance:")) {

//                        instance = parser.getName(";");

//                        if (CoreUtils.isNullOrEmpty(instance)) {

//                            throw new Exception("instance value is missing");

//                        } else {

//                            executeInstance(parser, instanceList, instance, mappingList);

//                        }

//                    }

//                } /*

//                else if (parser.checkToken("instance:")) {

//                    if (instanceList != null) {

//                        executeInstance(parser, instanceList);

//                    } else {

//                        throw new Exception("undefined instance list");

//                    }

//                } else if (parser.checkToken("link:")) {

//                    executeLink(parser, instanceList);

//                } else if (parser.checkToken("delete:")) {

//                    executeDelete(parser, instanceList);

//                } else if (parser.checkToken("eventQueue:")) {

//                    name = parser.getName(";");

//                    eventQueue = EventQueue.getQueue(name);

//                    if (eventQueue == null) {

//                        throw new Exception("unknown event queue : " + name);

//                    }

//                    if (parser.checkToken("clearQueue;")) {

//                        if (eventQueue != null) {

//                            executeClear(parser, eventQueue);

//                        }

//                    }

//                    if (parser.checkToken("delete:")) {

//                        executeDeleteEvent(parser, eventQueue);

//                    }

//                    if (parser.checkToken("event:")) {

//                        executeEvent(parser, eventQueue);

//                    } else if (line.contains("fields[")) {

//                        executeEvent(parser, eventQueue);

//                    }

//                } else if (parser.checkToken("clearQueue;")) {

//                    if (eventQueue != null) {

//                        executeClear(parser, eventQueue);

//                    } else {

//                        throw new Exception("undefined event queue");

//                    }

//                } else if (parser.checkToken("event:")) {

//                    if (eventQueue != null) {

//                        executeEvent(parser, eventQueue);

//                    } else {

//                        throw new Exception("undefined event queue");

//                    }

//                }

//                if (parser.checkToken("alertConnector:")) {

//                    name = parser.getName(";");

//                    alertConnector = AlertConnector.getAlertConnector(name);

//                    if (alertConnector == null) {

//                        throw new Exception("unknown alertConnector : " + name);

//                    }

//                    if (parser.checkToken("alert:")) {

//                        executeAlert(parser, alertConnector);

//                    }

//                } else if (parser.checkToken("alert:")) {

//                    if (alertConnector != null) {

//                        executeAlert(parser, alertConnector);

//                    } else {

//                        throw new Exception("undefined alertConnector");

//                    }

//                }*/

//                parser.getEol();

//            } catch (Exception exc) {

//                //logger.error("Dispatcher : " + exc.getMessage(), exc);

//                //logger.error(parser.showLine());

//            }

//        }

//

//    }

//

//    private void executeInstance(StringParser parser, String instanceList, String instance, Map<String, String> mappingList) throws Exception {

//        //Instance instance = null;

//        TibrvMsg msg = null;

//        //String name = parser.getName(";");

//        String name;

//        String value;

//        Object valueConverted = null;

//        //instance = instanceList.getInstance(name, true);

//        //msg = createInstanceMsg(instanceList, instance.getName());

//

//        //mappingInstanceTypeList

//        //Map<String, String> mappingList

//

//

//        msg = new TibrvMsg();

//        msg.setSendSubject(TibcoService.getConfigurationSingleton().getSubject());

//        msg.add("type", "instance");

//        msg.add("instanceList", instanceList);

//        msg.add("instance", instance);

//

//        if (parser.checkToken("time=")) {

//            value = parser.getValue();

//            long time = TimeType.getSingleton().unserialize(value);

//            setTime(msg, time);

//        }

//        if (parser.checkToken("indicators[")) {

//            while (!parser.checkToken("];")) {

//                name = parser.getName("=");

//                value = parser.getValue();

//                /*Indicator indicator = instance.getIndicator(name);

//                if ((indicator != null) && !value.equals("")) {

//                    addIndicator(msg, name, indicator.getTaskType().unserialize(value));

//                }*/

//

//                if ((name != null) && !value.equals("")) {

//

//                    valueConverted = convertValue(mappingList, name, value);

//

//                    //addIndicator(msg, name, value);

//                    addIndicator(msg, name, valueConverted);

//                }

//            }

//        }

//        if (parser.checkToken("properties[")) {

//            while (!parser.checkToken("];")) {

//                name = parser.getName("=");

//                value = parser.getValue();

//                if ((name != null) && !value.equals("")) {

//                    addProperty(msg, name, value);

//                }

//            }

//        }

//        if (parser.checkToken("to[")) {

//            while (!parser.checkToken("];")) {

//                name = parser.getName("=");

//                value = parser.getValue();

//                if ((name != null) && !value.equals("")) {

//                    addLink(msg, name, value, true);

//                }

//            }

//        }

//        if (parser.checkToken("from[")) {

//            while (!parser.checkToken("];")) {

//                name = parser.getName("=");

//                value = parser.getValue();

//                if ((name != null) && !value.equals("")) {

//                    addLink(msg, name, value, false);

//                }

//            }

//        }

//

//        TibcoService.getTransportSingleton().send(msg);

//    }

//

//    private Object convertValue(Map<String, String> mappingList, String indicatorName, String indicatorValue) {

//

//        Object valueConverted;

//        if (mappingList.containsKey(indicatorName)) {

//            String type = mappingList.get(indicatorName);

//            switch (type) {

//                case "integer":

//                    valueConverted = Integer.parseInt(indicatorValue);

//                    break;

//                case "float":

//                    valueConverted = Float.parseFloat(indicatorValue);

//                    break;

//                case "date":

//                case "long":

//                    valueConverted = Long.parseLong(indicatorValue);

//                    break;

//                default:

//                    valueConverted = indicatorValue;

//                    break;

//            }

//        } else {

//            valueConverted = indicatorValue;

//        }

//        return valueConverted;

//    }

//

//

//    // can be used on both instance and event messages

//    private void setTime(TibrvMsg msg, long time) throws TibrvException {

//        msg.add("time", time);

//    }

//

//    private void addIndicator(TibrvMsg msg, String indicator, Object value) throws TibrvException {

//        TibrvMsg msg1 = (TibrvMsg) msg.get("indicators");

//        if (msg1 == null) {

//            msg1 = new TibrvMsg();

//            msg.add("indicators", msg1);

//        }

//        TibrvMsg msg2 = new TibrvMsg();

//        msg1.add(indicator, msg2);

//        if (value != null) {

//            msg2.add("object", truncateIfTooLong(indicator, value));

//        }

//    }

//

//    public void addProperty(TibrvMsg msg, String property, Object value) throws TibrvException {

//        TibrvMsg msg1 = (TibrvMsg) msg.get("properties");

//        if (msg1 == null) {

//            msg1 = new TibrvMsg();

//            msg.add("properties", msg1);

//        }

//        msg1.add(property, truncateIfTooLong(property, value));

//    }

//

//    public void addLink(TibrvMsg msg, String link, String instance, boolean isForward) throws TibrvException {

//        TibrvMsg msg1 = (TibrvMsg) msg.get(isForward ? "to" : "from");

//        if (msg1 == null) {

//            msg1 = new TibrvMsg();

//            msg.add(isForward ? "to" : "from", msg1);

//        }

//        msg1.add(link, instance);

//    }

//

//    private static Object truncateIfTooLong(String field, Object value) {

//        if (value != null && value instanceof String) {

//            String stringValue = (String) value;

//            if (stringValue.length() > 25000) {// max 25000 characters

//                MainProg.msgLog

//                        .warn("Content of field '"

//                                + field

//                                + "' has been truncated, because size is too important (maximum size if 25000 characters), here an extract of first characters "

//                                + stringValue.substring(0, 50));

//                value = stringValue.substring(0, 25000);

//            }

//        }

//        return value;

//    }

//

//

//    private void executeLink(StringParser parser, InstanceList instanceList) {

//    }

//

//    private void executeDelete(StringParser parser, InstanceList instanceList) {

//    }

//

//    private void executeClear(StringParser parser, EventQueue eventQueue) {

//    }

//

//    private void executeDeleteEvent(StringParser parser, EventQueue eventQueue) {

//    }

//

//    private void executeEvent(StringParser parser, EventQueue eventQueue) {

//    }

//

//    private void executeAlert(StringParser parser, AlertConnector alertConnector) {

//

//    }

//

//}

package sgcib.tmon.worker.common.model.job;



import static org.quartz.CronScheduleBuilder.cronSchedule;

import static org.quartz.TriggerBuilder.newTrigger;



import java.util.UUID;



import org.joda.time.DateTime;

import org.quartz.CronExpression;

import org.quartz.JobDataMap;

import org.quartz.JobExecutionContext;

import org.quartz.JobExecutionException;

import org.quartz.Trigger;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.StatusExecutionType;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



/**

* Created by Stephane on 11/06/2015.

*/

public abstract class WorkerJob implements IJob {



    private final static Logger logger = LoggerFactory.getLogger(WorkerJob.class);



    private final Job job;

    private final IQueryableStore store;



    public WorkerJob(Job job, IQueryableStore store) {

        this.job = job;

        this.store = store;

    }



    @Override

    public JobType getJobType() {

        return job.getJobType();

    }



    @Override

    public String getName() {

        return job.getName();

    }



    @Override

    public String getComponent() {

        return job.getComponent();

    }



    @Override

    public String getKey() {

        return job.getId();

    }



    @Override

    public DateTime getCreationDate() {

        return job.getCreationDate();

    }



    @Override

    public DateTime getModificationDate() {

        return job.getModificationDate();

    }



    @Override

    public DateTime getDeletionDate() {

        return job.getDeletionDate();

    }



    @Override

    public void setModificationDate(DateTime updateDate) {

        job.setModificationDate(updateDate);

    }



    protected IQueryableStore getStore() {

        return store;

    }



    protected Job getJob() {

        return job;

    }



    @Override

    public void execute(JobExecutionContext context) throws JobExecutionException {

        long start = DateTime.now().getMillis();



        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

        String jobName = jobDataMap.getString(Job.name);



        JobStatusExecution jobStatusExecution = null;



        if (store != null) {

            try {

                doExecute(jobDataMap, store);

                jobStatusExecution = new JobStatusExecution(jobName, new DateTime(), StatusExecutionType.Ok, StatusExecutionType.Ok.toString());

            } catch (Exception error) {

                logger.error(error.getMessage(), error);

                jobStatusExecution = new JobStatusExecution(jobName, new DateTime(), StatusExecutionType.Error, error.getMessage());

                throw new WorkerException("Job execution failed", error);

            } finally {

                long executionTime = DateTime.now().getMillis() - start;

                jobStatusExecution.setExecutionTime(executionTime);

                store.save(jobStatusExecution);

            }

        }

    }



    @Override

    public Trigger getTrigger() {

        String triggerName = "trigger_" + UUID.randomUUID().toString();



        return newTrigger().withIdentity(triggerName, getGroup()).startNow().withSchedule(cronSchedule(getJob().getFrequency())).build();

    }



    @Override

    public String check() throws WorkerException {

        String returnMessage = "OK";

        String cronExpression = getJob().getFrequency();

        if (!CronExpression.isValidExpression(cronExpression)) {

            returnMessage = "The cron expression is invalid.";

        }

        return returnMessage;

    }



    protected abstract void doExecute(JobDataMap jobDataMap, IQueryableStore store) throws Exception;

}

package sgcib.tmon.worker.common.processor.alert;



import sgcib.tmon.worker.common.model.ServiceLevelAgreement;



/**

* @author ablaszcz120213

*

*/

public interface IServiceLevelAgreementAutomation {



    /**

     * Execute the intented behaviour (closing old alerts for instance)

     * according to the given service level agreement {@code sla}.

     *

     * @param sla

     *            Service level agreeement.

     */

    void update(ServiceLevelAgreement sla);

}

package sgcib.tmon.worker.common.processor.alert;



import java.util.List;

import java.util.Optional;



import org.joda.time.DateTime;



import sgcib.tmon.worker.cluster.WorkerContext;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertPriority;

import sgcib.tmon.worker.common.model.AlertStatus;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.IServiceLevelAgreementFactory;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterion;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.ServiceLevelAgreement;

import sgcib.tmon.worker.common.processor.ProcessorBase;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



public class ServiceLevelAgreementProcessor extends ProcessorBase<DateTime> implements IServiceLevelAgreementAutomation {

    private final IQueryableStore eventStore;

    private final IServiceLevelAgreementFactory factory;

    private final IAlertManager alertManager;



    public ServiceLevelAgreementProcessor(String name, IQueryableStore eventStore, IServiceLevelAgreementFactory factory, IAlertManager alertManager) {

        super(name);

        this.eventStore = eventStore;

        this.factory = factory;

        this.alertManager = alertManager;

    }



    public void check() {

        process(new DateTime());

    }



    @Override

    protected void doProcess(DateTime timeStamp) {



        // SLA run only on master.

        if (!WorkerContext.getInstance().isMaster()) {

            return;

        }



        List<ServiceLevelAgreement> serviceLevelAgreements = factory.buildAll();



        Optional<IAlertManager> opt = Optional.of(alertManager);

        if (opt.isPresent()) {

            for (ServiceLevelAgreement serviceLevelAgreement : serviceLevelAgreements) {

                if (serviceLevelAgreement != null) {

                    List<Alert> alerts = serviceLevelAgreement.validate(eventStore);

                    if (alerts != null && !alerts.isEmpty()) {

                        for (Alert alert : alerts) {

                            alertManager.raiseAlert(alert);

                        }

                    }

                    update(serviceLevelAgreement);

                }

            }

        }

    }



    @Override

    public void update(ServiceLevelAgreement serviceLevelAgreement) {



        DateTime now = DateTime.now().minusMinutes(serviceLevelAgreement.getCloseQuietly());



        IQuery query = new Query().addCriterion( //

                new QueryCriterion(Alert.type, "alert", QueryCriterionType.Is), //

                new QueryCriterion(Alert.status, AlertStatus.Open, QueryCriterionType.Is), //

                new QueryCriterion(Alert.brokenSla, serviceLevelAgreement.getName(), QueryCriterionType.Is), //

                new QueryCriterion(Alert.timestamp, now, QueryCriterionType.After));



        List<Alert> oldAlerts = alertManager.getAlerts(query);

        if (oldAlerts != null && oldAlerts.size() > 0) {

            for (Alert oldAlert : oldAlerts) {

                if (!AlertPriority.Info.equals(oldAlert.getPriority())) {

                    oldAlert.setStatus(AlertStatus.Closed);

                    oldAlert.setValue("closedQuietly", DateTime.now());

                    alertManager.save(oldAlert);

               }

            }

        }

    }



    @Override

    protected void doCreate() {



    }



    @Override

    protected void doDestroy() {



    }



}/**

* Handles service level agreement behaviour and alerts.

*

*/

package sgcib.tmon.worker.common.processor.alert;package sgcib.tmon.worker.common.processor.job;



import java.util.List;

import java.util.Map;

import java.util.Properties;



import org.joda.time.DateTime;

import org.quartz.JobDetail;

import org.quartz.JobKey;

import org.quartz.Scheduler;

import org.quartz.SchedulerException;

import org.quartz.Trigger;

import org.quartz.impl.StdSchedulerFactory;

import org.quartz.impl.matchers.GroupMatcher;

import org.quartz.spi.JobFactory;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.job.CleanWorkerJob;

import sgcib.tmon.worker.common.model.job.DatabaseWorkerJob;

import sgcib.tmon.worker.common.model.job.Job;

import sgcib.tmon.worker.common.model.job.WorkerJob;

import sgcib.tmon.worker.common.processor.ProcessorBase;

import sgcib.tmon.worker.common.store.job.IJobStore;



import com.google.common.collect.Maps;



/**

* Created by adouangp012014 on 04/02/14.

*/

public class JobProcessor extends ProcessorBase<DateTime> {



    private final IJobStore jobStore;

    private final Scheduler scheduler;

    private DateTime lastExecutionDate;



    public JobProcessor(String name, IJobStore jobStore, JobFactory jobFactory, Integer threadCount) throws SchedulerException {

        super(name);

        this.jobStore = jobStore;

        Properties properties = new Properties();

        properties.setProperty("org.terracotta.quartz.skipUpdateCheck", "true");

        properties.setProperty("org.quartz.scheduler.instanceName", name);

        properties.setProperty("org.quartz.threadPool.threadCount", threadCount.toString());

        properties.setProperty("org.quartz.jobStore.class", "org.quartz.simpl.RAMJobStore");

        properties.setProperty("org.quartz.threadPool.class", "org.quartz.simpl.SimpleThreadPool");

        StdSchedulerFactory stdSchedulerFactory = new StdSchedulerFactory(properties);

        this.scheduler = stdSchedulerFactory.getScheduler();

        this.scheduler.setJobFactory(jobFactory);

        this.lastExecutionDate = null;

    }



    public void check() throws SchedulerException {

        getLogger().debug("Checking job processor");

        doProcess(DateTime.now());

    }



    @Override

    protected void doProcess(DateTime currentExecutionDate) {

        try {

            getLogger().debug("Processing jobs ...");

            // get all jobs in ElasticSearch

            List<Job> jobs = this.jobStore.getAllJobs();

            getLogger().debug(String.format("... found %s jobs to process", jobs.size()));



            // create a map<jobName, job>

            Map<String, WorkerJob> workerJobs = Maps.newHashMap();

            for (Job job : jobs) {

                switch (job.getJobType()) {

                case Database:

                    workerJobs.put(job.getName(), new DatabaseWorkerJob(job, null));

                    break;

                case Clean:

                    workerJobs.put(job.getName(), new CleanWorkerJob(job, null));

                    break;

                case Ssh:

                    break;

                default:

                    break;

                }

            }



            if (this.lastExecutionDate != null) {

                // loop on all jobs declared in the scheduler

                for (String groupName : this.scheduler.getJobGroupNames()) {

                    for (JobKey jobKey : this.scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))) {

                        WorkerJob workerJob = workerJobs.get(jobKey.getName());

                        // if the current job exist in ES

                        if (workerJob != null) {

                            DateTime modificationDate = workerJob.getModificationDate();

                            // compare the modificationDate of the current job

                            // and the last execution date

                            if (modificationDate != null && modificationDate.compareTo(this.lastExecutionDate) > 0) {

                                // the job was modify, so re-run it with the new

                                // config

                                scheduleUpdateJob(workerJob);

                            }

                            workerJobs.values().remove(workerJob);

                        } else {

                            scheduleDeleteJob(jobKey.getName(), groupName);

                        }

                    }

                }

            }



            // run all new jobs

            for (WorkerJob workerJob : workerJobs.values()) {

                scheduleNewJob(workerJob);

            }



            this.lastExecutionDate = currentExecutionDate;

        } catch (SchedulerException error) {

            getLogger().error(String.format("Cannot stop job processor : %s", error.getMessage()));

        }



    }



    @Override

    protected void doDestroy() throws WorkerException {

        try {

            this.scheduler.shutdown();

        } catch (SchedulerException error) {

            getLogger().error(String.format("Cannot stop job processor : %s", error.getMessage()));

            throw new WorkerException("Cannot stop job processor", error);

        }

    }



    @Override

    protected void doCreate() throws WorkerException {

        try {

            this.scheduler.start();

        } catch (SchedulerException error) {

            getLogger().error(String.format("Cannot start job processor : %s", error.getMessage()));

            throw new WorkerException("Cannot start job processor", error);

        }

    }



    private void scheduleUpdateJob(WorkerJob job) throws SchedulerException {

        JobKey jobKey = new JobKey(job.getName(), job.getGroup());

        getLogger().debug(String.format("Job %s has to be updated", job.getName()));

        List<Trigger> triggerList = (List<Trigger>) scheduler.getTriggersOfJob(jobKey);

        if (triggerList.size() > 0) {

            this.scheduler.deleteJob(jobKey);

            scheduleNewJob(job);

        }

    }



    private void scheduleNewJob(WorkerJob job) throws SchedulerException {

        getLogger().debug(String.format("Job %s has to be created", job.getName()));

        JobDetail jobDetail = job.getDetail();

        Trigger trigger = job.getTrigger();

        this.scheduler.scheduleJob(jobDetail, trigger);

    }



    private void scheduleDeleteJob(String jobName, String group) throws SchedulerException {

        getLogger().debug(String.format("Job %s has to be deleted", jobName));

        JobKey jobKey = new JobKey(jobName, group);

        scheduler.deleteJob(jobKey);

    }

}

package sgcib.tmon.worker.common.processor.job;



import org.quartz.Job;

import org.quartz.JobDetail;

import org.quartz.Scheduler;

import org.quartz.SchedulerException;

import org.quartz.spi.JobFactory;

import org.quartz.spi.TriggerFiredBundle;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



import java.lang.reflect.Constructor;



/**

* Created by adouangp012014 on 28/02/14.

*/

public class WorkerJobFactory implements JobFactory {



    private final IQueryableStore store;



    private final Logger log = LoggerFactory.getLogger(getClass());



    protected Logger getLog() {

        return log;

    }



    public WorkerJobFactory(IQueryableStore store) {

        this.store = store;

    }



    @Override

    public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException, WorkerException {



        JobDetail jobDetail = bundle.getJobDetail();

        Class<? extends Job> jobClass = jobDetail.getJobClass();

        try {



            log.debug(String.format("Producing instance of Job '%s', class=%s", jobDetail.getKey(), jobClass.getName()));



            Constructor<? extends Job> constructor = jobClass.getConstructor(sgcib.tmon.worker.common.model.job.Job.class, IQueryableStore.class);

            if (constructor == null) {

                throw new WorkerException(String.format("Constructor(Job, IQueryableStore) is missing in the class %s. The Job %s cannot be create.", jobClass.getName(), jobDetail.getKey().getName()));

            }



            return constructor.newInstance(new sgcib.tmon.worker.common.model.job.Job(jobDetail.getJobDataMap()), this.store);



        } catch (Exception error) {

            throw new SchedulerException(String.format("Problem instantiating class '%s'", jobDetail.getJobClass().getName()), error);

        }



    }



}

package sgcib.tmon.worker.common.processor.metric;





import java.util.List;



public class Capacity {

    private String name;

    private String eventName;

    private String eventType;

    private String eventField;

    private String queryFilter;

    private String component;

    private String host;

    private String workflow;

    private String task;

    private int period;

    private int periodForward;

    private double threshold;

    private CapacityScope periodScope;

    private List<CapacityPoint> points;

    private CapacityPoint alertPoint;

    private CapacityPoint estimatePoint;

    private String errorMessage;



    public Capacity() {

    }



    public Capacity(String name, String eventType, String eventName, String eventField, int period, CapacityScope periodScope) {

        this.name = name;

        this.eventType = eventType;

        this.eventName = eventName;

        this.eventField = eventField;

        this.period = period;

        this.periodScope = periodScope;

        this.periodForward = -1;

        this.alertPoint = null;

        this.estimatePoint = null;

        this.component=null;

        this.host=null;

        this.workflow = null;

        this.task=null;

        this.queryFilter=null;

    }



    public String getName() {

        return name;

    }



    public void setName(String name) {

        this.name = name;

    }



    public String getEventName() {

        return eventName;

    }



    public void setEventName(String eventName) {

        this.eventName = eventName;

    }



    public String getEventType() {

        return eventType;

    }



    public void setEventType(String eventType) {

        this.eventType = eventType;

    }



    public String getEventField() {

        return eventField;

    }



    public void setEventField(String eventField) {

        this.eventField = eventField;

    }



    public String getQueryFilter() {

        return queryFilter;

    }



    public void setQueryFilter(String queryFilter) {

        this.queryFilter = queryFilter;

    }



    public String getComponent() {

        return component;

    }



    public void setComponent(String component) {

        this.component = component;

    }



    public String getHost() {

        return host;

    }



    public void setHost(String host) {

        this.host = host;

    }



    public String getWorkflow() {

        return workflow;

    }



    public void setWorkflow(String workflow) {

        this.workflow = workflow;

    }



    public String getTask() {

        return task;

    }



    public void setTask(String task) {

        this.task = task;

    }



    public int getPeriod() {

        return period;

    }



    public void setPeriod(int period) {

        this.period = period;

    }



    public int getPeriodForward() {

        return periodForward;

    }



    public void setPeriodForward(int periodForward) {

        this.periodForward = periodForward;

   }



    public double getThreshold() {

        return threshold;

    }



    public void setThreshold(double threshold) {

        this.threshold = threshold;

    }



    public CapacityScope getPeriodScope() {

        return periodScope;

    }



    public void setPeriodScope(CapacityScope periodScope) {

        this.periodScope = periodScope;

    }



    public List<CapacityPoint> getPoints() {

        return points;

    }



    public void setPoints(List<CapacityPoint> points) {

        this.points = points;

    }



    public CapacityPoint getAlertPoint() {

        return alertPoint;

    }



    public void setAlertPoint(CapacityPoint alertPoint) {

        this.alertPoint = alertPoint;

    }



    public CapacityPoint getEstimatePoint() {

        return estimatePoint;

    }



    public void setEstimatePoint(CapacityPoint estimatePoint) {

        this.estimatePoint = estimatePoint;

    }



    public String getErrorMessage() {

        return errorMessage;

    }



    public void setErrorMessage(String errorMessage) {

        this.errorMessage = errorMessage;

    }

}

package sgcib.tmon.worker.common.processor.metric;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.model.Metric;



public class CapacityPoint extends Metric{

    private final DateTime date;

    private double estimate;

    private String label;



    public CapacityPoint(DateTime date) {

        this.date = date;

    }



    public DateTime getDate() {

        return date;

    }



    public double getEstimate() {

        return estimate;

    }



    public void setEstimate(double estimate) {

        this.estimate = estimate;

    }



    public String getLabel() {

        return label;

    }



    public void setLabel(String label) {

       this.label = label;

    }





}

package sgcib.tmon.worker.common.processor.metric;



import java.util.Map;



import org.apache.commons.math.stat.regression.SimpleRegression;

import org.joda.time.DateTime;

import org.joda.time.Period;



import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.processor.ProcessorBase;

import sgcib.tmon.worker.common.store.event.IEventStore;



import com.google.common.collect.ImmutableList;



public class CapacityProcessor extends ProcessorBase<Capacity> {

    private final IEventStore store;



    public CapacityProcessor(String name, IEventStore store) {

        super(name);

        this.store = store;

    }



    @Override

    protected void doProcess(Capacity capacity) {

        try {

            DateTime now = DateTime.now();

            String itemType = capacity.getEventType();

            Query query = new Query();

            query.addCriterion(Queryable.type, itemType, QueryCriterionType.Is);

            query.addCriterion(Queryable.name, capacity.getEventName(), QueryCriterionType.Is);

            query.addCriterion(Queryable.timestamp, getStartDate(capacity.getPeriod(), capacity.getPeriodScope(), now), QueryCriterionType.GreaterOrEqualThan);

            query.addCriterion(Queryable.timestamp, now, QueryCriterionType.LesserOrEqualThan);



            Map<DateTime, CapacityPoint> points = store.readCapacity(query, capacity.getEventType(), capacity.getEventName(), capacity.getEventField(), capacity.getPeriodScope(), 1);



            SimpleRegression regression = new SimpleRegression();



            if (points == null || points.size() < 3) {

                capacity.setPoints(null);

                capacity.setErrorMessage("Not enough points to compute a regression !!");

                return;

            }



            for (Map.Entry<DateTime, CapacityPoint> point : points.entrySet()) {

                regression.addData(point.getKey().getMillis(), point.getValue().getMean());

                point.getValue().setEstimate(regression.predict(point.getValue().getDate().getMillis()));

                point.getValue().setLabel(toShortDate(capacity.getPeriodScope(), point.getValue().getDate()));

            }



            if (capacity.getPeriodForward() != 0) {

                DateTime endDate = getEndDate(capacity.getPeriodForward(), capacity.getPeriodScope(), now);

                CapacityPoint estimatePoint = new CapacityPoint(endDate);

                estimatePoint.setEstimate(regression.predict(endDate.getMillis()));

                estimatePoint.setLabel(toShortDate(capacity.getPeriodScope(), estimatePoint.getDate()));

                capacity.setEstimatePoint(estimatePoint);

            }



            if (capacity.getThreshold() > 0.0) {

                double b = regression.getIntercept();

                double a = regression.getSlope();

                try {

                    DateTime alertDate = new DateTime((long) ((capacity.getThreshold() - b) / a));



                    CapacityPoint alertPoint = new CapacityPoint(alertDate);

                    alertPoint.setEstimate(regression.predict(alertDate.getMillis()));

                    Period delay = new Period(now, alertDate);



                    StringBuilder alert = new StringBuilder();

                    if (delay.getYears() != 0) {

                        alert.append(delay.getYears()).append(" years ");

                    }

                    if (delay.getMonths() != 0) {

                        alert.append(delay.getMonths()).append(" months ");

                    }

                    if (delay.getWeeks() != 0) {

                        alert.append(delay.getWeeks()).append(" weeks ");

                    }

                    if (delay.getDays() != 0) {

                        alert.append(delay.getDays()).append(" days ");

                    }

                    if (delay.getHours() != 0) {

                        alert.append(delay.getHours()).append(" hours ");

                    }

                    if (delay.getMinutes() != 0) {

                        alert.append(delay.getMinutes()).append(" minutes");

                    }

                    alertPoint.setLabel(alert.toString());

                    capacity.setAlertPoint(alertPoint);

                } catch (Exception error) {

                    getLogger().error(error.getMessage(), error);

                    CapacityPoint alertPoint = new CapacityPoint(now);

                    alertPoint.setLabel("Alert point cannot be computed. It is problably infinite.");

                    capacity.setAlertPoint(alertPoint);

                }

            }

            capacity.setPoints(ImmutableList.copyOf(points.values()));

        } catch (Exception error) {

            getLogger().error(error.getMessage(), error);

            capacity.setPoints(null);

            capacity.setErrorMessage("Not enough points to compute a regression !!");

        }

    }



    private DateTime getStartDate(int periods, CapacityScope scope, DateTime now) {

        if (periods != 0) {

            switch (scope) {

            case MINUTE:

                return now.minusMinutes(periods);

            case HOUR:

                return now.minusHours(periods);

            case DAY:

                return now.minusDays(periods);

            case WEEK:

                return now.minusWeeks(periods);

            case MONTH:

                return now.minusMonths(periods);

            case QUARTER:

                return now.minusMonths(periods * 3);

            case YEAR:

                return now.minusYears(periods);

            default:

                break;

            }

        }

        return now;

    }



    private DateTime getEndDate(int periods, CapacityScope scope, DateTime now) {

        if (periods != 0) {

            switch (scope) {

            case MINUTE:

                return now.plusMinutes(periods);

            case HOUR:

                return now.plusHours(periods);

            case DAY:

                return now.plusDays(periods);

            case WEEK:

                return now.plusWeeks(periods);

            case MONTH:

                return now.plusMonths(periods);

            case QUARTER:

                return now.plusMonths(periods * 3);

            case YEAR:

                return now.plusYears(periods);

            default:

                break;

            }

        }

        return now;

    }



    private String toShortDate(CapacityScope scope, DateTime date) {

        switch (scope) {

        case MINUTE:

            return date.toString("HH:mm:ss");



        case HOUR:

            return date.toString("YYYY-MM-dd HH:mm:ss");



        case DAY:

            return date.toString("YYYY-MM-dd");



        case WEEK:

            return date.toString("YYYY-MM-dd");



        case MONTH:

            return date.toString("YYYY-MM");



        case QUARTER:

            return date.toString("YYYY-MM");



        case YEAR:

            return date.toString("YYYY");



        default:

            break;



        }

        return date.toString("YYYY-MM-dd HH:mm:ss");

    }



    @Override

    protected void doCreate() {

        // To change body of implemented methods use File | Settings | File

        // Templates.

    }



    @Override

    protected void doDestroy() {

        // To change body of implemented methods use File | Settings | File

        // Templates.

    }

}

package sgcib.tmon.worker.common.processor.metric;



/**

* Date: 28/10/13

* Time: 09:38

* This file is part of biopsy.

* biopsy is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* biopsy is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with biopsy.  If not, see <http://www.gnu.org/licenses/>.

*/



public enum CapacityScope

{

    MINUTE,

    HOUR,

    DAY,

    WEEK,

    MONTH,

    QUARTER,

    YEAR

}

package sgcib.tmon.worker.common.processor.storage;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormat;

import sgcib.tmon.worker.common.processor.ProcessorBase;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.configuration.StorageConfiguration;



import java.util.Set;

import java.util.regex.Matcher;

import java.util.regex.Pattern;



/**

* Date: 28/11/13

* Time: 20:54

* This file is part of biopsy.

* biopsy is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* biopsy is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with biopsy.  If not, see <http://www.gnu.org/licenses/>.

*/

public class StorageProcessor extends ProcessorBase<DateTime> {

    private final StorageManager storageManager;

    private final String dateRegex;

    private final String dateFormat;





    public StorageProcessor(String name, StorageManager storageManager) {

        super(name);

        getLogger().debug("Creating StorageProcessor !!");

        this.storageManager = storageManager;

        this.dateRegex = "(?<date>\\d{4}\\.\\d{2}\\.\\d{2})";

        this.dateFormat = "yyyy.MM.dd";

    }



    public DateTime getDate(String index) {

        Pattern pattern = Pattern.compile(dateRegex, Pattern.CASE_INSENSITIVE);

        Matcher matcher = pattern.matcher(index);

        if (matcher.find()) {

            return DateTime.parse(matcher.group("date"), DateTimeFormat.forPattern(dateFormat));

        }

        return null;

    }



    public void check() {

        process(new DateTime());

    }



    @Override

    protected void doProcess(DateTime timeStamp) {

        StorageConfiguration configuration = getConfiguration().getStorageConfiguration();

        if (configuration != null) {

            DateTime referenceDate = timeStamp.minusDays(configuration.getRetentionPeriod());

            Set<String> indices = storageManager.getIndexes();

            for (String index : indices) {

                DateTime date = getDate(index);

                if (date != null) {

                    if (date.isBefore(referenceDate)) {

                        storageManager.deleteIndex(index);

                    }

                }

            }

        }

    }



    @Override

    protected void doCreate() {

    }



    @Override

    protected void doDestroy() {

        //To change body of implemented methods use File | Settings | File Templates.

    }

}

package sgcib.tmon.worker.common.store.alert;



import java.io.IOException;

import java.util.List;

import java.util.Map;



import org.apache.commons.io.IOUtils;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



public class AlertStore extends GenericQueryableStore<Alert> implements IAlertStore {



    public static String mapping = "alertMapping";



    public AlertStore(String name, StorageManager storageManager) {

        super(name, storageManager, true, false, "alert", "alerts");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {

        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, AlertStore.mapping)) {

                    createAlertMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }

    }



    private boolean createAlertMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("alert").setSource(getAlertMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private String getAlertMapping() throws IOException {

       return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/alertMapping.json"));

    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public void create(Alert alert) throws WorkerException {

        save(alert);

    }



    @Override

    public void create(List<Alert> alerts) throws WorkerException {

        save(alerts);

    }



    @Override

    public void delete(Alert alert) throws WorkerException {

        super.delete(alert);

    }



    @Override

    protected Alert buidItem(Map data) {

        return new Alert(data);

    }



    @Override

    public List<Alert> read(String name, String brokenSla) throws WorkerException {

        Query query = new Query();

        query.addCriterion(Alert.name, name, QueryCriterionType.Is);

        query.addCriterion(Alert.brokenSla, brokenSla, QueryCriterionType.Is);

        return fetch(query);



    }



    @Override

    public List<Alert> read(IQuery query) throws WorkerException {

        return fetch(query);

    }



    @Override

    public Alert read(String id) throws WorkerException {

        return super.fetch(id);

    }

}

package sgcib.tmon.worker.common.store.alert;



import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.Map.Entry;

import java.util.concurrent.BlockingQueue;

import java.util.concurrent.ExecutionException;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

import java.util.concurrent.LinkedBlockingDeque;

import java.util.concurrent.Semaphore;

import java.util.concurrent.TimeUnit;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.stream.Collectors;



import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.index.IndexRequestBuilder;

import org.elasticsearch.client.Client;

import org.elasticsearch.common.collect.Lists;

import org.elasticsearch.index.VersionType;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.configuration.AsyncPollerConfiguration;



import com.google.common.base.Function;



/**

* @author ablaszcz120213

*

*/

public class AsyncAlertStore extends AlertStore {



    private Client client;

    private ExecutorService executor;

    private BlockingQueue<StoredQueryable> itemsToStore;

    private int nThreads;

    private AtomicBoolean isRunning;



    public AsyncAlertStore(String name, StorageManager storageManager) {

        super(name, storageManager);

        this.initExecutor(storageManager);

        this.itemsToStore = new LinkedBlockingDeque<StoredQueryable>();

        this.client = getStorageManager().getClient();

        this.isRunning = new AtomicBoolean(false);

    }



    /**

     * Create a thread pool that can schedule commands to run after a given

     * delay, or to execute periodically. The storage manager {@code manager}

     * should have the attribute {@code threads}, otherwise a default value is

     * used.

     *

     * @param manager

     *            The given storage manager.

     */

    @SuppressWarnings("static-access")

    private void initExecutor(StorageManager manager) {

        this.nThreads = manager.getConfiguration() != null ? manager.getConfiguration().getAsyncPollerConfiguration().getThreads() : //

                AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS;

        this.executor = Executors.newFixedThreadPool(this.nThreads);

    }



    @Override

    public void start() throws WorkerException {



        this.isRunning.set(true);

        super.start();



        getLogger().info("Wait for yellow cluster state");

        getStorageManager().getClient().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();



        // Prevent too many threads.

        Semaphore semaphore = new Semaphore(AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS);



        // Launch consumers.

        for (int i = 0; i < this.nThreads; i++) {

            executor.execute(() -> {

                do {

                    boolean permit = false;

                    try {

                        Thread.sleep(100);

                        permit = semaphore.tryAcquire(100, TimeUnit.MILLISECONDS);

                        if (permit) {

                            List<StoredQueryable> queryables = Lists.newArrayList();

                            int count = itemsToStore.drainTo(queryables, MAX_EVENTS);

                            if (count > 0) {

                                // Conflate items before storing them.

                                List<StoredQueryable> conflatedQueryables = Lists.newArrayList();

                                Map<String, List<StoredQueryable>> groupedQueryables = queryables //

                                        .parallelStream() //

                                        .collect(Collectors.groupingBy(StoredQueryable::getId));



                                for (Entry<String, List<StoredQueryable>> entry : groupedQueryables.entrySet()) {

                                    conflatedQueryables.add(Collections.max(entry.getValue(), getVersionComparator()));

                                }

                                storeMultiple(conflatedQueryables);

                            }

                        }

                    } catch (Exception error) {

                        getLogger().error("Fail to store queryables", error);

                    } finally {

                        if (permit) {

                            semaphore.release();

                        }

                    }



                } while (isRunning.get());

            });

        }

    }



    @Override

    public void stop() throws WorkerException {

        try {

            super.stop();

            this.isRunning.set(false);

            executor.shutdown();

            executor.awaitTermination(10, TimeUnit.SECONDS);

            getLogger().info("{} has stopped", getName());

        } catch (InterruptedException e) {

            getLogger().error("Error while stopping.", e);

        } finally {

            if (!executor.isTerminated()) {

                getLogger().warn("Cancel non-finished tasks for {}", getName());

            }

            executor.shutdownNow();

            getLogger().info("Shutdown finished");

       }

    }



    @Override

    public void create(Alert alert) throws WorkerException {

        itemsToStore.offer(new StoredQueryable(alert));

    }



    @Override

    public void create(List<Alert> alerts) throws WorkerException {

        alerts.stream().forEach(e -> create(e));

    }



    private void storeMultiple(List<StoredQueryable> events) {



        if (events.size() == 0) {

            return;

        }



        try {

            BulkRequestBuilder bulkRequest = this.client.prepareBulk();

            Function<Queryable, String> indexBuilder = this.getIndexBuilder();

            Function<Queryable, String> parentBuilder = getParentBuilder();



            for (StoredQueryable event : events) {

                try {

                    IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(event.getItem()), event.getItem().getType(), event.getItem().getId());

                    saveRequest.setVersion(event.getVersion()).setVersionType(VersionType.EXTERNAL);

                    if (parentBuilder != null) {

                        String parent = parentBuilder.apply(event.getItem());

                        if (parent != null) {

                            saveRequest.setParent(parent);

                        }

                    }

                    bulkRequest.add(saveRequest.setSource(event.getItemAsString()));

                } catch (Exception error) {

                    getLogger().error("Fail to prepare save request", error);

                }

            }



            BulkResponse response = bulkRequest.execute().get();

            if (response.hasFailures()) {

                String failureMessage = response.buildFailureMessage();

                getLogger().error("Error on store multiple, response failure {}", failureMessage);

            }



        } catch (InterruptedException | ExecutionException error) {

            getLogger().error("Error on store multiple", error);

        }

    }

}

package sgcib.tmon.worker.common.store.alert;





import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IQuery;



import java.util.List;





public interface IAlertStore extends IManageable {

    String getName();



    void create(Alert alert) throws WorkerException;



    void create(List<Alert> alerts) throws WorkerException;



    void delete(Alert alert) throws WorkerException;



    List<Alert> read(String name ,String brokenSla) throws WorkerException;



    List<Alert> read(IQuery query) throws WorkerException;



    Alert read(String id) throws WorkerException;



}

package sgcib.tmon.worker.common.store.alert;



import java.util.List;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.MemoryStore;



import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 16/05/2015.

*/

public class MemoryAlertStore extends ManageableBase implements IAlertStore {

    private final MemoryStore<Alert> alertStore;



    public MemoryAlertStore() {

        super("MemoryAlertStore");

        alertStore = new MemoryStore<Alert>();

    }



    @Override

    public void create(Alert alert) throws WorkerException {

        alertStore.save(alert.getId(), alert);

    }



    @Override

    public void create(List<Alert> alerts) throws WorkerException {

        for (Alert alert : alerts) {

            create(alert);

        }

    }



    @Override

    public void delete(Alert alert) throws WorkerException {

        alertStore.delete(alert.getId());

    }



    @Override

    public List<Alert> read(String name, String brokenSla) throws WorkerException {

        Query query = new Query();

        query.addCriterion(Alert.name, name, QueryCriterionType.Is);

        query.addCriterion(Alert.brokenSla, brokenSla, QueryCriterionType.Is);



        List<Alert> alerts = alertStore.readAll();

        ImmutableList.Builder<Alert> builder = new ImmutableList.Builder<>();

        for (Alert alert : alerts) {

            if (query.match(alert)) {

                builder.add(alert);

            }

        }

        return builder.build();

    }



    @Override

    public List<Alert> read(IQuery query) throws WorkerException {

        List<Alert> alerts = alertStore.readAll();

        ImmutableList.Builder<Alert> builder = new ImmutableList.Builder<>();

        for (Alert alert : alerts) {

            if (query.match(alert)) {

                builder.add(alert);

            }

        }

        return builder.build();

    }



    @Override

    public Alert read(String key) throws WorkerException {

        return alertStore.read(key);

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



}

package sgcib.tmon.worker.common.store.cache;



import com.fasterxml.jackson.databind.ObjectMapper;

import org.elasticsearch.action.get.GetResponse;

import org.elasticsearch.action.search.SearchResponse;

import org.elasticsearch.client.Client;

import org.elasticsearch.index.query.FilterBuilders;

import org.elasticsearch.index.query.QueryBuilders;

import org.elasticsearch.search.SearchHit;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.CachedEntry;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.utils.DateUtils;



import java.io.IOException;

import java.util.List;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.atomic.AtomicBoolean;



public class CacheStore extends CacheStoreBase {

                private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();

                private final static String SEPARATOR = "#";



                private final Client client;

                private final String index;

                private final ObjectMapper mapper;

                private final StorageManager storageManager;

                private final AtomicBoolean hasReloaded = new AtomicBoolean(false);

                private final ConcurrentHashMap<String, CachedEntry> cachedEntries;



                public CacheStore(String name, String index, StorageManager storageManager) {

                                super(name);



                                this.index = index;

                                this.storageManager = storageManager;

                                this.client = storageManager.getClient();

                                this.mapper = new ObjectMapper();



                                this.cachedEntries = new ConcurrentHashMap<String, CachedEntry>();

                }



                @Override

                public void start() throws WorkerException {

                                if (!this.storageManager.isIndexExist(this.index)) {

                                                this.storageManager.createIndex(this.index);

                                }

                }



                @Override

                public void stop() throws WorkerException {

                }



                @Override

                protected void doCreate(CachedEntry entry) throws WorkerException {

                                // reload all data

                                this.reloadCache();



                                try {

                                                // add the creation date

                                                entry.setCreationDate(dateTimeFormatter.print(DateUtils.getUTCDate()));



                                                // save the value locally

                                                this.cachedEntries.put(CacheStore.formatKey(entry), entry);



                                                // push the value to elasticsearch

                                                String strEntry = this.mapper.writeValueAsString(entry);



                                                this.client.prepareIndex(this.index, this.index, CacheStore.formatKey(entry))

                                                                .setSource(strEntry)

                                                                .setOperationThreaded(true)

                                                                .execute()

                                                                .actionGet();

                                }

                                catch (IOException exception) {

                                                throw new WorkerException("An error occurred while indexing the cache entry", exception);

                                }

                }



                @Override

                protected CachedEntry doRead(String name, String type) throws WorkerException {

                                // reload all data

                                this.reloadCache();



                                // read the value locally

                                CachedEntry entry = this.cachedEntries.get(CacheStore.formatKey(name, type));



                                if (entry != null) {

                                                return entry;

                                }



                                // get the value from elasticsearch

                                GetResponse response = client.prepareGet(this.index, this.index, CacheStore.formatKey(name, type))

                                                .execute()

                                                .actionGet();



                                try {

                                                if (response.getSourceAsBytes() != null) {

                                                                entry = this.mapper.readValue(response.getSourceAsBytes(), CachedEntry.class);

                                                                this.cachedEntries.put(CacheStore.formatKey(entry), entry);



                                                                return entry;

                                                }



                                                return null;

                                }

                                catch (IOException error) {

                                                throw new WorkerException("Event reading failed", error);

                                }

                }



                private void reloadCache() throws WorkerException {

                                if (hasReloaded.compareAndSet(false, true)) {

                                                try {

                                                                // load all saved values

                                                                SearchResponse response = this.client.prepareSearch(this.index)

                                                                                .setQuery(QueryBuilders.matchAllQuery())

                                                                                //.setFilter(FilterBuilders.typeFilter(this.index))

                    .setPostFilter(FilterBuilders.typeFilter(this.index))

                                                                                .execute()

                                                                                .actionGet();



                                                                int hitCount = (int) response.getHits().totalHits();



                                                                if (hitCount > 0) {

                                                                                for (SearchHit hit : response.getHits().hits()) {

                                                                                                CachedEntry entry = this.mapper.readValue(hit.getSourceAsString(), CachedEntry.class);



                                                                                                this.cachedEntries.put(CacheStore.formatKey(entry), entry);

                                                                                }

                                                                }

                                                } catch (IOException exception) {

                                                                throw new WorkerException("An error occurred while loading all the cache entries from elasticsearch", exception);

                                                } catch (Exception exception) {

                                                                throw new WorkerException("aaa", exception);

                                                }

                                }

                }



                private static String formatKey(CachedEntry entry) {

                                return CacheStore.formatKey(entry.getName(), entry.getType());

                }



                private static String formatKey(String name, String type) {

                                return String.format("%s%s%s", type, CacheStore.SEPARATOR, name);

                }

}

package sgcib.tmon.worker.common.store.cache;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.CachedEntry;



public abstract class CacheStoreBase extends ManageableBase implements ICacheStore {





                public CacheStoreBase(String name) {

                                super(name);

                }



                @Override

                public void create(CachedEntry entry) throws WorkerException {

                                this.getLogger().debug("Start creating a new cache entry");



                                try {

                                                if (entry != null) {

                                                                this.doCreate(entry);

                                                }

                                                else {

                                                                this.getLogger().warn("Trying to create a null cache entry");

                                                }

                                }

                                finally {

                                                this.getLogger().debug("Stop creating a new cache entry");

                                }

                }



                protected abstract void doCreate(CachedEntry entry) throws WorkerException;



                @Override

                public CachedEntry read(String name, String type) throws WorkerException {

                                this.getLogger().debug("Start reading a cache entry");



                                try {

                                                if (type != null && name != null) {

                                                                return this.doRead(name, type);

                                                }

                                                else {

                                                                this.getLogger().warn("Trying to reading a null cache entry");

                                                                return null;

                                                }

                                }

                                finally {

                                                this.getLogger().debug("Stop reading a cache entry");

                                }

                }



                protected abstract CachedEntry doRead(String name, String type) throws WorkerException;

}

package sgcib.tmon.worker.common.store.cache;



public interface ICacheReloader {

                public void reloadList(String list);

}

package sgcib.tmon.worker.common.store.cache;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.CachedEntry;



public interface ICacheStore {

                void create(CachedEntry entry) throws WorkerException;

                CachedEntry read(String name, String type) throws WorkerException;

}

package sgcib.tmon.worker.common.store.chain;



import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.Map.Entry;

import java.util.concurrent.BlockingQueue;

import java.util.concurrent.ExecutionException;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

import java.util.concurrent.LinkedBlockingDeque;

import java.util.concurrent.Semaphore;

import java.util.concurrent.TimeUnit;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.atomic.AtomicLong;

import java.util.stream.Collectors;



import org.apache.commons.lang3.StringUtils;

import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.index.IndexRequestBuilder;

import org.elasticsearch.client.Client;

import org.elasticsearch.common.collect.Lists;

import org.elasticsearch.index.VersionType;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.configuration.AsyncPollerConfiguration;



import com.google.common.base.Function;



/**

* @author slopes041604

* @author ablaszcz120213

*/

public class AsyncChainStore extends ChainStore {



    private static final String VERSION_CONFLICT = "VersionConflictEngineException";



    public static String emptyParentName = "00000000-0000-0000-0000-000000000000";



    public static String mapping = "chainMapping";



    private Client client;

    private ExecutorService executor;

    private BlockingQueue<StoredQueryable> items;

    private int nThreads;

    private AtomicBoolean isRunning;



    private AtomicLong atomicVersion = new AtomicLong(System.currentTimeMillis());



    public AsyncChainStore(String name, StorageManager storageManager) {

        super(name, storageManager);

        this.initExecutor(storageManager);

        this.items = new LinkedBlockingDeque<StoredQueryable>();

        this.client = getStorageManager().getClient();

        this.isRunning = new AtomicBoolean(false);

    }



    /**

     * Create a thread pool that can schedule commands to run after a given

     * delay, or to execute periodically. The storage manager {@code manager}

     * should have the attribute {@code threads}, otherwise a default value is

     * used.

     *

     * @param manager

     *            The given storage manager.

     */

    @SuppressWarnings("static-access")

    private void initExecutor(StorageManager manager) {

        this.nThreads = manager.getConfiguration() != null ? manager.getConfiguration().getAsyncPollerConfiguration().getThreads() : //

                AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS;

        this.executor = Executors.newFixedThreadPool(this.nThreads);

    }



    @Override

    public void start() throws WorkerException {



        this.isRunning.set(true);

        super.start();



        getLogger().info("Wait for yellow cluster state");

        getStorageManager().getClient().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();



        // Prevent too many threads.

        Semaphore semaphore = new Semaphore(AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS);



        // Launch consumers.

        for (int i = 0; i < this.nThreads; i++) {

            executor.execute(() -> {

                do {

                    boolean permit = false;

                    try {

                        Thread.sleep(100);

                        permit = semaphore.tryAcquire(100, TimeUnit.MILLISECONDS);

                        if (permit) {

                            List<StoredQueryable> queryables = Lists.newArrayList();

                            int count = items.drainTo(queryables, MAX_EVENTS);

                            if (count > 0) {

                                // Conflate items before storing them.

                                List<StoredQueryable> conflatedQueryables = Lists.newArrayList();

                                Map<String, List<StoredQueryable>> groupedQueryables = queryables //

                                        .parallelStream() //

                                        .collect(Collectors.groupingBy(StoredQueryable::getId));



                                for (Entry<String, List<StoredQueryable>> entry : groupedQueryables.entrySet()) {

                                    conflatedQueryables.add(Collections.max(entry.getValue(), getVersionComparator()));

                                }

                                storeMultiple(conflatedQueryables);

                            }

                        }

                    } catch (Exception error) {

                        getLogger().error("Fail to store queryables", error);

                    } finally {

                        if (permit) {

                            semaphore.release();

                        }

                    }



                } while (isRunning.get());

            });

        }

    }



    @Override

    public void stop() throws WorkerException {

        try {

            super.stop();

            this.isRunning.set(false);

            executor.shutdown();

            executor.awaitTermination(10, TimeUnit.SECONDS);

            getLogger().info("{} has stopped", getName());

        } catch (InterruptedException e) {

           getLogger().error("Error while stopping.", e);

        } finally {

            if (!executor.isTerminated()) {

                getLogger().warn("Cancel non-finished tasks for {}", getName());

            }

            executor.shutdownNow();

            getLogger().info("Shutdown finished");

        }

    }



    /**

     * Insert mode only used for all queryables instances

     * {@link StoredQueryable}.

     *

     * @param queryables

     *            List of given instances to persit.

     */

    private void storeMultiple(List<StoredQueryable> queryables) {



        if (queryables.size() == 0) {

            return;

        }



        try {

            BulkRequestBuilder bulkRequest = this.client.prepareBulk();

            Function<Queryable, String> indexBuilder = this.getIndexBuilder();

            Function<Queryable, String> parentBuilder = getParentBuilder();



            for (StoredQueryable item : queryables) {

                try {

                    IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(item.getItem()), item.getItem().getType(), item.getItem().getId());

                    saveRequest.setVersion(item.getVersion()).setVersionType(VersionType.EXTERNAL);

                    if (parentBuilder != null) {

                        String parent = parentBuilder.apply(item.getItem());

                        if (parent != null) {

                            saveRequest.setParent(parent);

                        }

                    }

                    bulkRequest.add(saveRequest.setSource(item.getItemAsString()));

                } catch (Exception error) {

                    getLogger().error("Fail to prepare save request", error);

                }

            }



            BulkResponse response = bulkRequest.execute().get();

            if (response.hasFailures()) {

                String failureMessage = response.buildFailureMessage();

                if (StringUtils.containsIgnoreCase(failureMessage, VERSION_CONFLICT)) {

                    getLogger().warn("Warning on store multiple, version conflict {}", failureMessage);

                } else {

                    getLogger().error("Error on store multiple, response failure {}", failureMessage);

                }

            }



        } catch (InterruptedException | ExecutionException error) {

            getLogger().error("Error on store multiple", error);

        }

    }



    public void insertChain(Chain chain) throws WorkerException {

        chain.setValue("link", getChainUrl(chain.getId()));

        chain.setVersion(atomicVersion.getAndIncrement());

        items.offer(new StoredQueryable(chain));

    }



    public void insertChainStep(ChainStep chainStep) throws WorkerException {

        chainStep.setVersion(atomicVersion.getAndIncrement());

        items.offer(new StoredQueryable(chainStep));

    }



    @Override

    public Chain createChain(Chain chain) throws WorkerException {

        chain.setValue("link", getChainUrl(chain.getId()));

        chain.setVersion(atomicVersion.getAndIncrement());

        Queryable chainAsMap = new Queryable(chain);

        chainAsMap.remove(Chain.steps);

        chainAsMap.remove(Chain.latencies);

        items.offer(new StoredQueryable(chainAsMap));

        return chain;

    }



    @Override

    public void updateChain(Chain chain) throws WorkerException {

        chain.setValue("link", getChainUrl(chain.getId()));

        chain.setVersion(atomicVersion.getAndIncrement());

        Queryable chainAsMap = new Queryable(chain);

        chainAsMap.remove(Chain.steps);

        chainAsMap.remove(Chain.latencies);

        items.offer(new StoredQueryable(chainAsMap));

    }



    @Override

    public ChainStep createStep(ChainStep chainStep) throws WorkerException {

        if (chainStep.containsKey(ChainStep.chain)) {

            chainStep.setValue("link", getChainUrl(chainStep.getChain()));

        }

        chainStep.setVersion(atomicVersion.getAndIncrement());

        items.offer(new StoredQueryable(chainStep));

        return chainStep;

    }



    public void createChainStep(ChainStep chainStep) throws WorkerException {

        if (chainStep.containsKey(ChainStep.chain)) {

            chainStep.setValue("link", getChainUrl(chainStep.getChain()));

        }

        chainStep.setVersion(atomicVersion.getAndIncrement());

        items.offer(new StoredQueryable(chainStep));

    }



    @Override

    public void updateStep(ChainStep chainStep) throws WorkerException {

        if (chainStep.containsKey(ChainStep.chain)) {

            chainStep.setValue("link", getChainUrl(chainStep.getChain()));

        }

        chainStep.setVersion(atomicVersion.getAndIncrement());

        items.offer(new StoredQueryable(chainStep));

    }



    @Override

    public void storeChains(List<Chain> chains) {

        for (Chain chain : chains) {

            chain.setValue("link", getChainUrl(chain.getId()));

            chain.setVersion(atomicVersion.getAndIncrement());

            items.offer(new StoredQueryable(chain));

        }

    }



    @Override

    public void storeSteps(List<ChainStep> chainSteps) {

        for (ChainStep chainStep : chainSteps) {

            if (chainStep.containsKey(ChainStep.chain)) {

                chainStep.setValue("link", getChainUrl(chainStep.getChain()));

            }

            chainStep.setVersion(atomicVersion.getAndIncrement());

            items.offer(new StoredQueryable(chainStep));

        }

    }

}

package sgcib.tmon.worker.common.store.chain;



import com.google.common.base.Function;

import com.google.common.collect.ImmutableList;

import org.apache.commons.io.IOUtils;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;

import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.chain.Latency;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import javax.annotation.Nullable;

import java.io.IOException;

import java.util.List;

import java.util.Map;



/**

* Created by Stephane on 15/02/2015.

*/



public class ChainStore extends GenericQueryableStore<Queryable> implements IChainStore {



    public static String mapping = "chainMapping";



    public ChainStore(String name, StorageManager storageManager) {

        super(name, storageManager, true, false, "chain", "chains");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {

        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, ChainStore.mapping)) {

                    createChainStepMapping(client, index);

                    createLatencyMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }

    }



    private boolean createChainStepMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("chainStep").setSource(getChainMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private boolean createLatencyMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("latency").setSource(getChainMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private String getChainMapping() throws IOException {

        return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/chainMapping.json"));

    }



    @Override

    public void stop() throws WorkerException {

        getLogger().info("Elasticsearch.ChainStore has stopped");

    }



    @Override

    public Chain readChain(String id) throws WorkerException {



        Chain chain = (Chain) fetch(id);

        List<Queryable> children = Queryable.fromList(fetchChildren(chain.getId(), "chain"));

        if (children != null && children.size() > 0) {

            for (Queryable child : children) {

                if (child instanceof ChainStep) {

                    chain.getSteps().add((ChainStep) child);

                }

                if (child instanceof Latency) {

                    chain.getLatencies().add((Latency) child);

                }

            }

        }

        return chain;

    }



    protected String getChainUrl(String chainId) {

        if ( ManageableBase.getConfiguration() != null ) {

            return ManageableBase.getConfiguration().getChainUrl(chainId);

        }

        return "";

    }





    @Override

    public Chain createChain(Chain chain) throws WorkerException {

        chain.setValue("link", getChainUrl(chain.getId()));

        Queryable chainAsMap = new Queryable(chain);

        chainAsMap.remove(Chain.steps);

        chainAsMap.remove(Chain.latencies);

        save(chainAsMap);

//            save(Queryable.toList(chain.getSteps()));

//            save(Queryable.toList(chain.getLatencies()));

        return chain;



    }



    @Override

    public void updateChain(Chain chain) throws WorkerException {

        chain.setValue("link", getChainUrl(chain.getId()));

        Queryable chainAsMap = new Queryable(chain);

        chainAsMap.remove(Chain.steps);

        chainAsMap.remove(Chain.latencies);

        update(chainAsMap);

//            save(Queryable.toList(chain.getSteps()));

//            save(Queryable.toList(chain.getLatencies()));



    }



    @Override

    public List<Chain> fetchChain(IQuery query) throws WorkerException {

        return Queryable.fromList(fetch(query));

    }



    @Override

    public ChainStep readStep(String id) throws WorkerException {

        return (ChainStep) fetch(id);

    }



    @Override

    public ChainStep createStep(ChainStep chainStep) throws WorkerException {

        if (chainStep.containsKey(ChainStep.chain) ) {

            chainStep.setValue("link", getChainUrl(chainStep.getChain()));

        }

        return (ChainStep) save(chainStep);

    }



    @Override

    public void updateStep(ChainStep chainStep) throws WorkerException {

        if (chainStep.containsKey(ChainStep.chain) ) {

            chainStep.setValue("link", getChainUrl(chainStep.getChain()));

        }

        update(chainStep);

    }



    @Override

    public List<ChainStep> fetchStep(IQuery query) throws WorkerException {

        return Queryable.fromList(fetch(query));

    }



    @Override

    protected Queryable buidItem(Map data) {

        String type = (String) data.get(Queryable.type);

        if (type != null) {

            if (type.equalsIgnoreCase("chain")) {

                return new Chain(data);

            }



            if (type.equalsIgnoreCase("chainStep")) {

                return new ChainStep(data);

            }



            if (type.equalsIgnoreCase("latency")) {

                return new Latency(data);

            }

        }

        return null;

    }



    @Override

    public void deleteChain(Chain chain) throws WorkerException {

        //Todo : to be implemented

    }



    @Override

    public void storeChains(List<Chain> chains) {

        ImmutableList.Builder<Queryable> items = new ImmutableList.Builder<>();

        items.addAll(chains);

        save(items.build());

    }



    @Override

    public void storeSteps(List<ChainStep> steps) {

        ImmutableList.Builder<Queryable> items = new ImmutableList.Builder<>();

        items.addAll(steps);

        save(items.build());

    }



    @Override

    public Function<Queryable, String> getParentBuilder() {

        return new ParentBuilder();

    }



    private class ParentBuilder implements Function<Queryable, String> {

        @Nullable

        @Override

        public String apply(@Nullable Queryable item) {

            String type = item.getType();

            if (type != null) {

                if (type == "chain") {

                    return null;

                }



                if (type == "chainStep") {

                    String chain = (String) item.get(ChainStep.chain);

                    if (chain == null) {

                        return emptyParentName;

                    }

                    return chain;

                }



                if (type == "latency") {

                    String chain = (String) item.get(Latency.chain);

                    if (chain == null) {

                        return emptyParentName;

                    }

                    return chain;

                }

            }

            return null;

        }

    }





}

package sgcib.tmon.worker.common.store.chain;



import java.io.Serializable;

import java.util.Collection;

import java.util.List;

import java.util.Map;

import java.util.UUID;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;



import com.google.common.collect.ImmutableList;

import com.hazelcast.core.IMap;

import com.hazelcast.query.Predicate;



/**

* Created by Stephane on 11/04/2015.

*/

public class ClusteredChainStore extends ManageableBase implements IChainStore {



    private class ClusterPredicate implements Serializable, Predicate<String, Object> {



        private final IQuery query;



        public ClusterPredicate(IQuery query) {

            this.query = query;

        }



        @Override

        public boolean apply(Map.Entry<String, Object> mapEntry) {

            if (mapEntry != null && mapEntry.getValue() != null) {

                Queryable item = (Queryable) mapEntry.getValue();

                return query.match(item);

            }

            return false;

        }



    }



    /**

     * <b>Hazelcast efficiency : IMap.put vs IMap.set :</b>

     * <p>

     * IMap.set puts an entry into this map. Similar to put operation except

     * that set doesn't return the old value which is more efficient.

     * </p>

     */

    private final IMap<String, Chain> chainMap;

    private final IMap<String, ChainStep> stepMap;



    public ClusteredChainStore(IClusterManager clusterManager) {

        super("Clustered.ChainStore");

        this.chainMap = clusterManager.getMap(getName() + "ChainMap");

        this.stepMap = clusterManager.getMap(getName()+"StepnMap");

    }





    @Override

    public Chain readChain(String id) {



        return chainMap.get(id);



    }



    @Override

    public Chain createChain(Chain chain) throws WorkerException {



        if (chain != null) {

            this.chainMap.set(chain.getId(), chain);

            for (ChainStep step : chain.getSteps()) {

                if (step.hasId()) {

                    updateStep(step);

                } else {

                    createStep(step);

                }

            }

            return chain;

        }

        return null;



    }



    @Override

    public void updateChain(Chain chain) throws WorkerException {



        if (chain != null) {

            this.chainMap.set(chain.getId(), chain);

            for (ChainStep step : chain.getSteps()) {

                updateStep(step);

            }

        }



    }



    @Override

    public List<Chain> fetchChain(IQuery query) throws WorkerException {



        try {

            Collection<Chain> chains = this.chainMap.values(new ClusterPredicate(query));

            return ImmutableList.copyOf(chains);

        } catch (Exception error) {

            getLogger().error("Cannot fetch chain ", error);

            throw new WorkerException("Cannot fetch chain ", error);

        }

    }



    @Override

    public ChainStep readStep(String id) throws WorkerException {



        return stepMap.get(id);



    }



    @Override

    public ChainStep createStep(ChainStep chainStep) throws WorkerException {



        if (chainStep != null) {

            if (chainStep.getId() == null) {

                chainStep.setId(UUID.randomUUID().toString());

            }

            this.stepMap.set(chainStep.getId(), chainStep);

            return chainStep;

        }

        return null;



    }



    @Override

    public void updateStep(ChainStep chainStep) throws WorkerException {



        if (chainStep != null) {

            if (chainStep.getId() == null) {

                chainStep.setId(UUID.randomUUID().toString());

            }

            this.stepMap.set(chainStep.getId(), chainStep);

        }



    }



    @Override

    public List<ChainStep> fetchStep(IQuery query) throws WorkerException {



        try {

            Collection<ChainStep> steps = this.stepMap.values(new ClusterPredicate(query));

            return ImmutableList.copyOf(steps);

        } catch (Exception error) {

            getLogger().error("Cannot fetch step ", error);

            throw new WorkerException("Cannot fetch step ", error);

        }



    }



    @Override

    public void deleteChain(Chain chain) throws WorkerException {

        if (chain != null) {

            if (this.chainMap.containsKey(chain.getId())) {

                this.chainMap.delete(chain.getId());

                for (ChainStep step : chain.getSteps()) {

                    if (this.stepMap.containsKey(step.getId())) {

                        this.stepMap.delete(step.getId());

                    }

                }

            }

        }

    }



    @Override

    public void storeChains(List<Chain> chains) {



    }



    @Override

    public void storeSteps(List<ChainStep> steps) {



    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }

}

package sgcib.tmon.worker.common.store.chain;



import java.util.List;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.store.IStore;



/**

* Created by Stephane on 07/12/2014.

*/

public interface IChainStore extends IStore {



    Chain readChain(String id) throws WorkerException;



    Chain createChain(Chain chain) throws WorkerException;



    void updateChain(Chain chain) throws WorkerException;



    List<Chain> fetchChain(IQuery query) throws WorkerException;



    ChainStep readStep(String id) throws WorkerException;



    ChainStep createStep(ChainStep chainStep) throws WorkerException;



    void updateStep(ChainStep chainStep) throws WorkerException;



    List<ChainStep> fetchStep(IQuery query) throws WorkerException;



    void deleteChain(Chain chain) throws WorkerException;



    void storeChains(List<Chain> chains);



    void storeSteps(List<ChainStep> steps);

}

package sgcib.tmon.worker.common.store.chain;



import java.util.List;



import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.MemoryStore;



import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 11/04/2015.

*/

public class MemoryChainStore extends ManageableBase implements IChainStore {

    protected final Logger logger;

    private final MemoryStore<Chain> chainStore;

    private final MemoryStore<ChainStep> stepStore;



    public MemoryChainStore() {

        super("Memory.IChainStore");

        logger = LoggerFactory.getLogger("Memory.IChainStore");

        this.chainStore = new MemoryStore<Chain>();

        this.stepStore = new MemoryStore<ChainStep>();

    }



    public MemoryChainStore(String name) {

        super(name);

        logger = LoggerFactory.getLogger(name);

        this.chainStore = new MemoryStore<Chain>();

        this.stepStore = new MemoryStore<ChainStep>();

    }





    @Override

    synchronized public Chain readChain(String id) {

        return this.chainStore.read(id);

    }



    @Override

    synchronized public Chain createChain(Chain chain) throws WorkerException {



        if (chain != null) {

            this.chainStore.save(chain.getId(), chain);

            for (ChainStep step : chain.getSteps()) {

                createStep(step);

            }

            return chain;

        }

        return null;



    }



    @Override

    synchronized public void updateChain(Chain chain) throws WorkerException {



        if (chain != null) {

            this.chainStore.update(chain.getId(), chain);

            for (ChainStep step : chain.getSteps()) {

                updateStep(step);

            }

        }



    }



    @Override

    synchronized public List<Chain> fetchChain(IQuery query) throws WorkerException {



        ImmutableList.Builder<Chain> builder = new ImmutableList.Builder<Chain>();

        List<Chain> chains = chainStore.readAll();

        if (chains != null && chains.size() > 0) {

            for (Chain chain : chains) {

                if (query.match(chain)) {

                    builder.add(chain);

                }

            }

        }

        return builder.build();



    }



    @Override

    synchronized public ChainStep readStep(String id) throws WorkerException {



        return this.stepStore.read(id);



    }



    @Override

    synchronized public ChainStep createStep(ChainStep chainStep) throws WorkerException {



        if (chainStep != null) {

            this.stepStore.save(chainStep.getId(), chainStep);

            return chainStep;

        }

        return null;



    }



    @Override

    synchronized public void deleteChain(Chain chain) throws WorkerException {



        if (chain != null) {

            this.chainStore.delete(chain.getId());

            for (ChainStep step : chain.getSteps()) {

                this.stepStore.delete(step.getId());

            }

        }



    }



    @Override

    public void storeChains(List<Chain> chains) {

        for (Chain chain : chains) {

            updateChain(chain);

        }

    }



    @Override

    public void storeSteps(List<ChainStep> steps) {

        for (ChainStep step : steps) {

            updateStep(step);

        }

    }



    @Override

    synchronized public void updateStep(ChainStep chainStep) throws WorkerException {



        if (chainStep != null) {

            this.stepStore.update(chainStep.getId(), chainStep);

        }



    }



    @Override

    synchronized public List<ChainStep> fetchStep(IQuery query) throws WorkerException {

        ImmutableList.Builder<ChainStep> builder = new ImmutableList.Builder<ChainStep>();

        List<ChainStep> steps = stepStore.readAll();

        if (steps != null && steps.size() > 0) {

            for (ChainStep step : steps) {

                if (query.match(step)) {

                    builder.add(step);

                }

            }

        }

        return builder.build();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    /**

     * Return the chain store's size.

     */

    public synchronized int getChainStoreSize() {

        return this.chainStore.size();

    }



    /**

     * Return the step store's size.

     */

    public synchronized int getStepStoreSize() {

        return this.stepStore.size();

    }

}

package sgcib.tmon.worker.common.store.chain;



import java.util.Collection;

import java.util.List;



import org.elasticsearch.common.collect.ImmutableList;

import org.kie.api.runtime.ObjectFilter;

import org.kie.api.runtime.rule.EntryPoint;

import org.kie.api.runtime.rule.FactHandle;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;



/**

* Created by slopes041604 on 09/07/2015.

*/

public class WorkingMemoryChainStore extends ManageableBase implements IChainStore {



    private class WorkingMemoryQueryFilter implements ObjectFilter {



        private final IQuery query;



        private WorkingMemoryQueryFilter(IQuery query) {

            this.query = query;

        }



        @Override

        public boolean accept(Object object) {

            if (query != null) {

                if (object instanceof Queryable) {

                    Queryable item = (Queryable) object;

                    if (item != null) {

                        return query.match(item);

                    }

                }

            }

            return false;

        }

    }



    private final EntryPoint workingMemory;



    public WorkingMemoryChainStore(String name, EntryPoint workingMemory) {

        super(name);

        this.workingMemory = workingMemory;

    }



    @Override

    public Chain readChain(String id) throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(Queryable.key, id, QueryCriterionType.Is);

        query.addCriterion(Queryable.type, "chain", QueryCriterionType.Is);

        Collection<? extends Object> items = this.workingMemory.getObjects(new WorkingMemoryQueryFilter(query));

        if (items != null && items.size() == 1) {

            return (Chain) ImmutableList.copyOf(items).get(0);

        }

        if (items != null && items.size() > 1) {

            throw new WorkerException(String.format("Found more than one chain (%d) with the same id (%s)", items.size(), id));

        }

        return null;

    }



    @Override

    public Chain createChain(Chain chain) throws WorkerException {

        FactHandle handle = workingMemory.getFactHandle(chain);

        if (handle == null) {

            workingMemory.insert(chain);

        } else {

            updateChain(chain);

        }

        return chain;

    }



    @Override

    public void updateChain(Chain chain) throws WorkerException {

        FactHandle handle = workingMemory.getFactHandle(chain);

        if (handle != null) {

            workingMemory.update(handle, chain);

        } else {

            createChain(chain);

        }

    }



    @Override

    public List<Chain> fetchChain(IQuery query) throws WorkerException {

        ImmutableList.Builder<Chain> builder = new ImmutableList.Builder<Chain>();

        Collection<? extends Object> items = this.workingMemory.getObjects(new WorkingMemoryQueryFilter(query));

        if (query != null) {

            query.addCriterion(Queryable.type, "chain", QueryCriterionType.Is);

            if (items != null) {



                for (Object item : items) {

                    builder.add((Chain) item);

                }

            }

        }

        return builder.build();

    }



    @Override

    public ChainStep readStep(String id) throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(Queryable.key, id, QueryCriterionType.Is);

        query.addCriterion(Queryable.type, "chainStep", QueryCriterionType.Is);

        Collection<? extends Object> items = this.workingMemory.getObjects(new WorkingMemoryQueryFilter(query));

        if (items != null && items.size() == 1) {

            return (ChainStep) items.toArray()[0];

        }

        if (items != null && items.size() > 1) {

            throw new WorkerException(String.format("Found more than one chain step (%d) with the same id (%s)", items.size(), id));

        }

        return null;

    }



    @Override

    public ChainStep createStep(ChainStep chainStep) throws WorkerException {

        FactHandle handle = workingMemory.getFactHandle(chainStep);

        if (handle == null) {

            workingMemory.insert(chainStep);

        } else {

            workingMemory.update(handle, chainStep);

        }

        return chainStep;

    }



    @Override

    public void updateStep(ChainStep chainStep) throws WorkerException {

        // FactHandle handle = (FactHandle)

        // chainStep.getValue("factHandle");

        FactHandle handle = workingMemory.getFactHandle(chainStep);

        if (handle != null) {

            workingMemory.update(handle, chainStep);

        } else {

            workingMemory.insert(chainStep);

        }

    }



    @Override

    public List<ChainStep> fetchStep(IQuery query) throws WorkerException {

        ImmutableList.Builder<ChainStep> builder = new ImmutableList.Builder<ChainStep>();

        Collection<? extends Object> items = this.workingMemory.getObjects(new WorkingMemoryQueryFilter(query));

        if (query != null) {

            query.addCriterion(Queryable.type, "chainStep", QueryCriterionType.Is);

            if (items != null) {



                for (Object item : items) {

                    builder.add((ChainStep) item);

                }

            }

        }

        return builder.build();

    }



    @Override

    public void deleteChain(Chain chain) throws WorkerException {

        FactHandle handle = workingMemory.getFactHandle(chain);

        if (null != handle) {

            workingMemory.delete(handle);

        }

    }



    @Override

    public void storeChains(List<Chain> chains) {



    }



    @Override

    public void storeSteps(List<ChainStep> steps) {



    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



}

package sgcib.tmon.worker.common.store.configuration;



import sgcib.tmon.worker.configuration.SettingsConfiguration;



public class ApplicationSettings {



    private static SettingsConfiguration configuration;



    // Private constructor

    private ApplicationSettings() {

    }



    // Holder

    private static class ApplicationSettingsHolder {

        // Unique instance

        private final static ApplicationSettings instance = new ApplicationSettings();

    }



    // Unique entry point to access to the singleton

    private static ApplicationSettings getInstance() {

        return ApplicationSettingsHolder.instance;

    }



    public static void setConfiguration(SettingsConfiguration configuration) {

        if (configuration == null) {

            throw new IllegalArgumentException("Configuration cannot be null");

        }

         getInstance().configuration = configuration;

    }



    public static SettingsConfiguration configuration() {

        return getInstance().configuration;

    }



    public static Object get(Object key) {

        if(getInstance() != null && getInstance().configuration != null)

         return getInstance().configuration.get(key);

        else return null;

    }

}

package sgcib.tmon.worker.common.store.configuration;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.IStore;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import java.util.List;



/**

* Created by Stephane on 04/01/2015.

*/

public interface ITaskConfigurationStore extends IStore {

    List<TaskConfiguration> readAll(TaskType type) throws WorkerException;



    TaskConfiguration readConfiguration(String name) throws WorkerException;



    void saveConfiguration(TaskConfiguration configuration) throws WorkerException;



    void updateConfiguration(TaskConfiguration configuration) throws WorkerException;



    void deleteConfiguration(String name) throws WorkerException;

}

package sgcib.tmon.worker.common.store.configuration;



import com.google.common.collect.ImmutableList;

import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.MemoryStore;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import java.util.List;



/**

* Created by Stephane on 05/01/2015.

*/



public class MemoryTaskConfigurationStore extends ManageableBase implements ITaskConfigurationStore {

    private final MemoryStore<TaskConfiguration> configurationStore;



    public MemoryTaskConfigurationStore() {

        super("Memory.ConfigurationStore");

        this.configurationStore = new MemoryStore<TaskConfiguration>();

    }



    @Override

    public void start() {



    }



    @Override

    public void stop() {



    }



    @Override

    public List<TaskConfiguration> readAll(TaskType type) throws WorkerException {

        ImmutableList.Builder<TaskConfiguration> builder = new ImmutableList.Builder<TaskConfiguration>();

        List<TaskConfiguration> configurations = configurationStore.readAll();

        if (configurations != null && configurations.size() > 0) {

            for (TaskConfiguration configuration : configurations) {

                if (configuration != null && configuration.getTaskType() == type) {

                    builder.add(configuration);

                }

            }

        }

        return builder.build();

    }



    @Override

    public TaskConfiguration readConfiguration(String name) throws WorkerException {

        return configurationStore.read(name);

    }



    @Override

    public void saveConfiguration(TaskConfiguration configuration) throws WorkerException {

        configurationStore.save(configuration.getName(), configuration);

    }



    @Override

    public void updateConfiguration(TaskConfiguration configuration) throws WorkerException {

        configurationStore.update(configuration.getName(), configuration);

    }



    @Override

    public void deleteConfiguration(String name) throws WorkerException {

        configurationStore.delete(name);

    }

}

package sgcib.tmon.worker.common.store.configuration;



import org.apache.commons.io.IOUtils;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;

import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import java.io.IOException;

import java.util.List;

import java.util.Map;



/**

* Created by Stephane on 08/01/2015.

*/



@Extension

public class TaskConfigurationStore extends GenericQueryableStore<TaskConfiguration> implements ITaskConfigurationStore {

    public static String name = "TaskConfigurationStore";



    public static String mapping = "taskConfigurationMapping";



    public TaskConfigurationStore(StorageManager storageManager) {

        super(name, storageManager, false, false, "configuration", "configurations");

    }



    @Override

    public List<TaskConfiguration> readAll(TaskType type) throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(TaskConfiguration.taskType, type.toString(), QueryCriterionType.Is);

        return fetch(query);

    }



    @Override

    public TaskConfiguration readConfiguration(String name) throws WorkerException {

        return fetch(name);

    }



    @Override

    public void saveConfiguration(TaskConfiguration configuration) throws WorkerException {

        save(configuration);

    }



    @Override

    public void updateConfiguration(TaskConfiguration configuration) throws WorkerException {

        update(configuration);

    }



    @Override

    public void deleteConfiguration(String name) throws WorkerException {

        TaskConfiguration item = new TaskConfiguration(name, null);

        delete(item);

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {



        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, TaskConfigurationStore.mapping)) {

                    createTaskConfigurationMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }



    }



    private boolean createTaskConfigurationMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("taskConfiguration").setSource(getTaskConfigurationMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private String getTaskConfigurationMapping() throws IOException {

        return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/taskConfigurationMapping.json"));

    }



    @Override

    protected TaskConfiguration buidItem(Map data) {

        TaskConfiguration item = new TaskConfiguration(data);

        return item;

    }



}

package sgcib.tmon.worker.common.store.cutoff;





import com.fasterxml.jackson.databind.ObjectMapper;

import org.elasticsearch.action.bulk.BulkItemResponse;

import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.delete.DeleteResponse;

import org.elasticsearch.action.get.GetResponse;

import org.elasticsearch.action.index.IndexResponse;

import org.elasticsearch.action.search.SearchResponse;

import org.elasticsearch.client.Client;

import org.elasticsearch.index.query.FilterBuilders;

import org.elasticsearch.index.query.QueryBuilders;

import org.elasticsearch.search.SearchHit;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.BasicCutoff;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.StorageManager;



import java.io.IOException;

import java.util.ArrayList;

import java.util.List;



/**

* Created by ekolonis120213 on 25/03/14.

*/





public class CutoffStore extends CutoffStoreBase {

    private final Client client;

    private final String index;

    private final String type;

    private final ObjectMapper mapper;

    private final StorageManager storageManager;



    public CutoffStore(String name, StorageManager storageManager) {

        super(name);

        this.client = storageManager.getClient();

        this.index = "configuration";

        this.type = "cutoff";

        this.mapper = new ObjectMapper();

        this.storageManager = storageManager;

    }



    public void start() throws WorkerException {

        if (!storageManager.isIndexExist(this.index)) {

            storageManager.createIndex(this.index);

        }



        /*DateTime dateTime = new DateTime();

        DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss");



        // create a sample cutoff

        BasicCutoff cutoff = new BasicCutoff("countCutoff");

        cutoff.setEventName("cpu");

        cutoff.setEventField("none");

        cutoff.setEventType("serverData");

        cutoff.setMetricField("COUNT");

        cutoff.setOverUnder("OVER");

        cutoff.setQueryFilter("");



        cutoff.setEventTimestamp(Event.timestamp);

        String startDate = formatter.print(dateTime.minusMinutes(1));

        cutoff.setStartingDate(startDate);

        String targetDate;

        targetDate = formatter.print(dateTime.plusHours(1));

        cutoff.setTargetDate1(targetDate);



        cutoff.setTargetDate2(15);

        cutoff.setTargetDate3(30);

        cutoff.setTargetDate4(45);

        cutoff.setTargetDate5(60);

        cutoff.setTargetValue1(250);

        cutoff.setTargetValue2(180);

        cutoff.setTargetValue3(120);

        cutoff.setTargetValue4(80);

        cutoff.setTargetValue5(40);



        create(cutoff);*/





    }



    public void stop() throws WorkerException {



    }



    @Override

    protected boolean doCreate(BasicCutoff cutoff) {

        try {

            String cutoffAsString = mapper.writeValueAsString(cutoff);

            final IndexResponse indexResponse = client.prepareIndex(this.index, this.type, cutoff.getName())

                    .setSource(cutoffAsString).setOperationThreaded(true).execute().actionGet();



        } catch (IOException error) {

            throw new WorkerException("Cutoff creation failed", error);

        }

        return true;

    }



    @Override

    protected boolean doCreate(BasicCutoff[] cutoffs) {

        try {

            BulkRequestBuilder bulkRequest = client.prepareBulk();

            for (int cutoffIndex = 0; cutoffIndex < cutoffs.length; cutoffIndex++) {

                BasicCutoff cutoff = cutoffs[cutoffIndex];

                if (cutoff != null) {

                    String cutoffAsString = mapper.writeValueAsString(cutoff);

                    bulkRequest.add(client.prepareIndex(this.index, this.type).setSource(cutoffAsString));

                }

            }

            BulkResponse bulkResponse = bulkRequest.execute().actionGet();

            if (bulkResponse.hasFailures()) {

                for (BulkItemResponse response : bulkResponse.getItems()) {

                    getLogger().warn(response.getFailureMessage());

                }

            }

        } catch (IOException error) {

            throw new WorkerException("Cutoffs creation failed", error);



        }

        return true;

    }



    @Override

    protected boolean doDelete(BasicCutoff cutoff) {

        this.client.admin().indices().prepareRefresh().execute().actionGet();

        final DeleteResponse response = client.prepareDelete(this.index, this.type, cutoff.getName()).execute().actionGet();

        return true;

    }



    @Override

    protected BasicCutoff doRead(String name) {

        final GetResponse response = client.prepareGet(this.index, this.type, name)

                .execute()

                .actionGet();

        try {

            if (response.getSourceAsBytes() != null) {

                return mapper.readValue(response.getSourceAsBytes(), BasicCutoff.class);



            }



        } catch (IOException error) {

            throw new WorkerException("Cutoff reading failed", error);

        }

        return null;

    }



    @Override

    protected void doUpdate(BasicCutoff cutoff) {



        final IndexResponse indexResponse = client.prepareIndex(this.index, this.type, cutoff.getName()).setSource(cutoff).setOperationThreaded(true).execute().actionGet();



        //TODo : check response code



    }



    @Override

    protected List<BasicCutoff> doGetAllCutoffs() {

        SearchResponse response = this.client.prepareSearch(this.index)

                .setQuery(QueryBuilders.matchAllQuery())

                .setPostFilter(FilterBuilders.typeFilter(this.type))

                .execute()

                .actionGet();



        int hitCount = (int) response.getHits().totalHits();

        List<BasicCutoff> cutoffs = new ArrayList<BasicCutoff>();



        if (hitCount > 0) {

            for (SearchHit hit : response.getHits().hits()) {

                cutoffs.add(doRead(hit.getId()));

            }

        }

        return cutoffs;

    }

}

package sgcib.tmon.worker.common.store.cutoff;



/**

* Created by ekolonis120213 on 25/03/14.

*/





import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.BasicCutoff;



import java.util.List;





public abstract class CutoffStoreBase extends ManageableBase implements ICutoffStore {



    public CutoffStoreBase(String name) {

        super(name);



    }



    @Override

    public boolean create(BasicCutoff cutoff) throws WorkerException {

        getLogger().debug("Start creating cutoff");

        try {

            if (cutoff != null) {

                return doCreate(cutoff);

            } else {

                getLogger().warn("Trying to start a null cutoff");

                return false;

            }

        } finally {

            getLogger().debug("Stop creating cutoff");

        }

    }



    protected abstract boolean doCreate(BasicCutoff cutoff);



    @Override

    public boolean create(BasicCutoff[] cutoffs) throws WorkerException {

        getLogger().debug("Start creating cutoffs");

        try {

            if (cutoffs != null && cutoffs.length > 0) {

                return doCreate(cutoffs);

            } else {

                getLogger().warn("Trying to start a null or empty cutoff list");

                return false;

            }



        } finally {

            getLogger().debug("Stop creating cutoffs");

        }

    }



    protected abstract boolean doCreate(BasicCutoff[] cutoffs);





    @Override

    public boolean update(BasicCutoff cutoff)

            throws WorkerException {

        getLogger().debug("Start updating cutoff");

        try {

            if ((cutoff != null)&&(cutoff.getName() != null)) {

                doUpdate(cutoff);

                return true;

            } else {

                getLogger().warn("Cannot update null cutoff or cutoff with a null name");

                return false;

            }

        } finally {

            getLogger().debug("Stop updating cutoff");

        }

    }



    protected abstract void doUpdate(BasicCutoff cutoff);





    @Override

    public boolean delete(BasicCutoff cutoff)

            throws WorkerException {

        getLogger().debug("Start deleting cutoff");

        try {

            if (cutoff != null) {

                return doDelete(cutoff);

            } else {

                getLogger().warn("Cannot delete cutoff with a null Id");

                return false;

            }

        } finally {

            getLogger().debug("Stop deleting cutoff");

        }

    }



    protected abstract boolean doDelete(BasicCutoff cutoff);



    @Override

    public BasicCutoff read(String name) throws WorkerException {

        getLogger().debug("Start reading cutoff");

        try {

            if (name != null) {

                return doRead(name);

            } else {

                getLogger().warn("Cannot read cutoff with a null Id");

                return null;

           }

        } finally {

            getLogger().debug("Stop reading cutoff");

        }

    }



    protected abstract BasicCutoff doRead(String name);





    @Override

    public List<BasicCutoff> getAllCutoffs() throws WorkerException {

        getLogger().debug("Start reading all cutoffs");

        try {

            return doGetAllCutoffs();

        } finally {

            getLogger().debug("Stop reading all cutoffs");

        }

    }



    protected abstract List<BasicCutoff> doGetAllCutoffs();

}

package sgcib.tmon.worker.common.store.cutoff;



/**

* Created by ekolonis120213 on 25/03/14.

*/



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.BasicCutoff;



import java.util.List;



public interface ICutoffStore extends IManageable {

    String getName();



    boolean create(BasicCutoff cutoff) throws WorkerException;



    boolean create(BasicCutoff[] cutoffs) throws WorkerException;



    boolean update(BasicCutoff cutoff) throws WorkerException;



    boolean delete(BasicCutoff cutoff)

            throws WorkerException;



    BasicCutoff read(String name) throws WorkerException;



    List<BasicCutoff> getAllCutoffs() throws WorkerException;

}

package sgcib.tmon.worker.common.store.error;



import org.apache.commons.io.IOUtils;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;

import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;

import sgcib.tmon.worker.common.task.TaskAction;

import sgcib.tmon.worker.common.task.TaskError;



import java.io.IOException;

import java.util.List;

import java.util.Map;



/**

* Created by Stephane on 14/03/2015.

*/

@Extension

public class ErrorStore extends GenericQueryableStore<TaskError> implements ITaskErrorStore {





    public static String mapping = "errorMapping";



    public ErrorStore(String name, StorageManager storageManager) {

        super(name, storageManager, true, false, "error","errors");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {

        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, ErrorStore.mapping)) {

                    createMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }

    }



    private boolean createMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("alert").setSource(getMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private String getMapping() throws IOException {

        return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/errorMapping.json"));

    }



    @Override

    protected TaskError buidItem(Map data) {

        return new TaskError(data);

    }



    @Override

    public void registerError(TaskError error) throws WorkerException {

        save(error);

    }



    @Override

    public List<TaskError> getErrors() throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(TaskError.type,"taskError",QueryCriterionType.Is );

        return fetch(query);

    }



    @Override

    public void remove(String id) throws WorkerException {

        TaskError error = new TaskError("", TaskAction.None,"");

        error.setId(id);

        delete(error);

    }



}

package sgcib.tmon.worker.common.store.error;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.IStore;

import sgcib.tmon.worker.common.task.TaskError;



import java.util.List;



/**

* Created by Stephane on 14/03/2015.

*/

public interface ITaskErrorStore extends IStore {

    void registerError(TaskError error) throws WorkerException;

    List<TaskError> getErrors() throws WorkerException;

    void remove(String id) throws WorkerException;

}

package sgcib.tmon.worker.common.store.error;



import java.util.List;



import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.store.MemoryStore;

import sgcib.tmon.worker.common.task.TaskError;



/**

* Created by Stephane on 14/03/2015.

*/

public class MemoryTaskErrorStore extends ManageableBase implements ITaskErrorStore {



    private final MemoryStore<TaskError> errorStore;



    public MemoryTaskErrorStore() {

        super("Memory.TaskErrorStore");

        errorStore = new MemoryStore<TaskError>();

    }



    @Override

    public void registerError(TaskError error) throws WorkerException {

        errorStore.save(error.getId(), error);

    }



    @Override

    public List<TaskError> getErrors() throws WorkerException {

        return errorStore.readAll();

    }



    @Override

    public void remove(String id) throws WorkerException {

        errorStore.delete(id.toString());

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



}

package sgcib.tmon.worker.common.store.event;



import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.Map.Entry;

import java.util.concurrent.BlockingQueue;

import java.util.concurrent.ExecutionException;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

import java.util.concurrent.LinkedBlockingDeque;

import java.util.concurrent.Semaphore;

import java.util.concurrent.TimeUnit;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.stream.Collectors;



import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.index.IndexRequestBuilder;

import org.elasticsearch.client.Client;

import org.elasticsearch.common.collect.Lists;

import org.elasticsearch.index.VersionType;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.configuration.AsyncPollerConfiguration;



import com.google.common.base.Function;



/**

* @author slopes041604

* @author ablaszcz120213

*/

public class AsyncEventStore extends EventStore {



    private Client client;

    private ExecutorService executor;

    private BlockingQueue<StoredQueryable> itemsToStore;

    private int nThreads;

    private AtomicBoolean isRunning;



    public AsyncEventStore(String name, StorageManager storageManager) {

        super(name, storageManager);

        this.initExecutor(storageManager);

        this.itemsToStore = new LinkedBlockingDeque<StoredQueryable>();

        this.client = getStorageManager().getClient();

        this.isRunning = new AtomicBoolean(false);

    }



    /**

     * Create a thread pool that can schedule commands to run after a given

     * delay, or to execute periodically. The storage manager {@code manager}

     * should have the attribute {@code threads}, otherwise a default value is

     * used.

     *

     * @param manager

     *            The given storage manager.

     */

    @SuppressWarnings("static-access")

    private void initExecutor(StorageManager manager) {

        this.nThreads = manager.getConfiguration() != null ? manager.getConfiguration().getAsyncPollerConfiguration().getThreads() : //

                AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS;

        this.executor = Executors.newFixedThreadPool(this.nThreads);

    }



    @Override

    public void start() throws WorkerException {



        this.isRunning.set(true);

        super.start();



        getLogger().info("Wait for yellow cluster state");

        getStorageManager().getClient().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();



        // Prevent too many threads.

        Semaphore semaphore = new Semaphore(AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS);



        // Launch consumers.

        for (int i = 0; i < this.nThreads; i++) {

            executor.execute(() -> {

                do {

                    boolean permit = false;

                    try {

                        Thread.sleep(100);

                        permit = semaphore.tryAcquire(100, TimeUnit.MILLISECONDS);

                        if (permit) {

                            List<StoredQueryable> queryables = Lists.newArrayList();

                            int count = itemsToStore.drainTo(queryables, MAX_EVENTS);

                            if (count > 0) {

                                // Conflate items before storing them.

                                List<StoredQueryable> conflatedQueryables = Lists.newArrayList();

                                Map<String, List<StoredQueryable>> groupedQueryables = queryables //

                                        .parallelStream() //

                                        .collect(Collectors.groupingBy(StoredQueryable::getId));



                                for (Entry<String, List<StoredQueryable>> entry : groupedQueryables.entrySet()) {

                                    conflatedQueryables.add(Collections.max(entry.getValue(), getVersionComparator()));

                                }

                                storeMultiple(conflatedQueryables);

                            }

                        }

                    } catch (Exception error) {

                        getLogger().error("Fail to store queryables", error);

                    } finally {

                        if (permit) {

                            semaphore.release();

                        }

                    }



                } while (isRunning.get());

            });

        }

    }



    @Override

    public void stop() throws WorkerException {

        try {

            super.stop();

            this.isRunning.set(false);

            executor.shutdown();

            executor.awaitTermination(10, TimeUnit.SECONDS);

            getLogger().info("{} has stopped", getName());

        } catch (InterruptedException e) {

            getLogger().error("Error while stopping.", e);

       } finally {

            if (!executor.isTerminated()) {

                getLogger().warn("Cancel non-finished tasks for {}", getName());

            }

            executor.shutdownNow();

            getLogger().info("Shutdown finished");

        }

   }



    @Override

    public List<Event> save(final List<Event> events) throws WorkerException {

        events.stream().forEach(e -> save(e));

        return events;

    }



    @Override

    public Event save(final Event event) throws WorkerException {

        itemsToStore.offer(new StoredQueryable(event));

        return event;

    }



    @Override

    public Event update(Event event) throws WorkerException {

        save(event);

        return event;

    }



    private void storeMultiple(List<StoredQueryable> events) {



        if (events.size() == 0) {

            return;

        }



        try {

            BulkRequestBuilder bulkRequest = this.client.prepareBulk();

            Function<Queryable, String> indexBuilder = this.getIndexBuilder();

            Function<Queryable, String> parentBuilder = getParentBuilder();



            for (StoredQueryable event : events) {

                try {

                    IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(event.getItem()), event.getItem().getType(), event.getItem().getId());

                    saveRequest.setVersion(event.getVersion()).setVersionType(VersionType.EXTERNAL);

                    if (parentBuilder != null) {

                        String parent = parentBuilder.apply(event.getItem());

                        if (parent != null) {

                            saveRequest.setParent(parent);

                        }

                    }

                    bulkRequest.add(saveRequest.setSource(event.getItemAsString()));

                } catch (Exception error) {

                    getLogger().error("Fail to prepare save request", error);

                }

            }



            BulkResponse response = bulkRequest.execute().get();

            if (response.hasFailures()) {

                String failureMessage = response.buildFailureMessage();

                getLogger().error("Error on store multiple, response failure {}", failureMessage);

            }



        } catch (InterruptedException | ExecutionException error) {

            getLogger().error("Error on store multiple", error);

        }

    }

}

package sgcib.tmon.worker.common.store.event;





import org.apache.commons.io.IOUtils;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;

import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import java.io.IOException;

import java.util.List;

import java.util.Map;



public class EventStore extends GenericQueryableStore<Event> implements IEventStore {



    public static String mapping = "eventMapping";



    protected EventStore(String name, StorageManager storageManager) {

        super(name, storageManager, true, false, "logstash", "events");

    }



   public EventStore(StorageManager storageManager) {

        super("EventStore", storageManager, true, false, "logstash", "events");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {

        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, EventStore.mapping)) {

                    createMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }

    }



    private boolean createMapping(Client client, String index) throws IOException {

        PutMappingResponse response = client.admin().indices().preparePutMapping(index).setType("_default_").setSource(getMapping()).execute().actionGet();

        return response.isAcknowledged();

    }



    private String getMapping() throws IOException {

        return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/eventMapping.json"));

    }





    @Override

    public List<Event> read(IQuery query) throws WorkerException {

        return super.fetch(query);

    }



    @Override

    public Event read(String id) throws WorkerException {

        return super.fetch(id);

    }



    @Override

    public Metric readMetric(String metricName, String eventType, String eventName, String eventField,  IQuery query ) {

        query.addCriterion(Event.type, eventType, QueryCriterionType.Is);

        query.addCriterion(Event.name, eventName, QueryCriterionType.Is);

        return super.fetchMetric(query, eventType, eventField);

    }



    @Override

    public Map<DateTime, CapacityPoint> readCapacity(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException {

        return super.fetchCapacityByDate(query, eventType, eventName, eventField, periodScope, periodDuration);

    };



    @Override

    protected Event buidItem(Map data) {

        return new Event(data);

    }



}package sgcib.tmon.worker.common.store.event;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.IStore;



import java.util.List;

import java.util.Map;



public interface IEventStore extends IStore {



    List<Event> save(final List<Event> events) throws WorkerException;



    Event save(final Event event) throws WorkerException;



    Event update(Event event) throws WorkerException;



    void delete(Event event) throws WorkerException;



    List<Event> read(IQuery query) throws WorkerException;



    Event read(String id) throws WorkerException;



    Metric readMetric(String metricName, String eventType, String eventName, String eventField,  IQuery query ) throws WorkerException;



    Map<DateTime, CapacityPoint> readCapacity(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException;

}



package sgcib.tmon.worker.common.store.event;



import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;

import ro.fortsoft.pf4j.Extension;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.MemoryStore;



import javax.mail.MethodNotSupportedException;

import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



/**

* Created by Stephane on 16/02/2015.

*/



public class MemoryEventStore extends ManageableBase implements IEventStore {

    private final Map<String, MemoryStore<Event>> store;



    public MemoryEventStore() {

        super("Memory.EventStore");

        store = new ConcurrentHashMap<String, MemoryStore<Event>>(10);

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public List<Event> save(List<Event> events) throws WorkerException {

        if (events != null && events.size() > 0) {

            for (Event event : events) {

                save(event);

            }

            return ImmutableList.copyOf(events);

        }

        return Collections.emptyList();

    }



    @Override

    public Event save(Event event) throws WorkerException {

        if (event != null) {

            MemoryStore<Event> store = null;

            if (!this.store.containsKey(event.getType())) {

                store = new MemoryStore<Event>();

                this.store.put(event.getType(), store);

            } else {

                store = this.store.get(event.getType());

            }



            if (store != null) {

                store.save(event.getId(), event);

            }

        }

        return event;

    }



    @Override

    public Event update(Event event) throws WorkerException {

        return save(event);

    }



    @Override

    public void delete(Event event) throws WorkerException {

        if (event != null) {

            String eventType = event.getType();

            MemoryStore<Event> store = this.store.get(eventType);

            if (store != null) {

                String id = event.getId();

                store.delete(id);

            }

        }

    }



    @Override

    public List<Event> read(IQuery query) throws WorkerException {

        ImmutableList.Builder<Event> builder = new ImmutableList.Builder<>();

        if (query != null) {

            for (MemoryStore<Event> eventStore : store.values()) {

                List<Event> events = eventStore.readAll();

                for (Event event : events) {

                    if (query.match(event)) {

                        builder.add(event);

                    }

                }

            }

        }

        return builder.build();

    }



    @Override

    public Event read(String id) throws WorkerException {

        for (MemoryStore<Event> eventStore : store.values()) {

            List<Event> events = eventStore.readAll();

            for (Event event : events) {

                if (event.getId().equals(id)) {

                    return event;

                }

            }

        }

        return null;

    }



    @Override

    public Metric readMetric(String metricName, String eventType, String eventName, String eventField, IQuery query) throws WorkerException {

        Metric metric = new Metric(eventType);

        if (query != null) {

            query.addCriterion(Event.type, eventType, QueryCriterionType.Is);

            query.addCriterion(Event.name, eventName, QueryCriterionType.Is);

            for (MemoryStore<Event> eventStore : store.values()) {

                List<Event> events = eventStore.readAll();

                for (Event event : events) {

                    if (query.match(event)) {

                        Object value = event.getValue(eventField);

                        if (value != null) {

                            metric.add(Double.parseDouble(value.toString()));

                        } else {

                            metric.add(0.0);

                        }

                    }

                }

            }

        }

        return metric;

    }



    @Override

    public Map<DateTime, CapacityPoint> readCapacity(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException {

        throw new WorkerException("This operation is not allowed on memory store", new MethodNotSupportedException("readCapacity"));

    }



}

package sgcib.tmon.worker.common.store.feature;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.*;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.StoreBase;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import java.util.List;

import java.util.Map;



public class FeatureStore extends StoreBase implements IFeatureStore {





    private class QueryableDataStore extends GenericQueryableStore<Queryable> {



        private final int searchOffset;



        private QueryableDataStore(StorageManager storageManager, int searchOffset) {

            super("queryableDataStore", storageManager, true, false, "logstash", "events");

            this.searchOffset = searchOffset;

        }



        @Override

        protected void checkMapping(String index) throws WorkerException {



        }



        @Override

        protected String[] getAlias() {

            String[] alias = new String[searchOffset];

            for (int index = 0; index < searchOffset; index++) {

                alias[index] = buildIndex(null, DateTime.now().minusDays(index));

            }

            return alias;

        }



        @Override

        protected Queryable buidItem(Map data) {

            return new Queryable(data);

        }



    }



    private class QueryableFeatureStore extends GenericQueryableStore<Feature> {



        public QueryableFeatureStore(StorageManager storageManager) {

            super("queryableFeatureStore", storageManager, false, false, "feature", "features");

        }



        @Override

        protected void checkMapping(String index) throws WorkerException {



        }



        @Override

        protected Feature buidItem(Map data) {

            return new Feature(data);

        }



    }



    private final int searchOffset;

    private final QueryableFeatureStore featureStore;

    private final QueryableDataStore dataStore;



    public FeatureStore(String name, StorageManager storageManager, int searchOffset) {

        super(name, storageManager);

        this.searchOffset = searchOffset;

        this.featureStore = new QueryableFeatureStore(storageManager);

        this.dataStore = new QueryableDataStore(storageManager, searchOffset);

    }



    @Override

    public void start() throws WorkerException {

        this.featureStore.start();

        this.dataStore.start();

    }



    @Override

    public void stop() throws WorkerException {

        this.featureStore.stop();

        this.dataStore.stop();

    }



    @Override

    public List<Feature> getFeatures() {

        IQuery query = new Query();

        query.addCriterion("type", "feature", QueryCriterionType.Is);

        return featureStore.fetch(query);

    }



    @Override

    public List<Queryable> loadTicket(DateTime lastCheck, String ticketEventName) {

        IQuery query = new Query();

        query.addCriterion(Queryable.type, ticketEventName, QueryCriterionType.Is);

        if (lastCheck != null) {

            query.addCriterion(Queryable.timestamp, lastCheck, QueryCriterionType.GreaterOrEqualThan);

        } else {

            DateTime now = DateTime.now();

            query.addCriterion(Queryable.timestamp, now.minusDays(searchOffset), QueryCriterionType.GreaterThan);

            query.addCriterion(Queryable.timestamp, now, QueryCriterionType.LesserThan);

        }

        return dataStore.fetch(query);

    }





    @Override

    public DateTime loadFeatureData(String feature, DateTime lastCheck, String dataEventType, String dataFeatureField) {

        IQuery query = new Query();

        query.addCriterion(Queryable.type, dataEventType, QueryCriterionType.Is);

        query.addCriterion(dataFeatureField, feature, QueryCriterionType.Is);

        if (lastCheck != null) {

            query.addCriterion(Queryable.timestamp, lastCheck, QueryCriterionType.GreaterOrEqualThan);

        } else {

            DateTime now = DateTime.now();

            query.addCriterion(Queryable.timestamp, now.minusDays(searchOffset), QueryCriterionType.GreaterThan);

            query.addCriterion(Queryable.timestamp, now, QueryCriterionType.LesserThan);

        }

        Metric metric = dataStore.fetchMetric(query, dataEventType, Queryable.timestamp);

        if (metric.getCount() > 0) {

            return new DateTime((long) metric.getMinimum());

        }

        return null;

    }



    @Override

    public List<Feature> loadTicketFollowUp() {

        IQuery query = new Query();

        query.addCriterion(Queryable.type, "ticketFollowUp", QueryCriterionType.Is);



        return featureStore.fetch(query);

    }



    @Override

    public void saveFeatures(List<Feature> features) {

        featureStore.save(features);

    }



}

package sgcib.tmon.worker.common.store.feature;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Feature;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.IStore;



import java.util.List;



/**

* Created by slopes041604 on 09/06/2015.

*/

public interface IFeatureStore extends IManageable, IStore {

    List<Feature> getFeatures();



    List<Queryable> loadTicket(DateTime lastCheck, String ticketEventName);



    DateTime loadFeatureData(String feature, DateTime lastCheck, String dataEventType, String dataFeatureField);



    List<Feature> loadTicketFollowUp();



    void saveFeatures(List<Feature> features);

}

package sgcib.tmon.worker.common.store.job;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.job.Job;

import sgcib.tmon.worker.common.model.job.JobType;

import sgcib.tmon.worker.common.store.IStore;



import java.util.List;



/**

* Created by adouangp012014 on 03/02/14.

*/

public interface IJobStore extends IStore {



    String getName();



    void create(Job job) throws WorkerException;



    void create(List<Job> jobs) throws WorkerException;



    void delete(String jobName,JobType type) throws WorkerException;



    Job update(Job job) throws WorkerException;



    Job read(String name) throws WorkerException;



    List<Job> getAllJobs() throws WorkerException;



    List<Job> getJobsByType(JobType jobType) throws WorkerException;



}

package sgcib.tmon.worker.common.store.job;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.job.Job;

import sgcib.tmon.worker.common.model.job.JobType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import java.util.List;

import java.util.Map;



/**

* Created by adouangp012014 on 03/02/14.

*/

public class JobStore extends GenericQueryableStore<Job> implements IJobStore{





    public JobStore(String name, StorageManager storageManager) {

        super("JobStore", storageManager, false, false, "job", "jobs");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {



    }



    @Override

    protected Job buidItem(Map data) {

        return new Job(data);

    }



    @Override

    public void create(Job job) throws WorkerException {

        super.save(job);

    }



    @Override

    public void create(List<Job> jobs) throws WorkerException {

        super.save(jobs);

    }



    @Override

    public void delete(String jobName, JobType type) throws WorkerException {

        super.delete(new Job(jobName, type));

    }



    @Override

    public Job read(String name) throws WorkerException {

        return  super.fetch(name);

    }



    @Override

    public List<Job> getAllJobs() throws WorkerException {

        IQuery query = new Query();

        return super.fetch(query);

    }



    @Override

    public List<Job> getJobsByType(JobType jobType) throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(Job.type, jobType, QueryCriterionType.Is);

        return super.fetch(query);

    }

}

package sgcib.tmon.worker.common.store.job;



import com.google.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.job.Job;

import sgcib.tmon.worker.common.model.job.JobType;

import sgcib.tmon.worker.common.store.MemoryStore;



import java.util.List;





public class MemoryJobStore extends ManageableBase implements IJobStore {

    private final MemoryStore<Job> store;



    public MemoryJobStore() {

        super("MemoryJobStore");

        store = new MemoryStore<Job>();

    }



    @Override

    public void create(Job job) throws WorkerException {

        store.save(job.getId(), job);

    }



    @Override

    public void create(List<Job> jobs) throws WorkerException {

        if (jobs != null && jobs.size() > 0) {

            for (Job job : jobs) {

                create(job);

            }

        }

    }



    @Override

    public void delete(String jobName, JobType type) throws WorkerException {

        store.delete(jobName);

    }



    @Override

    public Job update(Job job) throws WorkerException {

        store.update(job.getId(), job);

        return job;

    }



    @Override

    public Job read(String name) throws WorkerException {

        return store.read(name);

    }



    @Override

    public List<Job> getAllJobs() throws WorkerException {

        return store.readAll();

    }



    @Override

    public List<Job> getJobsByType(JobType jobType) throws WorkerException {

        IQuery query = new Query();

        query.addCriterion(Job.type, jobType.toString(), QueryCriterionType.Is);

        ImmutableList.Builder<Job> builder = new ImmutableList.Builder<>();

        if (query != null) {

            List<Job> jobs = store.readAll();

            for (Job job : jobs) {

                if (query.match(job)) {

                    builder.add(job);

                }

            }

        }

        return builder.build();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }

}

package sgcib.tmon.worker.common.store.metric;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Metric;



import java.util.List;

import java.util.UUID;



public interface IMetricStore extends IManageable {



    void create(Metric metric) throws WorkerException;



    void create(List<Metric> metrics) throws WorkerException;



    void delete(String name, DateTime startTime, DateTime stopTime) throws WorkerException;



    void aggregate(String name, DateTime startTime, DateTime stopTime, int factor) throws WorkerException;



    Metric read(UUID id) throws WorkerException;



    List<Metric> read(String name, DateTime startTime, DateTime stopTime) throws WorkerException;

}

package sgcib.tmon.worker.common.store.metric;



import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.MemoryStore;



import java.util.List;

import java.util.UUID;





public class MemoryMetricStore extends ManageableBase implements IMetricStore {

    private final MemoryStore<Metric> store;



    public MemoryMetricStore() {

        super("MemoryJobStore");

        store = new MemoryStore<Metric>();

    }





    @Override

    public void create(Metric metric) throws WorkerException {

        store.save(metric.getKey(), metric);

    }



    @Override

    public void create(List<Metric> metrics) throws WorkerException {

        if (metrics != null && metrics.size() > 0) {

            for (Metric metric : metrics) {

                create(metric);

            }

        }

    }



    @Override

    public void delete(String name, DateTime startTime, DateTime stopTime) throws WorkerException {

        List<Metric> metrics = read(name, startTime, stopTime);

        for (Metric metric : metrics) {

            store.delete(metric.getId());

        }

    }



    @Override

    public void aggregate(String name, DateTime startTime, DateTime stopTime, int factor) throws WorkerException {



    }



    @Override

    public Metric read(UUID id) throws WorkerException {

        return store.read(id.toString());

    }



    @Override

    public List<Metric> read(String name, DateTime startTime, DateTime stopTime) throws WorkerException {

        Query query = new Query();

        query.addCriterion(Queryable.name, name, QueryCriterionType.Is);

        query.addCriterion(Queryable.timestamp, startTime, QueryCriterionType.After);

        query.addCriterion(Queryable.timestamp, name, QueryCriterionType.Before);

        ImmutableList.Builder<Metric> builder = new ImmutableList.Builder<>();

        if (query != null) {

            List<Metric> metrics = store.readAll();

            for (Metric metric : metrics) {

                if (query.match(metric)) {

                    builder.add(metric);

                }

            }

        }

        return builder.build();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }





}

package sgcib.tmon.worker.common.store.metric;



import org.apache.commons.io.IOUtils;

import org.elasticsearch.ElasticsearchException;

import org.elasticsearch.action.ListenableActionFuture;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingRequestBuilder;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.client.Client;

import org.joda.time.DateTime;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import java.io.IOException;

import java.util.List;

import java.util.Map;

import java.util.UUID;



/**

* Created by adouangp012014 on 03/02/14.

*/

public class MetricStore extends GenericQueryableStore<Metric> implements IMetricStore {



    public static String mapping = "metricMapping";



    public MetricStore(String name, StorageManager storageManager) {

        super("MetricStore", storageManager, true, false, "metrics", "metrics");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {

        try {

            Client client = getStorageManager().getClient();

            if (client != null) {

                if (!getStorageManager().isMappingExist(client, index, MetricStore.mapping)) {

                    createMapping(client, index);

                }

            }

        } catch (IOException error) {

            getLogger().debug("Creation of mapping failed", error);

            throw new WorkerException("Creation of mapping failed", error);

        }

    }



    @Override

    protected Metric buidItem(Map data) {

        return new Metric(data);

    }



    private boolean createMapping(Client client, String index) throws IOException {

        boolean result = false;

        PutMappingRequestBuilder metric = client.admin().indices().preparePutMapping(index).setType("metric").setSource(getMapping());

        ListenableActionFuture<PutMappingResponse> execute = metric.execute();

        PutMappingResponse response = null;

        try {

            response = execute.actionGet();

            result = response.isAcknowledged();

        } catch (ElasticsearchException eex) {

            getLogger().error("Creation of mapping failed", eex);

        }

        return result;

    }



    private String getMapping() throws IOException {

        return IOUtils.toString(getClass().getClassLoader().getResourceAsStream("mappings/metricMapping.json"));

    }



    @Override

    protected String buildIndex(String itemType, DateTime date) throws WorkerException {

        String index = "metrics";



        if (date != null) {

            index = String.format("%s-%s", index, date.toString("yyyy-MM"));

        } else {

            index = String.format("%s-%s", index, "*");

        }



        return index.toLowerCase();

    }



    @Override

    public void create(Metric metric) throws WorkerException {

        save(metric);

    }



    @Override

    public void create(List<Metric> metrics) throws WorkerException {

        save(metrics);

    }



    @Override

    public void delete(String name, DateTime startTime, DateTime stopTime) throws WorkerException {

        List<Metric> metrics = read(name, startTime, stopTime);

        delete(metrics);

    }



    @Override

    public void aggregate(String name, DateTime startTime, DateTime stopTime, int factor) throws WorkerException {



    }



    @Override

    public Metric read(UUID id) throws WorkerException {

        return fetch(id.toString());

    }



    @Override

    public List<Metric> read(String name, DateTime startTime, DateTime stopTime) throws WorkerException {

        Query query = new Query();

        query.addCriterion(Queryable.name,name,QueryCriterionType.Is);

        query.addCriterion(Queryable.timestamp,startTime,QueryCriterionType.After);

        query.addCriterion(Queryable.timestamp, name, QueryCriterionType.Before);

        return fetch(query);

    }



}

package sgcib.tmon.worker.common.store.queryable;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.google.common.base.Function;

import org.apache.commons.lang3.StringUtils;

import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.index.IndexRequestBuilder;

import org.elasticsearch.client.Client;

import org.elasticsearch.common.collect.Lists;

import org.elasticsearch.index.VersionType;

import org.joda.time.DateTime;

import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.chain.ChainStore;

import sgcib.tmon.worker.configuration.AsyncPollerConfiguration;



import java.util.Collections;

import java.util.Comparator;

import java.util.List;

import java.util.Map;

import java.util.Map.Entry;

import java.util.concurrent.*;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.atomic.AtomicLong;

import java.util.stream.Collectors;



/**

* @author slopes041604

* @author ablaszcz120213

*/

public class AsyncQueryableStore extends QueryableStore {



    // Limit the number of drained events from the blocking queue.

    private static final int MAX_EVENTS = 500;



    private Client client;

   private ExecutorService executor;

    private BlockingQueue<StoredQueryable> itemsToStore;

    private int nThreads;

    private AtomicBoolean isRunning;



    private AtomicLong atomicVersion = new AtomicLong(System.currentTimeMillis());



    public AsyncQueryableStore(String name, StorageManager storageManager) {

        super(name, storageManager);

        this.initExecutor(storageManager);

        this.itemsToStore = new LinkedBlockingDeque<StoredQueryable>();

        this.client = getStorageManager().getClient();

        this.isRunning = new AtomicBoolean(false);

    }



    /**

     * Create a thread pool that can schedule commands to run after a given

     * delay, or to execute periodically. The storage manager {@code manager}

     * should have the attribute {@code threads}, otherwise a default value is

     * used.

     *

     * @param manager The given storage manager.

     */

    @SuppressWarnings("static-access")

    private void initExecutor(StorageManager manager) {

        this.nThreads = manager.getConfiguration() != null ? manager.getConfiguration().getAsyncPollerConfiguration().getThreads() : //

                AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS;

        this.executor = Executors.newFixedThreadPool(this.nThreads);

    }



    @Override

    public void start() throws WorkerException {



        this.isRunning.set(true);

        super.start();



        getLogger().info("Wait for yellow cluster state");

        getStorageManager().getClient().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();



        // Prevent too many threads.

        Semaphore semaphore = new Semaphore(AsyncPollerConfiguration.DEFAULT_ASYNC_THREADS);



        // Used to find max version of StoredQueryable.

        final Comparator<StoredQueryable> versionComparator = Comparator.comparing(StoredQueryable::getVersion);



        // Launch consumers.

        for (int i = 0; i < this.nThreads; i++) {

            executor.execute(() -> {

                do {

                    boolean permit = false;

                    try {

                        Thread.sleep(100);

                        permit = semaphore.tryAcquire(100, TimeUnit.MILLISECONDS);

                        if (permit) {

                            List<StoredQueryable> queryables = Lists.newArrayList();

                            int count = itemsToStore.drainTo(queryables, MAX_EVENTS);

                            if (count > 0) {

                                // Conflate items before storing them.

                                List<StoredQueryable> conflatedQueryables = Lists.newArrayList();

                                Map<String, List<StoredQueryable>> groupedQueryables = queryables //

                                        .parallelStream() //

                                        .collect(Collectors.groupingBy(StoredQueryable::getId));



                                for (Entry<String, List<StoredQueryable>> entry : groupedQueryables.entrySet()) {

                                    conflatedQueryables.add(Collections.max(entry.getValue(), versionComparator));

                                }

                                storeMultiple(conflatedQueryables);

                            }

                        }

                    } catch (Exception error) {

                        getLogger().error("Fail to store queryables", error);

                    } finally {

                        if (permit) {

                            semaphore.release();

                        }

                    }



                } while (isRunning.get());

            });

        }

    }



    @Override

    public void stop() throws WorkerException {

        try {

            super.stop();

            this.isRunning.set(false);

            executor.shutdown();

            executor.awaitTermination(10, TimeUnit.SECONDS);

            getLogger().info("{} has stopped", getName());

        } catch (InterruptedException e) {

            getLogger().error("Error while stopping.", e);

       } finally {

            if (!executor.isTerminated()) {

                getLogger().warn("Cancel non-finished tasks for {}", getName());

            }

            executor.shutdownNow();

            getLogger().info("Shutdown finished");

        }

   }



    @Override

    public List<Queryable> save(final List<Queryable> items) throws WorkerException {

        items.stream().forEach(i -> save(i));

        return items;

    }



    @Override

    public Queryable save(final Queryable item) throws WorkerException {

        itemsToStore.offer(new StoredQueryable(item));

        return item;

    }



    @Override

    public List<Queryable> update(final List<Queryable> items) throws WorkerException {

        items.stream().forEach(i -> save(i));

        return items;

    }



    @Override

    public Queryable update(final Queryable item) throws WorkerException {

        itemsToStore.offer(new StoredQueryable(item));

        return item;

    }



    /**

     * Insert mode only used for all queryables instances

     * {@link StoredQueryable}.

     *

     * @param queryables List of given instances to persit.

     */

    private void storeMultiple(List<StoredQueryable> queryables) {



        if (queryables.size() == 0) {

            return;

        }



        try {

            BulkRequestBuilder bulkRequest = this.client.prepareBulk();

            Function<Queryable, String> indexBuilder = this.getIndexBuilder();

            Function<Queryable, String> parentBuilder = getParentBuilder();



            for (StoredQueryable item : queryables) {

                try {

                    IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(item.getItem()), item.getItem().getType(), item.getItem().getId());

                    saveRequest.setVersion(item.getVersion()).setVersionType(VersionType.EXTERNAL);

                    if (parentBuilder != null) {

                        String parent = parentBuilder.apply(item.getItem());

                        if (parent != null) {

                            saveRequest.setParent(parent);

                        }

                    }

                    bulkRequest.add(saveRequest.setSource(item.getItemAsString()));

                } catch (Exception error) {

                    getLogger().error("Fail to prepare save request", error);

                }

            }



            BulkResponse response = bulkRequest.execute().get();

            if (response.hasFailures()) {

                String failureMessage = response.buildFailureMessage();

                getLogger().error("Error on store multiple, response failure {}", failureMessage);

            }



        } catch (InterruptedException | ExecutionException error) {

            getLogger().error("Error on store multiple", error);

        }

    }



    /**

     * Wrapper used to perform serialization on {@link Queryable} item.

     */

    class StoredQueryable {



        private final String id;

        private final long version;

        private final Queryable item;

        private final String itemAsString;



        public StoredQueryable(Queryable item) {

            this.id = item.getId();

            this.version = item.getVersion();

            this.item = item;

            try {

                this.itemAsString = getMapper().writeValueAsString(item);

            } catch (JsonProcessingException e) {

                throw new WorkerException(e);

           }

        }



        public String getId() {

            return id;

        }



        public Queryable getItem() {

            return item;

        }



        public String getItemAsString() {

            return itemAsString;

        }



        public long getVersion() {

            return version;

        }

    }



}

package sgcib.tmon.worker.common.store.queryable;



import java.util.ArrayList;

import java.util.Collection;

import java.util.Date;

import java.util.List;

import java.util.Map;

import java.util.Timer;

import java.util.TimerTask;

import java.util.concurrent.ConcurrentHashMap;



import javax.annotation.Nullable;



import org.apache.commons.lang3.StringUtils;

import org.elasticsearch.action.bulk.BulkItemResponse;

import org.elasticsearch.action.bulk.BulkRequestBuilder;

import org.elasticsearch.action.bulk.BulkResponse;

import org.elasticsearch.action.delete.DeleteRequest;

import org.elasticsearch.action.delete.DeleteResponse;

import org.elasticsearch.action.deletebyquery.DeleteByQueryResponse;

import org.elasticsearch.action.index.IndexRequestBuilder;

import org.elasticsearch.action.index.IndexResponse;

import org.elasticsearch.action.search.SearchRequest;

import org.elasticsearch.action.search.SearchRequestBuilder;

import org.elasticsearch.action.search.SearchResponse;

import org.elasticsearch.action.search.SearchType;

import org.elasticsearch.action.support.IndicesOptions;

import org.elasticsearch.action.update.UpdateRequestBuilder;

import org.elasticsearch.action.update.UpdateResponse;

import org.elasticsearch.client.Client;

import org.elasticsearch.common.base.Predicate;

import org.elasticsearch.common.collect.Collections2;

import org.elasticsearch.common.unit.TimeValue;

import org.elasticsearch.index.query.BoolQueryBuilder;

import org.elasticsearch.index.query.MatchQueryBuilder;

import org.elasticsearch.index.query.QueryBuilders;

import org.elasticsearch.search.SearchHit;

import org.elasticsearch.search.aggregations.AggregationBuilder;

import org.elasticsearch.search.aggregations.AggregationBuilders;

import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogram;

import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramBuilder;

import org.elasticsearch.search.aggregations.bucket.terms.Terms;

import org.elasticsearch.search.aggregations.metrics.MetricsAggregationBuilder;

import org.elasticsearch.search.aggregations.metrics.stats.extended.ExtendedStats;

import org.joda.time.DateTime;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.QueryCriterion;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.StoreBase;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.google.common.base.Function;

import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 16/05/2015.

*/

public abstract class GenericQueryableStore<T extends Queryable> extends StoreBase {



    public static String emptyParentName = "00000000-0000-0000-0000-000000000000";



    private final boolean useDateInIndex;

    private final boolean useQueryableTypeInIndex;

    private final String indexPattern;

    private final String indexAlias;

    private Timer timer;



    public GenericQueryableStore(String name, StorageManager storageManager) {

        super(name, storageManager);

        this.useDateInIndex = true;

        this.useQueryableTypeInIndex = false;

        this.indexPattern = "logstash";

        this.indexAlias = this.indexPattern;

    }



    public GenericQueryableStore(String name, StorageManager storageManager, boolean useDateInIndex, boolean useTypeIndex, String indexPattern, String indexAlias) {

        super(name, storageManager);

        this.useDateInIndex = useDateInIndex;

        this.useQueryableTypeInIndex = useTypeIndex;

        this.indexPattern = indexPattern;

        this.indexAlias = indexAlias;



    }



    /* Save */

    public static <T extends Queryable> List<T> save(GenericQueryableStore<T> store, List<T> items) {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return items;

        }



        BulkRequestBuilder bulkRequest = client.prepareBulk();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        Function<T, String> parentBuilder = store.getParentBuilder();

        for (T item : items) {

            String itemType = item.getType();



            try {

                String itemAsString = store.getMapper().writeValueAsString(item);

                IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(item), itemType, item.getId());

                saveRequest.setSource(item);

                if (parentBuilder != null) {

                    String parent = parentBuilder.apply(item);

                    if (parent != null) {

                        saveRequest.setParent(parent);

                    }

                }

                // TODO replace by an other method

                // saveRequest.setVersion(item.getTimestamp().getMillis()).setVersionType(VersionType.EXTERNAL);

                bulkRequest.add(saveRequest.setSource(itemAsString));

            } catch (JsonProcessingException error) {

                store.getLogger().error(String.format("Json conversion failed for item %s", item.getId()), error);

                item.put("error", error.getMessage());

            }

        }



        BulkResponse bulkResponse = bulkRequest.execute().actionGet();

        if (bulkResponse.hasFailures()) {

            for (BulkItemResponse response : bulkResponse.getItems()) {

                final String itemId = response.getId();

                Predicate<T> findQueryable = new Predicate<T>() {



                    @Override

                    public boolean apply(T item) {

                        return item.getId().equals(itemId);

                    }

                };

                Collection<T> filteredQueryables = Collections2.filter(items, findQueryable);

                if (filteredQueryables != null && filteredQueryables.size() == 1) {

                    Queryable filteredQueryable = (Queryable) filteredQueryables.toArray()[0];

                    if (response.getFailure() != null) {

                        filteredQueryable.put("error", response.getFailure().getMessage());

                    } else {

                        filteredQueryable.put("version", response.getVersion());

                    }

                }

            }

        }

        return items;

    }



    public static <T extends Queryable> T save(GenericQueryableStore<T> store, T item) {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return item;

        }



        String itemType = item.getType();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        Function<T, String> parentBuilder = store.getParentBuilder();



        // TODO don't save the version attribut, there is already the

        // elasticsearch document version

        if (item.containsKey("version")) {

            item.remove("version");

        }



        IndexRequestBuilder saveRequest = client.prepareIndex(indexBuilder.apply(item), itemType, item.getId());

        saveRequest.setSource(item);

        if (parentBuilder != null) {

            String parent = parentBuilder.apply(item);

            if (parent != null) {

                if (!parent.equals(emptyParentName)) {

                    // TODO : delete only if was empty

                    client.delete(new DeleteRequest(indexBuilder.apply(item), itemType, item.getId()).parent(emptyParentName));

                }

                saveRequest.setParent(parent);

            }

        }



        IndexResponse indexResponse = saveRequest.execute().actionGet();

        item.put("version", indexResponse.getVersion());

        return item;

    }



    public static <T extends Queryable> T fetch(GenericQueryableStore<T> store, String id) {



        Client client = store.getStorageManager().getClient();



        // Can't continue if nor client has no been defined, neither id.

        if (client == null || id == null) {

            return null;

        }



        SearchRequestBuilder searchRequest = client.prepareSearch() //

                .setIndices(store.getAlias())//

                .setSize(1)//

                .setSearchType(SearchType.QUERY_AND_FETCH)//

                .setScroll(new TimeValue(60000))//

                .setQuery(QueryBuilders.matchQuery(Queryable.key, id).operator(MatchQueryBuilder.Operator.AND)) //

                .setVersion(true);



        Function<Map, T> itemBuilder = store.getItemBuilder();



        SearchResponse searchResponse = searchRequest.execute().actionGet();



        if (searchResponse.getHits().getHits().length == 1) {

            SearchHit searchHitFields = searchResponse.getHits().getHits()[0];

            Map<String, Object> source = searchHitFields.getSource();

            source.put("version", searchHitFields.getVersion());

            return itemBuilder.apply(source);

        }



        return null;

    }



    protected static <T extends Queryable> List<T> fetchChildren(GenericQueryableStore store, String id, String parentType) {

        Client client = store.getStorageManager().getClient();

        if (id == null) {

            return null;

        }



        SearchRequestBuilder searchRequest = client.prepareSearch().setIndices(store.getAlias()).setSearchType(SearchType.QUERY_AND_FETCH).setScroll(new TimeValue(60000))

                .setQuery(QueryBuilders.hasParentQuery(parentType, QueryBuilders.matchQuery(Queryable.key, id)));



        SearchResponse searchResponse = searchRequest.execute().actionGet();

        ImmutableList.Builder<T> items = new ImmutableList.Builder<>();

        if (searchResponse.getHits().getHits().length > 0) {

            Function<Map, T> itemBuilder = store.getItemBuilder();

            for (SearchHit hit : searchResponse.getHits().getHits()) {

                items.add(itemBuilder.apply(hit.getSource()));

            }

        }

        return items.build();

    }



    public static <T extends Queryable> List<T> fetch(GenericQueryableStore<T> store, IQuery query) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return null;

        }

        List<T> items = new ArrayList<T>();



        try {

            boolean searchComplete = false;

            BoolQueryBuilder elasticQuery = QueryBuilders.boolQuery();

            store.buildQuery(query, elasticQuery);



            Function<Map, T> itemBuilder = store.getItemBuilder();



            SearchRequestBuilder searchRequest = client.prepareSearch().setIndices(store.getAlias()).setIndicesOptions(IndicesOptions.fromOptions(true, false, false, false)).setSearchType(SearchType.SCAN).setScroll(new TimeValue(60000))

                    .setQuery(elasticQuery).setSize(100).setVersion(true);

            SearchResponse searchResponse = searchRequest.execute().actionGet();

            while (!searchComplete) {

                for (SearchHit hit : searchResponse.getHits().getHits()) {

                    // items.add(itemBuilder.apply(hit.getSource()));

                    Map<String, Object> source = hit.getSource();

                    source.put("version", hit.getVersion());

                    items.add(itemBuilder.apply(source));

                }

                searchResponse = client.prepareSearchScroll(searchResponse.getScrollId()).setScroll(new TimeValue(600000)).execute().actionGet();

                // Break condition: No hits are returned

                if (searchResponse.getHits().getHits().length == 0) {

                    searchComplete = true;

                }

            }

        } catch (WorkerException error) {

            throw new WorkerException("Failed to build index list", error);

        }



        return items;

    }



    public static Metric fetchMetric(GenericQueryableStore<?> store, IQuery query, String alias, String itemType, String valueField) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return null;

        }

        try {

            BoolQueryBuilder elasticQuery = QueryBuilders.boolQuery();

            store.buildQuery(query, elasticQuery);



            MetricsAggregationBuilder<?> aggregation = AggregationBuilders.extendedStats(itemType).field(valueField);



            SearchRequestBuilder searchRequest = client.prepareSearch().setIndices(getAlias(store, alias)).setQuery(elasticQuery).setSize(0).setSearchType(SearchType.COUNT).addAggregation(aggregation);



            SearchResponse searchResponse = searchRequest.execute().actionGet();



            ExtendedStats result = searchResponse.getAggregations().get(itemType);

            if (result != null) {

                Metric metric = new Metric(itemType);

                metric.setCount(result.getCount());

                metric.setMinimum(result.getMin());

                metric.setMaximum(result.getMax());

                metric.setMean(result.getAvg());

                metric.setSum(result.getSum());

                return metric;

            }



        } catch (WorkerException error) {

            throw new WorkerException("Failed to build index list", error);

        }



        return null;

    }



    /**

     * Return the given alias {@code alias} if present, otherwise the default

     * alias store {@code store}.

     *

     * @param store The given store.

     * @param alias The optinal alias.

     */

    private static String[] getAlias(GenericQueryableStore<?> store, String alias) {

        if (!StringUtils.isEmpty(alias)) {

            return new String[]{alias};

        }

        return store.getAlias();

    }



    public static Map<String, Metric> fetchMetricsByInstance(GenericQueryableStore store, IQuery query, String itemType, String valueField, String instanceField) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return null;

        }



        try {

            BoolQueryBuilder elasticQuery = QueryBuilders.boolQuery();

            store.buildQuery(query, elasticQuery);



            AggregationBuilder aggregation = AggregationBuilders.terms("instance").field(instanceField).subAggregation(AggregationBuilders.extendedStats(itemType).field(valueField));



            SearchResponse searchResponse = client.prepareSearch().setIndices(store.getAlias()).setQuery(elasticQuery).setSearchType(SearchType.COUNT).addAggregation(aggregation).execute().actionGet();



            Map<String, Metric> metrics = new ConcurrentHashMap<>();

            Terms result = searchResponse.getAggregations().get("instance");

            for (Terms.Bucket entry : result.getBuckets()) {

                ExtendedStats statistics = entry.getAggregations().get(itemType);

                Metric metric = new Metric(entry.getKey());

                metric.setCount(statistics.getCount());

                metric.setMinimum(statistics.getMin());

                metric.setMaximum(statistics.getMax());

                metric.setMean(statistics.getAvg());

                metric.setSum(statistics.getSum());

                metrics.put(entry.getKey(), metric);

            }

            return metrics;



       } catch (WorkerException error) {

            throw new WorkerException("Failed to build index list", error);

        }



    }



    public static Map<DateTime, CapacityPoint> fetchCapacityByDate(GenericQueryableStore store, IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return null;

        }



        try {

            BoolQueryBuilder elasticQuery = QueryBuilders.boolQuery();

            store.buildQuery(query, elasticQuery);



            DateHistogramBuilder aggregation = AggregationBuilders.dateHistogram(eventType).field(Queryable.timestamp);



            switch (periodScope) {

                case MINUTE:

                    aggregation.interval(DateHistogram.Interval.minutes(periodDuration));

                    break;

                case HOUR:

                    aggregation.interval(DateHistogram.Interval.hours(periodDuration));

                    break;

                case DAY:

                    aggregation.interval(DateHistogram.Interval.days(periodDuration));

                    break;

                case WEEK:

                    aggregation.interval(DateHistogram.Interval.weeks(periodDuration));

                    break;

                case MONTH:

                    aggregation.interval(DateHistogram.Interval.MONTH);

                    break;

                case QUARTER:

                    aggregation.interval(DateHistogram.Interval.QUARTER);

                    break;

                case YEAR:

                    aggregation.interval(DateHistogram.Interval.YEAR);

                    break;

            }



            aggregation.subAggregation(AggregationBuilders.extendedStats(eventType).field(eventField));



            SearchResponse searchResponse = client.prepareSearch().setIndices(store.getAlias()).setQuery(elasticQuery).setSearchType(SearchType.COUNT).addAggregation(aggregation).execute().actionGet();



            Map<DateTime, CapacityPoint> points = new ConcurrentHashMap<>();

            DateHistogram result = searchResponse.getAggregations().get(eventType);



            for (DateHistogram.Bucket entry : result.getBuckets()) {

                ExtendedStats statistics = entry.getAggregations().get(eventType);

                CapacityPoint point = new CapacityPoint(new DateTime(entry.getKeyAsDate().getMillis()));

                point.setCount(statistics.getCount());

                point.setMinimum(statistics.getMin());

                point.setMaximum(statistics.getMax());

                point.setMean(statistics.getAvg());

                point.setSum(statistics.getSum());

                points.put(new DateTime(entry.getKeyAsDate().getMillis()), point);

            }



            return points;



        } catch (WorkerException error) {

            throw new WorkerException("Failed to build index list", error);

        }



    }



    public static <T extends Queryable> List<T> update(GenericQueryableStore<T> store, List<T> items) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return items;

        }



        BulkRequestBuilder bulkRequest = client.prepareBulk();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        for (T item : items) {

            String itemType = item.getType();

            Function<T, String> parentBuilder = store.getParentBuilder();



            UpdateRequestBuilder updateRequest = client.prepareUpdate(indexBuilder.apply(item), itemType, item.getId());

            updateRequest.setDoc(item).setUpsert(item).setDocAsUpsert(true);

            if (parentBuilder != null) {

                String parent = parentBuilder.apply(item);

                if (parent != null) {

                    updateRequest.setParent(parent);

                }

            }

            bulkRequest.add(updateRequest);

        }



        BulkResponse bulkResponse = bulkRequest.execute().actionGet();

        if (bulkResponse.hasFailures()) {

            for (BulkItemResponse response : bulkResponse.getItems()) {

                final String itemId = response.getId();

                Predicate<T> findQueryable = new Predicate<T>() {

                    @Override

                    public boolean apply(T item) {

                        return item.getId().equals(itemId);

                    }

                };

                Collection<T> filteredQueryables = Collections2.filter(items, findQueryable);

                if (filteredQueryables != null && filteredQueryables.size() == 1) {

                    Queryable filteredQueryable = (Queryable) filteredQueryables.toArray()[0];

                    if (response.getFailure() != null) {

                        filteredQueryable.put("error", response.getFailure().getMessage());

                    } else {

                        filteredQueryable.put("version", response.getVersion());

                    }

                }

            }

        }

        return items;

    }



    public static <T extends Queryable> T update(GenericQueryableStore<T> store, T item) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return item;

        }

        String itemType = item.getType();

        Function<T, String> parentBuilder = store.getParentBuilder();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        UpdateRequestBuilder updateRequest = client.prepareUpdate(indexBuilder.apply(item), itemType, item.getId());

        updateRequest.setDoc(item);

        if (parentBuilder != null) {

            String parent = parentBuilder.apply(item);

            if (parent != null) {

                updateRequest.setParent(parent);

            }

        }

        // LoggerFactory.getLogger("GenericQueryableStore").debug(item.toString());

        // TODO replace by an other method

        // updateRequest.setVersion(item.getTimestamp().getMillis()).setVersionType(VersionType.EXTERNAL);

        final UpdateResponse updateResponse = updateRequest.execute().actionGet();

        item.put("version", updateResponse.getVersion());

        return item;

    }



    public static <T extends Queryable> List<T> delete(GenericQueryableStore<T> store, List<T> items) throws WorkerException {

        Client client = store.getStorageManager().getClient();

        if (client == null) {

            return items;

        }



        BulkRequestBuilder bulkRequest = client.prepareBulk();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        for (T item : items) {

            String itemType = item.getType();

            bulkRequest.add(client.prepareDelete(indexBuilder.apply(item), itemType, item.getId()));

        }



        BulkResponse bulkResponse = bulkRequest.execute().actionGet();

        if (bulkResponse.hasFailures()) {

            for (BulkItemResponse response : bulkResponse.getItems()) {

                final String itemId = response.getId();

                Predicate<T> findQueryable = new Predicate<T>() {

                    @Override

                    public boolean apply(T item) {

                        return item.getId().equals(itemId);

                    }

                };

                Collection<T> filteredQueryables = Collections2.filter(items, findQueryable);

                if (filteredQueryables != null && filteredQueryables.size() == 1) {

                    Queryable filteredQueryable = (Queryable) filteredQueryables.toArray()[0];

                    if (response.getFailure() != null) {

                        filteredQueryable.put("error", response.getFailure().getMessage());

                    } else {

                        filteredQueryable.put("version", response.getVersion());

                    }

                }

            }

        }

        return items;

    }



    public static <T extends Queryable> void delete(GenericQueryableStore<T> store, T item) {

        Client client = store.getStorageManager().getClient();

        Function<T, String> indexBuilder = store.getIndexBuilder();

        String type = item.getType();

        String index = indexBuilder.apply(item);

        String id = item.getId();

        // checkEvent(index, type, id);

        final DeleteResponse deleteResponse = client.prepareDelete(index, type, id).setOperationThreaded(true).execute().actionGet();

    }



    public static <T extends Queryable> void delete(GenericQueryableStore<T> store, IQuery query) {

        Client client = store.getStorageManager().getClient();

        BoolQueryBuilder elasticQuery = QueryBuilders.boolQuery();

        store.buildQuery(query, elasticQuery);

        DeleteByQueryResponse response = client.prepareDeleteByQuery(store.getAlias()).setQuery(elasticQuery).execute().actionGet();

    }



    @Override

    public void start() throws WorkerException {

        if (useDateInIndex) {

            this.timer = new Timer();

            checkIndexAndMapping();

            TimerTask task = new TimerTask() {

                @Override

                public void run() {

                    checkIndexAndMapping();

                }

            };

            timer.scheduleAtFixedRate(task, 0, 3600 * 1000);

        } else {

            validateIndex(DateTime.now());

        }



        long start = new Date().getTime();

        getLogger().info("Wait for yellow cluster state");

        getStorageManager().getClient().admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();

        getLogger().info("End of waiting for yellow cluster state");

        final long elaspedMilliseconds = (new Date().getTime()) - start;

        final String message = String.format("%s ms elapsed for yellow cluster state", elaspedMilliseconds);

        if (elaspedMilliseconds > 30000) {

            getLogger().error(message);

        } else {

            getLogger().info(message);

        }

    }



    private void checkIndexAndMapping() {

        DateTime now = DateTime.now();

        validateIndex(now);

        validateIndex(now.plusDays(1));

    }



    private void validateIndex(DateTime date) {

        StorageManager storageManager = getStorageManager();

        String index = buildIndex(indexPattern, date);

        if (!storageManager.isIndexExist(index)) {

            storageManager.createIndex(index);

        }

        storageManager.addAlias(index, indexAlias);

        checkMapping(index);



    }



    protected abstract void checkMapping(String index) throws WorkerException;



    protected String[] getAlias() {

        String[] alias = new String[1];

        alias[0] = indexAlias;

        return alias;

    }



    @Override

    public void stop() throws WorkerException {

        if (useDateInIndex) {

            if (timer != null) {

                timer.cancel();

            }

        }

    }



    public void buildQuery(IQuery query, BoolQueryBuilder elasticQuery) {



        for (QueryCriterion criterion : query.getCriteria()) {

            if (criterion.getType() == QueryCriterionType.Is) {

                elasticQuery.must(QueryBuilders.matchQuery(criterion.getField(), criterion.getValue()));

            }



            if (criterion.getType() == QueryCriterionType.NotIs) {

                elasticQuery.mustNot(QueryBuilders.matchQuery(criterion.getField(), criterion.getValue()));

            }



            if (criterion.getType() == QueryCriterionType.GreaterOrEqualThan) {

                elasticQuery.must(QueryBuilders.rangeQuery(criterion.getField()).gte(criterion.getValue()));

            }



            if (criterion.getType() == QueryCriterionType.GreaterThan) {

                elasticQuery.must(QueryBuilders.rangeQuery(criterion.getField()).gt(criterion.getValue()));

            }



            if (criterion.getType() == QueryCriterionType.LesserThan) {

                elasticQuery.must(QueryBuilders.rangeQuery(criterion.getField()).lt(criterion.getValue()));

            }



            if (criterion.getType() == QueryCriterionType.LesserOrEqualThan) {

                elasticQuery.must(QueryBuilders.rangeQuery(criterion.getField()).lte(criterion.getValue()));

            }

        }



        if (query.getQueryFilter() != null) {

            elasticQuery.must(QueryBuilders.queryString(query.getQueryFilter()));

        }



    }



    public List<T> save(List<T> items) throws WorkerException {

        if (items != null && items.size() > 0) {

            return save(this, items);

       }

        return items;

    }



    public T save(T item) throws WorkerException {

        return save(this, item);

    }



    /* Read */

    public T fetch(String id) {

        return fetch(this, id);

    }



    /* Update */



    protected <T extends Queryable> List<T> fetchChildren(String id, String parentType) {

        return fetchChildren(this, id, parentType);

    }



    public List<T> fetch(IQuery query) throws WorkerException {

        return fetch(this, query);

    }



   public Metric fetchMetric(IQuery query, String itemType, String valueField) throws WorkerException {

        // null value: because of no alias

        return fetchMetric(this, query, null, itemType, valueField);

    }



    public Metric fetchMetric(IQuery query, String alias, String itemType, String valueField) throws WorkerException {

        return fetchMetric(this, query, alias, itemType, valueField);

    }



    public Map<String, Metric> fetchMetricsByInstance(IQuery query, String itemType, String valueField, String instanceField) throws WorkerException {

        return fetchMetricsByInstance(this, query, itemType, valueField, instanceField);

    }



    public Map<DateTime, CapacityPoint> fetchCapacityByDate(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException {

        return fetchCapacityByDate(this, query, eventType, eventName, eventField, periodScope, periodDuration);

    }



    public List<T> update(List<T> items) throws WorkerException {

        if (items != null && items.size() > 0) {

            return update(this, items);

        }

        return items;

    }



    public T update(T item) throws WorkerException {

        return update(this, item);

    }



    /* Delete */

    public List<T> delete(List<T> items) throws WorkerException {

        return delete(this, items);

    }



    public void delete(T item) {

        delete(this, item);

    }



    public void delete(IQuery query) {

        delete(this, query);

    }



    /* Index builder */

    public <T extends Queryable> Function<T, String> getIndexBuilder() {

        return new IndexBuilder<T>();

    }



    protected String buildIndex(String itemType, DateTime date) throws WorkerException {

        String index = indexPattern;

        if (useQueryableTypeInIndex) {

            if (itemType != null) {

                index = String.format("%s.%s", index, itemType);

            } else {

                index = String.format("%s.%s", index, "*");

            }

        }

        if (useDateInIndex) {

            if (date != null) {

                index = String.format("%s-%s", index, date.toString("yyyy.MM.dd"));

            } else {

                index = String.format("%s-%s", index, "*");

            }

        }

        return index.toLowerCase();

    }



    public <T extends Queryable> Function<Map, T> getItemBuilder() {

        return new ItemBuilder<T>();

    }



    /* Item builder */



    protected abstract <T extends Queryable> T buidItem(Map data);



    public <T extends Queryable> Function<T, String> getParentBuilder() {

        return null;

    }



    private void checkEvent(String index, String type, String id) throws WorkerException {

        if (StringUtils.isEmpty(index) || StringUtils.isEmpty(type) || StringUtils.isEmpty(id)) {

            throw new WorkerException(String.format("One of theses parameters if missing: index<%s>, type<%s>, id<%s>", index, type, id));

        }

    }



    private class IndexBuilder<T extends Queryable> implements Function<T, String> {

        @Nullable

        @Override

        public String apply(@Nullable T item) {

            if (item != null) {

                String type = item.getType();

                DateTime timeStamp = item.getTimestamp();

                return buildIndex(type, timeStamp);

            } else {

                return buildIndex(null, null);

            }

        }

    }



    private class ItemBuilder<T extends Queryable> implements Function<Map, T> {

        @Nullable

        @Override

        public T apply(@Nullable Map data) {

            return buidItem(data);

        }

    }



}

package sgcib.tmon.worker.common.store.queryable;



import java.util.List;

import java.util.Map;



import org.joda.time.DateTime;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;



/**

* Created by Stephane on 16/05/2015.

*/

public interface IQueryableStore extends IManageable {



    List<Queryable> save(final List<Queryable> items) throws WorkerException;



    Queryable save(final Queryable item) throws WorkerException;



    List<Queryable> fetch(IQuery query) throws WorkerException;



    /**

     * Return a {@link Metric} instance according to the given query

     * {@code query} and event parameters {@code alias}, {@code eventType} and

     * {@code eventField}. The {@code alias} is optional.

     *

     * @param query

     *            Storage query

     * @param alias

     *            ElasticSearch alias

     * @param eventType

     *            Discriminator event type

     * @param eventField

     *            Discriminator event value

     */

    Metric fetchMetric(IQuery query, String alias, String eventType, String eventField);



    Map<String, Metric> fetchMetricsByInstance(IQuery query, String itemType, String valueField, String instanceField) throws WorkerException;



    Map<DateTime, CapacityPoint> fetchCapacityByDate(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException;



    List<Queryable> update(final List<Queryable> items) throws WorkerException;



    Queryable update(final Queryable item) throws WorkerException;



    void delete(final Queryable item);



    void delete(IQuery query);

}

package sgcib.tmon.worker.common.store.queryable;



import java.util.ArrayList;

import java.util.Collections;

import java.util.List;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



import org.joda.time.DateTime;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.processor.metric.CapacityPoint;

import sgcib.tmon.worker.common.processor.metric.CapacityScope;

import sgcib.tmon.worker.common.store.MemoryStore;



import com.google.common.collect.ImmutableList;

import com.google.common.collect.Lists;



/**

* Created by Stephane on 16/02/2015.

*/



public class MemoryQueryableStore extends ManageableBase implements IQueryableStore {

    private final Map<String, MemoryStore<Queryable>> itemStore = new ConcurrentHashMap<String, MemoryStore<Queryable>>(10);



    public MemoryQueryableStore() {

        super("MemoryQueryableStore");

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public List<Queryable> save(List<Queryable> items) throws WorkerException {

        if (items != null && items.size() > 0) {

            for (Queryable item : items) {

                save(item);

            }

            return ImmutableList.copyOf(items);

        }

        return Collections.emptyList();

    }



    @Override

    public Queryable save(Queryable item) throws WorkerException {

        if (item != null) {

            MemoryStore<Queryable> store = null;

            Object var = item.getType();

            if (!itemStore.containsKey(var)) {

                store = new MemoryStore<Queryable>();

                itemStore.put(item.getType(), store);

            } else {

                store = itemStore.get(item.getType());

            }



            if (store != null) {

                store.save(item.getId(), item);

            }

        }

        return item;

    }



    @Override

    public List<Queryable> fetch(IQuery query) throws WorkerException {

        ImmutableList.Builder<Queryable> builder = new ImmutableList.Builder<Queryable>();

        List<MemoryStore<Queryable>> stores = Lists.newArrayList(itemStore.values());

        for (MemoryStore store : stores) {

            if (store != null) {

                List<Queryable> items = store.readAll();

                for (Queryable item : items) {

                    if (query.match(item)) {

                        builder.add(item);

                    }

                }

            }

        }

        return builder.build();

    }



    @Override

    public Metric fetchMetric(IQuery query, String alias, String itemType, String valueField) throws WorkerException {

        Metric metric = new Metric(itemType);

        MemoryStore store = itemStore.get(itemType);

        if (store != null) {

            List<Queryable> items = store.readAll();

            for (Queryable item : items) {

                if (query.match(item)) {

                    Object value = item.getValue(valueField);

                    if (value != null) {

                        metric.add(Double.valueOf(value.toString()));

                    }

                }

            }

        }

        return metric;

    }



    @Override

    public Map<String, Metric> fetchMetricsByInstance(IQuery query, String itemType, String valueField, String instanceField) throws WorkerException {

        Map<String, Metric> metrics = new ConcurrentHashMap<>();



        MemoryStore store = itemStore.get(itemType);

        if (store != null) {

            List<Queryable> items = store.readAll();

            for (Queryable item : items) {

                if (query.match(item)) {

                    Object instance = item.getValue(instanceField);

                    if (instance != null) {

                        Metric metric = metrics.get(instance.toString());

                        if (metric == null) {

                            metric = new Metric(instance.toString());

                            metrics.put(instance.toString(), metric);

                        }

                        Object value = item.getValue(valueField);

                        if (value != null) {

                            metric.add(Double.valueOf(value.toString()));

                        }

                    }

                }

            }

        }

        return metrics;

    }



    @Override

    public Map<DateTime, CapacityPoint> fetchCapacityByDate(IQuery query, String eventType, String eventName, String eventField, CapacityScope periodScope, int periodDuration) throws WorkerException {

        // TODO

        return null;

    }



    @Override

    public List<Queryable> update(List<Queryable> items) throws WorkerException {

        if (items != null && items.size() > 0) {

            for (Queryable item : items) {

                update(item);

            }

            return ImmutableList.copyOf(items);

        }

        return Collections.emptyList();

    }



    @Override

    public Queryable update(Queryable item) throws WorkerException {

        MemoryStore store = itemStore.get(item.getType());

        if (store != null) {

            store.update(item.getId(), item);

        }

        return item;

    }



    @Override

    public void delete(Queryable item) {

        MemoryStore store = itemStore.get(item.getType());

        if (store != null) {

            store.delete(item.getId());

        }

    }



    @Override

    public void delete(IQuery query) {

        List<MemoryStore<Queryable>> stores = new ArrayList<>(itemStore.values());

        for (MemoryStore store : stores) {

            if (store != null) {

                List<Queryable> items = store.readAll();

                for (Queryable item : items) {

                    if (query.match(item)) {

                        store.delete(item.getName());

                    }

                }

            }

        }

    }



}

package sgcib.tmon.worker.common.store.queryable;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.StorageManager;



import java.util.Map;



/**

* Created by Stephane on 16/05/2015.

*/

public class QueryableStore extends GenericQueryableStore<Queryable> implements IQueryableStore {



    public QueryableStore(String name, StorageManager storageManager) {

        super(name, storageManager);

    }



    public QueryableStore(String name, StorageManager storageManager, boolean useDateInIndex, boolean useTypeIndex, String indexPattern, String indexAlias) {

        super(name, storageManager, useDateInIndex, useTypeIndex, indexPattern, indexAlias);

    }



    @Override

    protected Queryable buidItem(Map data) {

        return new Queryable(data);

    }



    @Override

    public void start() throws WorkerException {

        getLogger().info("Elasticsearch.QueryableStore has started");

        super.start();

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {

        getLogger().info("Elasticsearch.QueryableStore has stopped");

        super.stop();

    }

}



package sgcib.tmon.worker.common.store.sla;



import java.util.List;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.ServiceLevelAgreement;



public interface IServiceLevelAgreementStore extends IManageable {



    @Override

    String getName();



    void create(ServiceLevelAgreement serviceLevelAgreement) throws WorkerException;



    void create(List<ServiceLevelAgreement> serviceLevelAgreements) throws WorkerException;



    void delete(ServiceLevelAgreement serviceLevelAgreement) throws WorkerException;



    ServiceLevelAgreement read(String name) throws WorkerException;



    List<ServiceLevelAgreement> fetch(IQuery query) throws WorkerException;



    List<ServiceLevelAgreement> getAllAgreements() throws WorkerException;



    ServiceLevelAgreement update(String name, ServiceLevelAgreement serviceLevelAgreement) throws WorkerException;

}

package sgcib.tmon.worker.common.store.sla;



import com.google.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.ServiceLevelAgreement;

import sgcib.tmon.worker.common.store.MemoryStore;



import java.util.List;



/**

* Created by Stephane on 16/05/2015.

*/

public class MemoryServiceLevelAgreementStore extends ManageableBase implements IServiceLevelAgreementStore {



    private final MemoryStore<ServiceLevelAgreement> store;



    public MemoryServiceLevelAgreementStore() {

        super("MemoryServiceLevelAgreementStore");

        this.store = new MemoryStore<>();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public void create(ServiceLevelAgreement serviceLevelAgreement) throws WorkerException {

        store.save(serviceLevelAgreement.getName(), serviceLevelAgreement);

    }



    @Override

    public void create(List<ServiceLevelAgreement> serviceLevelAgreements) throws WorkerException {

        for (ServiceLevelAgreement serviceLevelAgreement : serviceLevelAgreements) {

            create(serviceLevelAgreement);

        }

    }



    @Override

    public void delete(ServiceLevelAgreement serviceLevelAgreement) throws WorkerException {

        store.delete(serviceLevelAgreement.getName());

    }



    @Override

    public ServiceLevelAgreement read(String name) throws WorkerException {

        return store.read(name);

    }



    @Override

    public List<ServiceLevelAgreement> fetch(IQuery query) throws WorkerException {

        ImmutableList.Builder<ServiceLevelAgreement> builder = new ImmutableList.Builder<ServiceLevelAgreement>();

        List<ServiceLevelAgreement> serviceLevelAgreements = store.readAll();

        if (serviceLevelAgreements != null && serviceLevelAgreements.size() > 0) {

            for (ServiceLevelAgreement serviceLevelAgreement : serviceLevelAgreements) {

                if (query.match(serviceLevelAgreement)) {

                    builder.add(serviceLevelAgreement);

                }

            }

        }

        return builder.build();

    }



    @Override

    public List<ServiceLevelAgreement> getAllAgreements() throws WorkerException {

        return store.readAll();

    }



    @Override

    public ServiceLevelAgreement update(String name, ServiceLevelAgreement serviceLevelAgreement) throws WorkerException {

        store.update(name, serviceLevelAgreement);

        return serviceLevelAgreement;

    }

}

package sgcib.tmon.worker.common.store.sla;



import java.util.List;

import java.util.Map;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.BasicServiceLevelAgreement;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.ServiceLevelAgreement;

import sgcib.tmon.worker.common.model.ServiceLevelAgreementType;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



public class ServiceLevelAgreementStore extends GenericQueryableStore<ServiceLevelAgreement> implements IServiceLevelAgreementStore {



    public ServiceLevelAgreementStore(StorageManager storageManager) {

        super("ServiceLevelAgreementStore", storageManager, false, false, "serviceLevelAgreement", "serviceLevelAgreements");

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {



    }



    @Override

    protected ServiceLevelAgreement buidItem(Map data) {

        String serviceLevelAgreementTypeAsString = (String) data.get(ServiceLevelAgreement.serviceLevelAgreementType);

        if (serviceLevelAgreementTypeAsString != null) {

            ServiceLevelAgreementType serviceLevelAgreementType = ServiceLevelAgreementType.valueOf(serviceLevelAgreementTypeAsString);

            switch (serviceLevelAgreementType) {

            case Basic:

                return new BasicServiceLevelAgreement(data);

            default:

                break;

            }

        }

        return null;

    }



    @Override

    public void create(ServiceLevelAgreement serviceLevelAgreement) throws WorkerException {

        // Override "key" attribute with SLA name.

        serviceLevelAgreement.put(ServiceLevelAgreement.key, serviceLevelAgreement.getName());

        super.save(serviceLevelAgreement);

    }



    @Override

    public void create(List<ServiceLevelAgreement> serviceLevelAgreements) throws WorkerException {

        super.save(serviceLevelAgreements);

    }



    @Override

    public ServiceLevelAgreement read(String name) throws WorkerException {

        return super.fetch(name);

    }



    @Override

    public List<ServiceLevelAgreement> getAllAgreements() throws WorkerException {

        return super.fetch(new Query());

    }



    @Override

    public ServiceLevelAgreement update(String name, ServiceLevelAgreement serviceLevelAgreement) throws WorkerException {

        // Override "key" attribute with SLA name.

        serviceLevelAgreement.put(ServiceLevelAgreement.key, name);

        return super.update(serviceLevelAgreement);

    }



}

package sgcib.tmon.worker.common.store.users;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.User;



import java.util.List;



/**

* Created by ekolonis120213 on 04/02/14.

*/



public interface IUserStore extends IManageable {



    User create(User user) throws WorkerException;



    User read(String email) throws WorkerException;



    boolean ckeckLogin(String email, String password) throws WorkerException;



    User update(User user) throws WorkerException;



    void delete(User user) throws WorkerException;



    List<User> getAllUsers() throws WorkerException;

}

package sgcib.tmon.worker.common.store.users;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.User;

import sgcib.tmon.worker.common.store.MemoryStore;



import java.util.List;



/**

* Created by slopes041604 on 12/06/2015.

*/

public class MemoryUserStore extends ManageableBase implements IUserStore {



    private final MemoryStore<User> store;



    public MemoryUserStore() {

        super("MemoryUserStore");

        store = new MemoryStore<User>();

    }



    @Override

    public User create(User user) throws WorkerException {

        store.save(user.getId(), user);

        return user;

    }



    @Override

    public User read(String email) throws WorkerException {

        return store.read(email);

    }



    @Override

    public boolean ckeckLogin(String email, String password) throws WorkerException {

        User user = store.read(email);

        if (user != null && user.getPassword().equals(password)) {

            return true;

        } else {

            return false;

        }

    }



    @Override

    public User update(User user) throws WorkerException {

        store.update(user.getId(), user);

        return user;

    }



    @Override

    public void delete(User user) throws WorkerException {

        store.delete(user.getId());

    }



    @Override

    public List<User> getAllUsers() throws WorkerException {

        return store.readAll();

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



}

package sgcib.tmon.worker.common.store.users;



import org.springframework.security.core.authority.SimpleGrantedAuthority;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.User;

import sgcib.tmon.worker.common.store.StorageManager;

import sgcib.tmon.worker.common.store.queryable.GenericQueryableStore;



import java.util.*;



/**

* Created by ekolonis120213 on 04/02/14.

*/

public class UserStore extends GenericQueryableStore<User> implements IUserStore {



    public UserStore(String name, StorageManager storageManager) {

        super("UserStore", storageManager, false, false, "user", "users");

    }



    @Override

    public void start() throws WorkerException {

        super.start();



        User adminUser = read("tmon.admin@sgcib.com");

        if (adminUser == null) {

            adminUser = new User();

            adminUser.setEmail("tmon.admin@sgcib.com");

            adminUser.setPassword("$2a$05$i6giSwzpyuXDJ2DxXULKo.bDS8hmV7UqmO/XrkiVVgNVYIo3E90vO");

            adminUser.setRole("ROLE_ADMIN");

            Collection<SimpleGrantedAuthority> simpleGrantedAuthorities = Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"), new SimpleGrantedAuthority("ROLE_ADMIN"));

            adminUser.setAuthorities(new HashSet<SimpleGrantedAuthority>(simpleGrantedAuthorities));

            save(adminUser);

        }

    }



    @Override

    protected void checkMapping(String index) throws WorkerException {



    }



    @Override

    protected User buidItem(Map data) {

        return new User(data);

    }



    @Override

    public User create(User user) throws WorkerException {

        return super.save(user);

    }



    @Override

    public User read(String email) throws WorkerException {

        return super.fetch(email);

    }



    @Override

    public boolean ckeckLogin(String email, String password) throws WorkerException {

        User user = super.fetch(email);

        if (user != null && user.getPassword().equals(password)) {

            return true;

        } else {

            return false;

        }

    }



    @Override

    public List<User> getAllUsers() throws WorkerException {

        return super.fetch(new Query());

    }

}

package sgcib.tmon.worker.common.task.publisher;



import javax.jms.JMSException;

import javax.jms.TextMessage;



import sgcib.arc.eai.jms.emswrapper.EMSWrapper;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;



/**

* Created by adouangp012014 on 10/07/2015.

*/

public class EmsPublisher extends ManageableBase implements IPublisher {



    private EMSWrapper emsWrapper;

    private EmsWrapperConfiguration emsWrapperConfiguration;



    // Message option in sendMessageToTopic method

    private long timeToLive;

    private boolean persistent;



    public EmsPublisher(String name, EmsWrapperConfiguration emsWrapperConfiguration, long timeToLive, boolean persistent) {

        super(name);



        this.emsWrapperConfiguration = emsWrapperConfiguration;

        this.timeToLive = timeToLive;

        this.persistent = persistent;

    }



    @Override

    public void start() throws WorkerException {



        getLogger().info("Starting EMS publisher...");



        emsWrapper = new EMSWrapper(false);



        emsWrapper.setAppName(emsWrapperConfiguration.getAppName());

        emsWrapper.setVersion(emsWrapperConfiguration.getVersion());

        emsWrapper.setCertificatePath(emsWrapperConfiguration.getCertificatePath());

        emsWrapper.setLogin(emsWrapperConfiguration.getLogin());

        emsWrapper.setPassword(emsWrapperConfiguration.getPassword());

        emsWrapper.setReplyPrefix(emsWrapperConfiguration.getReplyPrefix());

        emsWrapper.setConnectionFactoryName(emsWrapperConfiguration.getConnectionFactoryName());

        emsWrapper.setOther(emsWrapperConfiguration.getOther());

        emsWrapper.setJndiProps(emsWrapperConfiguration.getJndiProps());



        // Force connection initialisation, to detect errors ASAP

        emsWrapper.getConnection();

    }



    @Override

    public void stop() throws WorkerException {

        try {

            getLogger().info("Stopping EMS publisher...");

            emsWrapper.close();

        } catch (JMSException e) {

            getLogger().error("Error while stopping", e);

        }

    }



    @Override

    public Queryable send(String topic, Queryable item) {



        try {

            // create the message

            TextMessage tm = emsWrapper.createTextMessage();



            tm.setText(item.toJSON());



            // send the message

            emsWrapper.sendMessageToTopic(tm, topic, timeToLive, persistent);



        } catch (JMSException e) {

            getLogger().error("Error while sending the message", e);

       }



        return item;

    }



    public EMSWrapper getEmsWrapper() {

        return emsWrapper;

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.concurrent.ConcurrentLinkedQueue;

import java.util.concurrent.ExecutorService;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.utils.OptionalObjectUtils;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



/**

* Created by adouangp012014 on 10/07/2015.

*/

public class EmsPublisherTask extends PublisherTaskBase implements IEmsConstant {



    private static final long DEFAULT_TTL = 5000l;

    private static final boolean DEFAULT_PERSISTENT = false;



    EmsWrapperConfiguration emsWrapperConfiguration;

    private long timeToLive;

    private boolean persistent;



    public EmsPublisherTask(PublisherConfiguration configuration,  IAlertManager alertManager) {

        super(configuration, alertManager);



        this.alertManager = alertManager;

        emsWrapperConfiguration = new EmsWrapperConfiguration() //

                .setAppName((String) configuration.get(appNameField)) //

                .setTopic(configuration.getTopic()) //

                .setVersion((String) configuration.get(versionField)) //

                .setCertificatePath((String) configuration.get(certificatePathField)) //

                .setLogin((String) configuration.get(loginField)) //

                .setPassword((String) configuration.get(passwordField)) //

                .setReplyPrefix((String) configuration.get(replyPrefixField)) //

                .setConnectionFactoryName((String) configuration.get(connectionFactoryNameField)) //

                .setOther((String) configuration.get(otherField)) //

                .setJavaNamingFactoryInitial((String) configuration.get(javaNamingFactoryInitialField)) //

                .setTibjmsUrlList((String) configuration.get(tibjmsUrlListField)) //

                .setTibjmsSslVendor((String) configuration.get(tibjmsSslVendorField)) //

                .setTibjmsSecurityProtocol((String) configuration.get(tibjmsSecurityProtocolField)) //

                .setTibjmsSslDebugTrace((String) configuration.get(tibjmsSslDebugTraceField)) //

                .setTibjmsSslEnableVerifyHost((String) configuration.get(tibjmsSslEnableVerifyHostField)) //

                .setTibjmsSslEnableVerifyHostname((String) configuration.get(tibjmsSslEnableVerifyHostnameField)) //

                .setTibjmsSslExpectedHostname((String) configuration.get(tibjmsSslExpectedHostnameField)) //

                .setTibjmsSslCipherSuites((String) configuration.get(tibjmsSslCipherSuitesField));



        timeToLive = OptionalObjectUtils.longValue(configuration.get(timeToLiveField), DEFAULT_TTL);

        persistent = OptionalObjectUtils.booleanValue(configuration.get(persistentField), DEFAULT_PERSISTENT);

    }



    @Override

    public IPublisher build() {

        return new EmsPublisher(getName(), emsWrapperConfiguration, timeToLive, persistent);

    }



    @Override

    public String getErrorField() {

        return "emsPublisherError";

    }



    public ConcurrentLinkedQueue<IPublisher> getPublishers() {

        return publishers;

    }



}

package sgcib.tmon.worker.common.task.publisher;



import java.util.Properties;



/**

* This class regroup all properties need in the used of EMSWrapper

*/

public class EmsWrapperConfiguration {



    private String appName;

    private String version;

    private String certificatePath;

    private String login;

    private String password;

    private String replyPrefix;

    private String connectionFactoryName;

    private String other;

    private String topic;



    //JNDI properties

    private String javaNamingFactoryInitial;

    private String tibjmsUrlList;

    private String tibjmsSslVendor;

    private String tibjmsSecurityProtocol;

    private String tibjmsSslDebugTrace;

    private String tibjmsSslEnableVerifyHost;

    private String tibjmsSslEnableVerifyHostname;

    private String tibjmsSslExpectedHostname;

    private String tibjmsSslCipherSuites;



    public EmsWrapperConfiguration() {



    }



    public String getAppName() {

        return appName;

    }



    public EmsWrapperConfiguration setAppName(String appName) {

        this.appName = appName;

        return this;

    }



    public String getVersion() {

        return version;

    }



    public EmsWrapperConfiguration setVersion(String version) {

        this.version = version;

        return this;

    }



    public String getCertificatePath() {

        return certificatePath;

    }



    public EmsWrapperConfiguration setCertificatePath(String certificatePath) {

        this.certificatePath = certificatePath;

        return this;

    }



    public String getLogin() {

        return login;

    }



    public EmsWrapperConfiguration setLogin(String login) {

        this.login = login;

        return this;

    }



    public String getPassword() {

        return password;

    }



    public EmsWrapperConfiguration setPassword(String password) {

        this.password = password;

        return this;

    }



    public String getReplyPrefix() {

        return replyPrefix;

    }



    public EmsWrapperConfiguration setReplyPrefix(String replyPrefix) {

        this.replyPrefix = replyPrefix;

        return this;

    }



    public String getTopic() {

        return topic;

    }



    public EmsWrapperConfiguration setTopic(String topic) {

        this.topic = topic;

        return this;

    }



    public String getConnectionFactoryName() {

        return connectionFactoryName;

    }



    public EmsWrapperConfiguration setConnectionFactoryName(String connectionFactoryName) {

        this.connectionFactoryName = connectionFactoryName;

        return this;

    }



    public String getOther() {

        return other;

    }



    public EmsWrapperConfiguration setOther(String other) {

        this.other = other;

        return this;

    }



    public Properties getJndiProps() {



        Properties jndiProps = new Properties();



        jndiProps.put("java.naming.factory.initial", getJavaNamingFactoryInitial());

        jndiProps.put("com.tibco.tibjms.naming.url.list", getTibjmsUrlList());

        jndiProps.put("com.tibco.tibjms.naming.ssl_vendor", getTibjmsSslVendor());

        jndiProps.put("com.tibco.tibjms.naming.security_protocol", getTibjmsSecurityProtocol());

        jndiProps.put("com.tibco.tibjms.naming.ssl_debug_trace", getTibjmsSslDebugTrace());

        jndiProps.put("com.tibco.tibjms.naming.ssl_enable_verify_host", getTibjmsSslEnableVerifyHost());

        jndiProps.put("com.tibco.tibjms.naming.ssl_enable_verify_hostname", getTibjmsSslEnableVerifyHostname());

        jndiProps.put("com.tibco.tibjms.naming.ssl_expected_hostname", getTibjmsSslExpectedHostname());

        jndiProps.put("com.tibco.tibjms.naming.ssl_cipher_suites", getTibjmsSslCipherSuites());



       return jndiProps;

    }



    public String getJavaNamingFactoryInitial() {

        return javaNamingFactoryInitial;

    }



    public EmsWrapperConfiguration setJavaNamingFactoryInitial(String javaNamingFactoryInitial) {

        this.javaNamingFactoryInitial = javaNamingFactoryInitial;

        return this;

    }



    public String getTibjmsUrlList() {

        return tibjmsUrlList;

    }



    public EmsWrapperConfiguration setTibjmsUrlList(String tibjmsUrlList) {

        this.tibjmsUrlList = tibjmsUrlList;

        return this;

    }



    public String getTibjmsSslVendor() {

        return tibjmsSslVendor;

    }



    public EmsWrapperConfiguration setTibjmsSslVendor(String tibjmsSslVendor) {

        this.tibjmsSslVendor = tibjmsSslVendor;

        return this;

    }



    public String getTibjmsSecurityProtocol() {

        return tibjmsSecurityProtocol;

    }



    public EmsWrapperConfiguration setTibjmsSecurityProtocol(String tibjmsSecurityProtocol) {

        this.tibjmsSecurityProtocol = tibjmsSecurityProtocol;

        return this;

    }



    public String getTibjmsSslDebugTrace() {

        return tibjmsSslDebugTrace;

    }



    public EmsWrapperConfiguration setTibjmsSslDebugTrace(String tibjmsSslDebugTrace) {

        this.tibjmsSslDebugTrace = tibjmsSslDebugTrace;

        return this;

    }



    public String getTibjmsSslEnableVerifyHost() {

        return tibjmsSslEnableVerifyHost;

    }



    public EmsWrapperConfiguration setTibjmsSslEnableVerifyHost(String tibjmsSslEnableVerifyHost) {

        this.tibjmsSslEnableVerifyHost = tibjmsSslEnableVerifyHost;

        return this;

    }



    public String getTibjmsSslEnableVerifyHostname() {

        return tibjmsSslEnableVerifyHostname;

    }



    public EmsWrapperConfiguration setTibjmsSslEnableVerifyHostname(String tibjmsSslEnableVerifyHostname) {

        this.tibjmsSslEnableVerifyHostname = tibjmsSslEnableVerifyHostname;

        return this;

    }



    public String getTibjmsSslExpectedHostname() {

        return tibjmsSslExpectedHostname;

    }



    public EmsWrapperConfiguration setTibjmsSslExpectedHostname(String tibjmsSslExpectedHostname) {

        this.tibjmsSslExpectedHostname = tibjmsSslExpectedHostname;

        return this;

    }



    public String getTibjmsSslCipherSuites() {

        return tibjmsSslCipherSuites;

    }



    public EmsWrapperConfiguration setTibjmsSslCipherSuites(String tibjmsSslCipherSuites) {

        this.tibjmsSslCipherSuites = tibjmsSslCipherSuites;

        return this;

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.io.IOException;

import java.util.Arrays;

import java.util.Collection;

import java.util.LinkedHashMap;

import java.util.LinkedHashSet;

import java.util.Map;

import java.util.Set;

import java.util.concurrent.ConcurrentHashMap;



import sgcib.tmon.worker.common.model.Queryable;



import com.fasterxml.jackson.databind.ObjectMapper;



public class GeneosAlert {

    public static final String DYNAMIC_FIELD_NAME = "other";

    public static final String ROW_FIELD_NAME = "key";

    public static final String COMPONENT_FIELD_NAME = "component";



    // Row field name must be added first, because the first field on Geneos

    // side must be the row

    public static final String REQUIRED_FIELDS[] = { ROW_FIELD_NAME, DYNAMIC_FIELD_NAME, COMPONENT_FIELD_NAME };



    public static final String DEFAULT_FIELD_VALUE = "";



    // Dynamic field special characters

    private static final char ENTRY_SEPARATOR = ';';

    private static final char ENTRY_LINK = '=';

    private static final char ENTRY_SAFECHAR = '_';

    private static final char ENTRY_SUBFIELD_SEPARATOR = '.';



    // Used to parse json fields

    private static final ObjectMapper jsonMapper = new ObjectMapper();



    protected static String DEFAULT_COMPONENT = "No component";



    // Field names must keep the order of insertion and be unique, hence the

    // LinkedHashSet

    private static Map<String, LinkedHashSet<String>> fieldsByComponent = new ConcurrentHashMap<>();

    private static LinkedHashSet<String> defaultFields = createFields();

    private LinkedHashMap<String, String> fields;



    /**

     * Creates a GeneosAlert from the given Queryable. Data will be validated,

     * and an IllegalArgumentException might be thrown if a field is missing or

     * duplicated

     *

     * @param item

     *            The queryable to send

     */

    public GeneosAlert(Queryable item) throws IllegalArgumentException {

        this.fields = new LinkedHashMap<>();

        String component = (String) item.getValue(COMPONENT_FIELD_NAME);

        initializeFields(getFieldsForComponent(component));

        fillFieldsFromQueryable(item);

        validateRequiredFields();

    }



    /**

     * Replace the old default component value by this value

     *

     * @param newDefault

     *            the new default component

     */

    public static void changeDefaultComponent(String newDefault) {

        DEFAULT_COMPONENT = newDefault;

    }



    /**

     * Remove all specific fields for each component. As a result, every

     * component will use default fields

     */

    public static void resetFieldsForComponents() {

        fieldsByComponent.clear();

    }



    /**

     * Add a list of fields for the specified component. If the component is

     * already known, the previous list of fields will be overwritten. The list

     * of fields will be validated.

     *

     * @param component

     *            The component for which the list of fields will be added

     * @param fields

     *            The list of fields for the component. Required fields will be

     *            added to this.

     */

    public static void addFieldsForComponent(String component, Collection<String> fields) {

        fieldsByComponent.put(component, createFields(fields));

    }



    /**

     * Returns the fields set for the given component. If no specific fields are

     * set, the defaults fields are returned.

     *

     * @param component

     *            Alert component, linked to a view in Geneos

     * @return THe fields linked to the given component, or default fields.

     */

    public static LinkedHashSet<String> getFieldsForComponent(String component) {

        if (component == null) {

            return defaultFields;

        }

        LinkedHashSet<String> fieldsOfComponent = fieldsByComponent.get(component);

        if (fieldsOfComponent != null) {

            return fieldsOfComponent;

        }

        return defaultFields;

    }



    /**

     * @return the list of default required fields for a GeneosAlert

     */

    public static Set<String> getDefaultFields() {

        return defaultFields;

    }



    /**

     * Change the default fields list, used for unknown components. The list of

     * field will be validated, and required fields will be added.

     *

     * @param fields

     *            The list of fields to use as a default.

     */

    public static void setDefaultFields(Collection<String> fields) {

        defaultFields = createFields(fields);

    }



    /**

     * Create a field list, with correct constraints. I.E, required field will

     * be added, and the row name field will be first

     *

     * @return A validated field list with required fields and starting with a

     *         row name field.

     */

    private static LinkedHashSet<String> createFields() {

        LinkedHashSet<String> fieldsList = new LinkedHashSet<>();

        fieldsList.addAll(Arrays.asList(REQUIRED_FIELDS));

        return fieldsList;

    }



    /**

     * Create a field list, with correct constraints. I.E, required field will

     * be added, and the row name field will be first

     *

     * @param fields

     *            Fields used to create the resulting field list

     * @return A validated field list with required fields and starting with a

     *         row name field.

     */

    private static LinkedHashSet<String> createFields(Collection<String> fields) {

        LinkedHashSet<String> fieldsList = new LinkedHashSet<>();

        fieldsList.addAll(Arrays.asList(REQUIRED_FIELDS));

        fieldsList.addAll(fields);

        return fieldsList;

    }



    /**

     * @param fieldName

     *            Name of the field to retrieve

     * @return the value of the alert for the given field

    */

    public String getFieldValue(String fieldName) {

        return fields.get(fieldName);

    }



    /**

     * @return Name of the row associated with the alert.

     */

    public String getRowName() {

        return getFieldValue(ROW_FIELD_NAME);

    }



    public LinkedHashSet<String> getFields() {

        return new LinkedHashSet<String>(this.fields.keySet());

    }



    /**

     * Add a default value for the component field if it is not already filled

     */

    private void fillDefaultComponentIfNeeded() {

        String component = this.fields.get(COMPONENT_FIELD_NAME);

        if (component == null || component.equals(DEFAULT_FIELD_VALUE)) {

            this.fields.put(COMPONENT_FIELD_NAME, DEFAULT_COMPONENT);

        }

    }



    /**

     * Validate the fact that required fields are set. Component will be filled

     * with a default value if needed, and the dynamic field is ignored.

     *

     * @throws IllegalArgumentException

     *             if a required field is missing

     */

    private void validateRequiredFields() throws IllegalArgumentException {

        fillDefaultComponentIfNeeded();

        for (String field : REQUIRED_FIELDS) {

            if (field.equals(DYNAMIC_FIELD_NAME)) {

                continue;

            }

            String requiredFieldValue = this.fields.get(field);

            if (requiredFieldValue == null || requiredFieldValue.equals(DEFAULT_FIELD_VALUE)) {

                throw new IllegalArgumentException("Error while building a GeneosAlert. The field " + field + " is necessary and was not given.");

            }

        }

    }



    /**

     * Create all the fields in tre correct order for the alert. It is necessary

     * to do so before filling to keep the required order of fields

     *

     * @param fields

     *            An ordered list of fields to be created

     */

    private void initializeFields(LinkedHashSet<String> fields) {

        for (String field : fields) {

            this.fields.put(field, DEFAULT_FIELD_VALUE);

        }

    }



    /**

     * Fill all the GeneosAlert fields, using data from the given Queryable

     *

     * @param item

     *            Item from which data is retrieved

     * @throws IllegalArgumentException

     *             If there is duplication, or if the key field is missing

     */

    private void fillFieldsFromQueryable(Queryable item) throws IllegalArgumentException {

        for (Map.Entry<String, Object> entry : item.entrySet()) {

            if (!insertEntryInFields(entry.getKey(), entry.getValue().toString())) {

                throw new IllegalArgumentException("Error while building a GeneosAlert. The field " + entry.getKey() + " is already present.");

            }

        }

    }



    /**

     * @param input

     *            The string to sanitize

     * @return the string given in input, with the forbidden characters (link

     *         and separator for the dynamic field in Geneos) replaced by a safe

     *         character.

     */

    private String sanitizeString(String input) {

        return input.replace(ENTRY_SEPARATOR, ENTRY_SAFECHAR).replace(ENTRY_LINK, ENTRY_SAFECHAR);

    }



    private String insertEntry(String keyValue, String dynamicField) {

        if (dynamicField == null || dynamicField.isEmpty()) {

            return keyValue;

        }

        return dynamicField + ENTRY_SEPARATOR + keyValue;

    }



    private String insertKeyValue(String key, String value, String dynamicField) {

        return insertEntry(key + ENTRY_LINK + value, dynamicField);

    }



    private String concatenateFieldKeys(String parentKey, String newKey) {

        return parentKey + ENTRY_SUBFIELD_SEPARATOR + newKey;

    }



    private String flattenJsonField(String parentField, Map.Entry<String, Object> jsonField) {

        String fieldKey = concatenateFieldKeys(parentField, jsonField.getKey());



        if (!(jsonField.getValue() instanceof Map)) {

            return insertKeyValue(fieldKey, sanitizeString(jsonField.getValue().toString()), "");

        } else {

            return insertEntry(flattenJsonNest(fieldKey, (Map<String, Object>) jsonField.getValue()), "");

        }



    }



    private String flattenJsonNest(String parentField, Map<String, Object> jsonNest) {

        String flattenedJson = "";

        for (Map.Entry<String, Object> jsonField : jsonNest.entrySet()) {

            flattenedJson = insertEntry(flattenJsonField(parentField, jsonField), flattenedJson);

        }

        return flattenedJson;

    }



    /**

     * Try to parse and flatten the given JSon. JSon sub objects will be

     * flattened by creating a new field with a key similar to field.subfield

     *

     * @param key

     *            The field name of the whole JSon Object

     * @param value

     *            The Json string

     * @return The Json object, flattened and of the form field=value;

     * @throws IOException

     *             if value is not a valid JSon string

     */

    private String parseAsJson(String key, String value) throws IOException {

        Map<String, Object> jsonParsed = jsonMapper.readValue(value, Map.class);

        return flattenJsonNest(key, jsonParsed);

    }



    /**

     * Adds the given entry to the dynamic field. The entry will be correctly

     * formatted, and if the value given is in JSON, it will be flattened.

     *

     * @param key

     *            The field name to add

     * @param value

     *            The field value to add

     * @param dynamicField

     *            The dynamic field

     * @return the dynamic field with the new value added

     */

    private String addEntryToDynamicField(String key, String value, String dynamicField) {

        key = sanitizeString(key);

        try {

            String newFields = parseAsJson(key, value);

            return insertEntry(newFields, dynamicField);

        } catch (IOException e) {

            value = sanitizeString(value);

            return insertKeyValue(key, value, dynamicField);

        }

    }



    /**

     * Insert the given entry to the relevant field. If it is a required entry,

     * it will be added to its own field, otherwise it will be added to the

     * dynamic field.

     *

     * @param key

     *            The field name to add

     * @param value

     *            The field value to add

     * @return true if the value was added to the relevant entry, false

     *         otherwise

     */

    private boolean insertEntryInFields(String key, String value) {

        if (fields.containsKey(key) && !key.equals(DYNAMIC_FIELD_NAME)) {

            if (!fields.get(key).equals(DEFAULT_FIELD_VALUE)) {

                return false;

            }

            fields.put(key, value);

        } else {

            String dynamicField = fields.get(DYNAMIC_FIELD_NAME);

            dynamicField = addEntryToDynamicField(key, value, dynamicField);

            fields.put(DYNAMIC_FIELD_NAME, dynamicField);

        }

        return true;

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.ArrayList;

import java.util.Collection;

import java.util.HashSet;

import java.util.LinkedHashSet;

import java.util.List;

import java.util.Map;

import java.util.Set;

import java.util.concurrent.atomic.AtomicBoolean;



import sgcib.tmon.geneos.connector.GeneosConnectorException;

import sgcib.tmon.geneos.connector.GeneosException;

import sgcib.tmon.geneos.connector.GeneosItemExistsException;

import sgcib.tmon.geneos.connector.GeneosNoSuchItemException;

import sgcib.tmon.geneos.connector.MultipleViewsGeneosConnector;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.IClock;

import sgcib.tmon.worker.common.model.IDate;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.JodaClock;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;



public class GeneosPublisher extends ManageableBase implements IPublisher {



    protected static IClock clock = new JodaClock();

    private static AtomicBoolean connectionIsUp = new AtomicBoolean(true);

    private static AtomicBoolean resynchronising = new AtomicBoolean(false);

    private static IDate lastResynchro = clock.longTimeAgo();

    private final int maxRetries;

    private final int initialTimeBeforeRetry;

    protected MultipleViewsGeneosConnector connector;

    private IAlertManager alertManager;



    // Initialisation



    public GeneosPublisher(String name, GeneosWrapperConfiguration conf) {

        super(name);

        this.maxRetries = conf.getMaxAlertSendRetries();

        this.initialTimeBeforeRetry = conf.getInitialRetryTime();

        this.alertManager = conf.getAlertManager();

        initializeGeneosAlerts(conf);

        try {

            this.connector = new MultipleViewsGeneosConnector(conf.getNetprobeUrl(), conf.getManagedEntity(), conf.getSampler(), conf.getGroupHeading());

        } catch (GeneosException e) {

            getLogger().error("Error while creating the GeneosConnector", e);

        }

    }



    private void initializeGeneosAlerts(GeneosWrapperConfiguration conf) {

        GeneosAlert.changeDefaultComponent(conf.getDefaultComponent());

        GeneosAlert.setDefaultFields(conf.getDefaultFields());

        for (Map.Entry<String, LinkedHashSet<String>> entry : conf.getCustomFieldsForComponent().entrySet()) {

            getLogger().info("Adding field " + entry.getKey() + " with columns " + entry.getValue());

            GeneosAlert.addFieldsForComponent(entry.getKey(), entry.getValue());

        }

    }



    // Publisher



    @Override

    public Queryable send(String topic, Queryable item) {

        if (connectionIsUp.get()) {

            GeneosAlert alert = createGeneosAlertFromQueryable(item);

            if (alert != null) {

                connectionIsUp.set(trySendAlertToGeneos(alert));

            }

        }

        if (!connectionIsUp.get() || needDailyResynchronisation()) {

            resynchronise();

        }

        return item;

    }



    /**

     * Verify that Geneos is correctly set up, and create the View if needed

     *

     * @throws WorkerException

     */

    @Override

    public void start() throws WorkerException {

        getLogger().info(

                "Starting the Geneos service (netprobeUrl=" + this.connector.getNetprobeURL() + ", managedEntity=" + this.connector.getManagedEntity() + ", sampler=" + this.connector.getSampler() + ", groupHeading="

                        + this.connector.getGroupHeading() + ")");

        try {

            if (!geneosSetupIsValid()) {

                throw new WorkerException("Invalid Geneos setup.");

            }

        } catch (GeneosException e) {

            getLogger().error("Error while connecting to the Geneos netprobe", e);

        }

    }



    @Override

    public void stop() throws WorkerException {

    }



    // Geneos data sending



    private GeneosAlert createGeneosAlertFromQueryable(Queryable item) {

        try {

            return new GeneosAlert(item);

        } catch (IllegalArgumentException e) {

            getLogger().error("Error while building the Geneos Alert", e);

            return null;

        }

    }



    /**

     * Retry to send data to Geneos, in the case there was a problem. It will

     * retry "maxRetries" times, before giving up. Each retry will wait twice as

     * much as the precedent try, starting with "initialTimeBeforeRetries"

     *

     * @param alert

     *            The alert to send

     * @return true if it was sent, false it if still could not be sent after

     *         all the retries.

     */

    private boolean trySendAlertToGeneos(GeneosAlert alert) {

        for (int retryNumber = 0, timeBeforeRetry = this.initialTimeBeforeRetry; retryNumber < this.maxRetries; retryNumber++, timeBeforeRetry *= 2) {

            if (sendAlertToGeneos(alert)) {

                return true;

            }

            try {

                Thread.sleep(timeBeforeRetry);

            } catch (InterruptedException e) {

                getLogger().error("There was an issue while waiting before retrying to send a Geneos Alert", e);

            }

        }

        return false;

    }



    /**

     * Try sending an alert to Geneos. The display is prepared if needed.

     *

     * @param alert

     *            The alert to send to the netprobe

     * @return true if the alert has been sent, false if there was an issue

     *         during the creation of the display or the sending.

     */

    private boolean sendAlertToGeneos(GeneosAlert alert) {

        String view = alert.getFieldValue(GeneosAlert.COMPONENT_FIELD_NAME);

        try {

            prepareDisplay(view, alert);

            prepareTableRow(view, alert.getRowName());

            this.connector.updateTableRow(view, alert.getRowName(), alertToRow(alert));

            return true;

        } catch (GeneosException e) {

            getLogger().warn("There was an error while sending the alert " + alert.getRowName(), e);

            return false;

        }

    }



    /**

     * Convert an alert to a correctly formatted row.

     *

     * @param alert

     *            The alert to convert to a row

     * @return The row generated from the alert

     */

    private List<String> alertToRow(GeneosAlert alert) {

        List<String> row = new ArrayList<>();

        for (String field : alert.getFields()) {

            row.add(alert.getFieldValue(field));

        }

        row.remove(alert.getFieldValue(GeneosAlert.ROW_FIELD_NAME));

        return row;

    }



    private void waitUntilConnectionIsOk() {

        while (!hasConnection()) {

            try {

                Thread.sleep(initialTimeBeforeRetry << maxRetries);

            } catch (InterruptedException e) {

                getLogger().error("There was an issue while waiting for resynchronisation with Geneos", e);

            }

            getLogger().error("Connection lost with Geneos, synchronising");

        }

    }



    // Geneos display creation / handling



    /**

     * Check whether the Geneos setup is valid, i.e. if the given managed entity

     * and sampler exists

     *

     * @return true if the managed Entity and the sampler exists on the Gateway

     * @throws GeneosException

     *             if there is an error while connecting with Geneos

     */

    private boolean geneosSetupIsValid() throws GeneosException {

        if (!this.connector.managedEntityExists()) {

            getLogger().error("The managed entity " + this.connector.getManagedEntity() + " does not exists");

            return false;

        }

        if (!this.connector.samplerExists()) {

            getLogger().error("The sampler " + this.connector.getSampler() + " does not exists");

            return false;

        }

        return true;

    }



    /**

     * Check if the view exists on Geneos and contains the needed columns /

     * rows.If something is missing, it is created. The row field name should

     * imperatively be created first, due to the fact that Geneos fill the first

     * column with the name of the row and it can not be modified afterward. The

     * order of the fields is set in GeneosAlert

     *

     * @throws GeneosException

     *             if there is an error while connecting with Geneos

     */

    private void prepareDisplay(String view, GeneosAlert alert) throws GeneosException {

        prepareView(view);

        LinkedHashSet<String> fields = alert.getFields();

        for (String fieldName : fields) {

            prepareColumn(view, fieldName);

        }

    }



    /**

     * Check if the view defined in the object exists, and create it if needed.

     * We catch the exception if it's because the item already exists, because

     * it is to be expected at first.

     *

     * @param viewName

     *            Name of the view to prepare

     * @throws GeneosException

     *             if there is an error while connecting with Geneos

     */

    private synchronized void prepareView(String viewName) throws GeneosException {

        if (!this.connector.viewExists(viewName)) {

            getLogger().info("Creating view " + viewName);

            try {

                this.connector.createView(viewName);

            } catch (GeneosItemExistsException e) {

                getLogger().error(e.getMessage(), e);

                getLogger().warn("Could not create view " + viewName + ", because it already exists");

            }

        }

    }



    /**

     * Check if the given column exists, and create it if needed.

     *

     * @param columnHeading

     *            Name of the column to check and/or create

     * @throws GeneosException

     *             if there is an error while connecting with Geneos

     */

    private synchronized void prepareColumn(String viewName, String columnHeading) throws GeneosException {

        if (!this.connector.tableColumnExists(viewName, columnHeading)) {

            getLogger().info("Adding column " + columnHeading + " to view " + viewName);

            try {

                this.connector.addTableColumn(viewName, columnHeading);

            } catch (GeneosItemExistsException e) {

                getLogger().error(e.getMessage(), e);

                getLogger().warn("Could not create column " + columnHeading + " in view " + viewName + ", because it already exists");

            }

        }

    }



    /**

     * Check if the given row exists, and create it if needed.

     *

     * @param rowHeading

     *            Name of the row to check and/or create

     * @throws GeneosException

     *             if there is an error while connecting with Geneos

     */

    private synchronized void prepareTableRow(String viewName, String rowHeading) throws GeneosException {

        if (!this.connector.tableRowExists(viewName, rowHeading)) {

            getLogger().info("Adding row " + rowHeading + " to view " + viewName);

            try {

                this.connector.addTableRow(viewName, rowHeading);

            } catch (GeneosItemExistsException e) {

                getLogger().error(e.getMessage(), e);

                getLogger().warn("Could not create row " + rowHeading + " in view " + viewName + ", because it already exists");

            }

        }

    }



    // Wiping / resynchronisation



    /**

     * @return true if there has not been a resynchro since one day. This is one

     *         calendar day, not 24h, so it is not impossible to have a

     *         resynchro at 23:59 and one at 00:00

     */

    private boolean needDailyResynchronisation() {

        return clock.isYesterdayOrBefore(lastResynchro);

    }



    /**

     * Check whether there is a connection with Geneos by checking if the

     * Managed Entity exists

     *

     * @return true if there was a connection with the Netprobe, false

     *         otherwise.

     */

    private boolean hasConnection() {

        try {

            this.connector.managedEntityExists();

        } catch (GeneosNoSuchItemException e) {

            getLogger().error("A connection has been established with Geneos, however the expected managed entity " + this.connector.getManagedEntity() + " does not exists");

            return false;

        } catch (GeneosException e) {

            getLogger().error(e.getMessage(), e);

            getLogger().error("Could not connect to the netprobe " + this.connector.getNetprobeURL());

            return false;

        }

        return true;

    }



    /**

     * Return a Set containing one of each different component of the alerts

     * handled since the given date. Those component can designate views created

     * in Geneos. If an alert has no component, the default component is set.

     * There is no null value in the list.

     *

     * @return a collection of components existing in the alerts.

     */

    private Collection<String> getViewsCreatedSince(IDate dateSince) {

        Collection<Alert> alerts = getAlertsSince(dateSince);

        Set<String> views = new HashSet<>();

        for (Alert alert : alerts) {

            views.add(alert.getComponent());

        }

        if (views.contains(null)) {

            views.remove(null);

            views.add(GeneosAlert.DEFAULT_COMPONENT);

        }

        return views;

    }



    /**

     * Delete all the views created on Geneos side.

     *

     * @throws GeneosException

     */

    private void wipeViews() throws GeneosException {

        Collection<String> potentialViews = getViewsCreatedSince(clock.longTimeAgo());

        for (String view : potentialViews) {

            getLogger().info("Wiping view " + view);

            try {

                this.connector.removeView(view);

            } catch (GeneosNoSuchItemException e) {

                getLogger().error(e.getMessage(), e);

                getLogger().warn("Could not delete the view " + view + " because it does not exists.");

            }

        }

    }



    /**

     * @param dateSince

     *            date since which the alert must be retrieved

     * @return a collection of alerts since the given date

     */

    private Collection<Alert> getAlertsSince(IDate dateSince) {

        IQuery query = new Query().addCriterion(Queryable.timestamp, dateSince.toString(), QueryCriterionType.Before);

        return this.alertManager.getAlerts(query);

    }



    /**

     * Convert a Collection of alerts to Geneos Alerts. If an alert can not be

     * converted, it is ignored.

     *

     * @param alerts

     *            The alerts to be converted to Geneos Alert

     * @return The corresponding collection of Geneos Alerts

     */

    private Collection<GeneosAlert> alertsToGeneosAlerts(Collection<Alert> alerts) {

        List<GeneosAlert> geneosAlerts = new ArrayList<>(alerts.size());

        for (Alert alert : alerts) {

            GeneosAlert geneosAlert = createGeneosAlertFromQueryable(alert);

            if (geneosAlert != null) {

                geneosAlerts.add(geneosAlert);

            }

        }

        return geneosAlerts;

    }



    /**

     * Try to resynchronise with the Geneos netprobe. The views will be wiped

     * and all recent alerts will be sent back. In case of error after the

     * connection has been reestablished, synchronisation is aborted and must be

     * tried again.

     */

    private void resynchronise() {

        if (!resynchronising.compareAndSet(false, true)) {

            return;

        }

        try {

            waitUntilConnectionIsOk();

            wipeViews();

            connectionIsUp.set(true);

            reSendAlertsToGeneos();

            lastResynchro = clock.now();

        } catch (GeneosException e) {

            connectionIsUp.set(false);

            getLogger().error("There was an issue during the resynchronisation with Geneos", e);

        } finally {

            resynchronising.set(false);

        }

    }



    /**

     * Re send every alerts from the last 24h.

     *

     * @throws GeneosConnectorException

     *             If an alert can not be sent

     */

    private void reSendAlertsToGeneos() throws GeneosConnectorException {

        Collection<GeneosAlert> alerts = alertsToGeneosAlerts(getAlertsSince(clock.yesterday()));

        for (GeneosAlert alert : alerts) {

            if (!trySendAlertToGeneos(alert)) {

                throw new GeneosConnectorException("Error while sending back alerts");

            }

        }

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.List;

import java.util.Map;

import java.util.Optional;



import org.elasticsearch.common.collect.Lists;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



public class GeneosPublisherTask extends PublisherTaskBase {

    public static final String netprobeUrlField = "netprobeUrl";

    public static final String managedEntityField = "managedEntity";

    public static final String samplerField = "sampler";

    public static final String groupHeadingField = "groupHeading";

    public static final String componentField = "components";



    private static final String errorField = "geneosPublisherError";

    private GeneosWrapperConfiguration geneosWrapperConfiguration;



    public GeneosPublisherTask(PublisherConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);



        @SuppressWarnings("unchecked")

        // Optional components

        List<Map<String, Object>> components = (List<Map<String, Object>>) //

        Optional.ofNullable(configuration.get(GeneosPublisherTask.componentField)).orElse(Lists.newArrayList());



        geneosWrapperConfiguration = new GeneosWrapperConfiguration( //

                (String) configuration.get(GeneosPublisherTask.netprobeUrlField), //

                (String) configuration.get(GeneosPublisherTask.managedEntityField), //

                (String) configuration.get(GeneosPublisherTask.samplerField), //

                (String) configuration.get(GeneosPublisherTask.groupHeadingField), //

                alertManager, components);

        getLogger().info("==================");

        getLogger().info(geneosWrapperConfiguration.getCustomFieldsForComponent().toString());

        getLogger().info("==================");

    }



    @Override

    public IPublisher build() {

        return new GeneosPublisher(getName(), geneosWrapperConfiguration);

    }



    @Override

    public String getErrorField() {

        return GeneosPublisherTask.errorField;

    }

}package sgcib.tmon.worker.common.task.publisher;



import java.util.Collection;

import java.util.LinkedHashSet;

import java.util.List;

import java.util.Map;



import scala.actors.threadpool.Arrays;

import sgcib.tmon.worker.common.alert.IAlertManager;



import com.google.common.collect.Maps;



public class GeneosWrapperConfiguration {

    public static final String DEFAULT_FIELDS = "type,name,@timestamp";

    private static final String FIELDS_SEPARATOR = ",";

    private static final int DEFAULT_TIME_BEFORE_RETRY = 1000;

    private static final int DEFAULT_MAX_RETRIES = 5;

    private static final String DEFAULT_COMPONENT = "No component";



    private final String netprobeUrl;

    private final String managedEntity;

    private final String sampler;

    private final String groupHeading;

    private final LinkedHashSet<String> defaultFields;

    private final Map<String, LinkedHashSet<String>> customFieldsForComponent = Maps.newHashMap();

    private final IAlertManager alertManager;

    private int maxAlertSendRetries;

    private int initialRetryTime;

    private String defaultComponent;



    public GeneosWrapperConfiguration(String netprobeUrl, String managedEntity, String sampler, String groupHeading, IAlertManager alertManager) {

        this.netprobeUrl = netprobeUrl;

        this.managedEntity = managedEntity;

        this.sampler = sampler;

        this.groupHeading = groupHeading;

        this.maxAlertSendRetries = DEFAULT_MAX_RETRIES;

        this.initialRetryTime = DEFAULT_TIME_BEFORE_RETRY;

        this.defaultComponent = DEFAULT_COMPONENT;

        this.defaultFields = splitFields(DEFAULT_FIELDS);

        this.alertManager = alertManager;

    }



    public GeneosWrapperConfiguration(String netprobeUrl, String managedEntity, String sampler, String groupHeading, IAlertManager alertManager, List<Map<String, Object>> customFieldsForComponent) {

        this.netprobeUrl = netprobeUrl;

        this.managedEntity = managedEntity;

        this.sampler = sampler;

        this.groupHeading = groupHeading;

        this.maxAlertSendRetries = DEFAULT_MAX_RETRIES;

        this.initialRetryTime = DEFAULT_TIME_BEFORE_RETRY;

        this.defaultComponent = DEFAULT_COMPONENT;

        this.defaultFields = splitFields(DEFAULT_FIELDS);

        this.alertManager = alertManager;

        this.customFieldsForComponent.putAll(reformatFieldsList(customFieldsForComponent));

    }



    private Map<String, LinkedHashSet<String>> reformatFieldsList(List<Map<String, Object>> jsonCustomFields) {

        Map<String, LinkedHashSet<String>> reformattedList = Maps.newHashMap();

        for (Map<String, Object> component : jsonCustomFields) {

            reformattedList.put((String) component.get("name"), new LinkedHashSet<String>((Collection<String>) component.get("columns")));

        }

        return reformattedList;

    }



    private LinkedHashSet<String> splitFields(String fields) {

        return new LinkedHashSet<String>(Arrays.asList(fields.split(FIELDS_SEPARATOR)));

    }



    public String getNetprobeUrl() {

        return netprobeUrl;

    }



    public String getManagedEntity() {

        return managedEntity;

    }



    public String getSampler() {

        return sampler;

    }



    public String getGroupHeading() {

        return groupHeading;

    }



    public int getMaxAlertSendRetries() {

        return maxAlertSendRetries;

    }



    public GeneosWrapperConfiguration setMaxAlertSendRetries(int maxAlertSendRetries) {

        this.maxAlertSendRetries = maxAlertSendRetries;

        return this;

    }



    public int getInitialRetryTime() {

        return initialRetryTime;

    }



   public GeneosWrapperConfiguration setInitialRetryTime(int initialRetryTime) {

        this.initialRetryTime = initialRetryTime;

        return this;

    }



    public String getDefaultComponent() {

        return defaultComponent;

    }



    public GeneosWrapperConfiguration setDefaultComponent(String defaultComponent) {

        this.defaultComponent = defaultComponent;

        return this;

    }



    public LinkedHashSet<String> getDefaultFields() {

        return defaultFields;

    }



    public IAlertManager getAlertManager() {

        return alertManager;

    }



    public Map<String, LinkedHashSet<String>> getCustomFieldsForComponent() {

        return customFieldsForComponent;

    }

}

package sgcib.tmon.worker.common.task.publisher;



/**

* @author ablaszcz120213

*

*/

public interface IEmsConstant {



    // Message fields

    static final String timeToLiveField = "timeToLiveField";

    static final String persistentField = "persistentField";



    // EmsPublisher fields

    static final String appNameField = "appNameField";

    static final String versionField = "versionField";

    static final String certificatePathField = "certificatePathField";

    static final String loginField = "loginField";

    static final String passwordField = "passwordField";

    static final String replyPrefixField = "replyPrefixField";

    static final String connectionFactoryNameField = "connectionFactoryNameField";

    static final String otherField = "otherField";



    // JNDI fields

    static final String javaNamingFactoryInitialField = "javaNamingFactoryInitialField";

    static final String tibjmsUrlListField = "tibjmsUrlListField";

    static final String tibjmsSslVendorField = "tibjmsSslVendorField";

    static final String tibjmsSecurityProtocolField = "tibjmsSecurityProtocolField";

    static final String tibjmsSslDebugTraceField = "tibjmsSslDebugTraceField";

    static final String tibjmsSslEnableVerifyHostField = "tibjmsSslEnableVerifyHostField";

    static final String tibjmsSslEnableVerifyHostnameField = "tibjmsSslEnableVerifyHostnameField";

    static final String tibjmsSslExpectedHostnameField = "tibjmsSslExpectedHostnameField";

    static final String tibjmsSslCipherSuitesField = "tibjmsSslCipherSuitesField";

}

package sgcib.tmon.worker.common.task.publisher;



import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Queryable;



/**

* Created by Stephane on 23/03/2015.

*/

public interface IPublisher extends IManageable {



                Queryable send(String topic, Queryable item);

}

package sgcib.tmon.worker.common.task.publisher;



/**

* Created by Stephane on 23/03/2015.

*/

public interface IPublisherFactory {

                IPublisher build();

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.List;

import java.util.Properties;



import kafka.javaapi.producer.Producer;

import kafka.producer.KeyedMessage;

import kafka.producer.ProducerConfig;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.ObjectMapper;



/**

* Created by Stephane on 23/03/2015.

*/

public class KafkaPublisher extends ManageableBase implements IPublisher {



    private final ObjectMapper mapper;

    private final String brokerList;

    private Producer<String, String> producer;



    public KafkaPublisher(String name, String brokerList) {

        super(name);

        this.mapper = new ObjectMapper();

        this.brokerList = brokerList;



    }



    @Override

    public Queryable send(String topic, Queryable item) {

        try {

            KeyedMessage<String, String> data = new KeyedMessage<String, String>(topic, item.getId(), this.mapper.writeValueAsString(item));

            producer.send(data);

        } catch (JsonProcessingException error) {

            getLogger().error("Cannot convert event to Json", error);

        }

        return item;

    }



    @Override

    public void start() throws WorkerException {

        Properties props = new Properties();

        props.put("metadata.broker.list", brokerList);

        props.put("serializer.class", "kafka.serializer.StringEncoder");

        props.put("request.required.acks", "1");



        ProducerConfig config = new ProducerConfig(props);

        this.producer = new Producer<String, String>(config);

    }



    @Override

    public void stop() throws WorkerException {

        this.producer.close();

    }





}

package sgcib.tmon.worker.common.task.publisher;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 15/03/2015.

*/

public class KafkaPublisherTask extends PublisherTaskBase {



                public static String brokerListField = "brokerListField";

                public final String brokerList;



                public KafkaPublisherTask(PublisherConfiguration configuration, IAlertManager alertManager) {

                                super(configuration, alertManager);

                                brokerList = (String) configuration.get(KafkaPublisherTask.brokerListField);

                                ;

                }



                @Override

                public String getErrorField() {

                                return "kafkaPublisherError";

                }



                @Override

                public IPublisher build() {

                                return new KafkaPublisher(getName(), brokerList);

                }

}

package sgcib.tmon.worker.common.task.publisher;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;



import javax.mail.Message;

import javax.mail.MessagingException;

import javax.mail.Session;

import javax.mail.Transport;

import javax.mail.internet.InternetAddress;

import javax.mail.internet.MimeMessage;

import java.util.Date;

import java.util.List;

import java.util.Properties;

import java.util.regex.Matcher;

import java.util.regex.Pattern;



/**

* Created by slopes041604 on 30/06/2015.

*/

public class MailPublisher extends ManageableBase implements IPublisher {



    private String to;

    private String from;

    private String smtpGateway;

    private String subjectTemplate;

    private String bodyTemplate;

    private Pattern pattern;



    public MailPublisher(String name, String to, String from, String smtpGateway, String subjectTemplate, String bodyTemplate) {

        super(name);

        this.to = to;

        this.from = from;

        this.smtpGateway = smtpGateway;

        this.subjectTemplate = subjectTemplate;

        this.bodyTemplate = bodyTemplate;

        this.pattern= Pattern.compile("\\{([a-zA-Z\\@\\.\\-]*)\\}");

    }





    String replace(String template,Queryable item)

    {

        String data = template;

        Matcher matcher = pattern.matcher(template);



        while (matcher.find()) {

            String group = matcher.group();

            String key = group.substring(1, group.length() - 1);

            Object value  = item.getValue(key);

            if ( value != null) {

                data = data.replace(group,value.toString());

            }

        }



        return data;

    }



    @Override

    public Queryable send(String topic, Queryable item) {



        // Get system properties

        Properties properties = System.getProperties();



        // Setup mail server

        properties.setProperty("mail.smtp.host", smtpGateway);



        // Get the default Session object.

        Session session = Session.getDefaultInstance(properties);



        try{

            // Create a default MimeMessage object.

            MimeMessage message = new MimeMessage(session);



            // Set From: header field of the header.

            message.setFrom(new InternetAddress(from));



            // Set To: header field of the header.

            message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));



            // Set Subject: header field





            message.setSentDate(new Date());





            message.setSubject(replace(subjectTemplate, item));





            message.setText(replace(bodyTemplate, item),"utf-8", "html");





            // Send message

            Transport.send(message);



        }catch (MessagingException error) {

           getLogger().error("Aller mail cannot be sent",error);

        }



        return item;

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



}

package sgcib.tmon.worker.common.task.publisher;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



import java.util.concurrent.ExecutorService;



/**

* Created by slopes041604 on 30/06/2015.

*/

public class MailPublisherTask extends PublisherTaskBase {

    public static String toField = "to";

    public static String fromField = "from";

    public static String smtpGatewayField = "smtpGateway";

    public static String subjectTemplateField = "subjectTemplate";

    public static String bodyTemplateField = "bodyTemplate";



    public String to;

    public String from;

    public String smtpGateway;

    public String subjectTemplate;

    public String bodyTemplate;



    public MailPublisherTask(PublisherConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        to = (String) configuration.get(MailPublisherTask.toField);

        from = (String) configuration.get(MailPublisherTask.fromField);

        smtpGateway = (String) configuration.get(MailPublisherTask.smtpGatewayField);

        subjectTemplate = (String) configuration.get(MailPublisherTask.subjectTemplateField);

        bodyTemplate = (String) configuration.get(MailPublisherTask.bodyTemplateField);

    }



    @Override

    public IPublisher build() {

        return new MailPublisher("MailPublisher", to, from, smtpGateway, subjectTemplate, bodyTemplate);

    }



    @Override

    public String getErrorField() {

        return "mailError";

    }

}

package sgcib.tmon.worker.common.task.publisher;



import com.codahale.metrics.Timer;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.TaskBase;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



import java.util.concurrent.ConcurrentLinkedQueue;

import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 23/03/2015.

*/

public abstract class PublisherTaskBase extends TaskBase implements IPublisherFactory {

    protected final ConcurrentLinkedQueue<IPublisher> publishers;

    private final int poolSize;



    protected PublisherTaskBase(PublisherConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        publishers = new ConcurrentLinkedQueue<IPublisher>();

        poolSize = configuration.getPoolSize();

    }



    @Override

    protected boolean canProcess() {

        return (publishers.size() > 0);

    }



    @Override

    protected Queryable doProcess(Queryable item) throws WorkerException {

        IPublisher publisher = publishers.poll();

        if (publisher == null) {

            publisher = build();

            publisher.start();

        }

        PublisherConfiguration configuration = (PublisherConfiguration) getTaskConfiguration();

        Queryable result = publisher.send(configuration.getTopic(), item);

        if (publishers.size() < poolSize) {

            publishers.add(publisher);

        } else {

            publisher.stop();

        }

        return result;

    }



    @Override

    public void start() throws WorkerException {

        for (int index = 0; index < poolSize; index++) {

            IPublisher publisher = build();

            publisher.start();

            publishers.add(publisher);

        }

    }



    @Override

    public void stop() throws WorkerException {

        while (publishers.size() > 0) {

            IPublisher publisher = publishers.poll();

            if (publisher != null) {

                publisher.stop();

            }

        }

    }



}

package sgcib.tmon.worker.common.task.publisher;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.configuration.PublisherConfiguration;



import java.util.Map;

import java.util.concurrent.ExecutorService;



/**

* @author ablaszcz120213

*/

public class RvPublisherTask extends PublisherTaskBase {



    public static String serviceField = "service";

    public static String networkField = "network";

    public static String daemonField = "daemon";

    public static String subjectField = "subject";



    public static String mappingField = "mappingField";



    private final String service;

    private final String network;

    private final String daemon;

    private final String subject;



    private final Map<String, String> mappingAlertFieldV3ToCustomFieldV2;



    public RvPublisherTask(PublisherConfiguration configuration,  IAlertManager alertManager) {

        super(configuration,alertManager);

        service = (String) configuration.get(RvPublisherTask.serviceField);

        network = (String) configuration.get(RvPublisherTask.networkField);

        daemon = (String) configuration.get(RvPublisherTask.daemonField);

        subject = (String) configuration.get(RvPublisherTask.subjectField);



        mappingAlertFieldV3ToCustomFieldV2 = (Map<String, String>) configuration.get(RvPublisherTask.mappingField);

    }



    @Override

    public String getErrorField() {

        return "RvPublisherError";

    }



    @Override

    public IPublisher build() {

        return new TmonV2Publisher(getName(), service, network, daemon, subject, mappingAlertFieldV3ToCustomFieldV2);

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.Map.Entry;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.Queryable;



import com.tibco.tibrv.Tibrv;

import com.tibco.tibrv.TibrvException;

import com.tibco.tibrv.TibrvMsg;

import com.tibco.tibrv.TibrvNetTransport;

import com.tibco.tibrv.TibrvRvdTransport;



/**

* @author ablaszcz120213

*

*/

public class TibcoPublisher extends ManageableBase implements IPublisher {



    private TibrvNetTransport transport;

    private String service;

    private String network;

    private String daemon;

    private String subject;



    public TibcoPublisher(String name, String serviceField, String networkField, String daemonField, String subjectField) {

        super(name);

        this.service = serviceField;

        this.network = networkField;

        this.daemon = daemonField;

        this.subject = subjectField;

    }



    protected TibrvNetTransport getTransport() {

        return transport;

    }



    public String getService() {

        return service;

    }



    public String getNetwork() {

        return network;

    }



    public String getDaemon() {

        return daemon;

    }



    public String getSubject() {

        return subject;

    }



    @Override

    public void start() throws WorkerException {

        getLogger().info("Starting the Tibco service (service=" + service + ", network=" + network + ", daemon=" + daemon + ", subject=" + subject + ")");

        try {

            Tibrv.open(Tibrv.IMPL_NATIVE);

            this.transport = new TibrvRvdTransport(service, network, daemon);

        } catch (TibrvException e) {

            getLogger().error("Error while creating the Tibco listener", e);

        }

    }



    @Override

    public void stop() throws WorkerException {

        if (this.transport != null) {

            this.transport.destroy();

        } else {

            getLogger().warn("Transport is null. Can't destroy it");

        }

    }



    @Override

    public Queryable send(String topic, Queryable item) {



        TibrvMsg msg = new TibrvMsg();



        try {

            msg.setSendSubject(subject);

            msg.add("type", "externalAlert");

            msg.add("eventQueue", "alerts");

            msg.add("eventList", "host");

            addAlertFields(msg, (Alert) item);

            this.transport.send(msg);

        } catch (TibrvException e) {

            getLogger().error("Error while sending the message", e);

        }



        return item;

    }



    /**

     * Add all fields from the given Alert {@code alert} into the Tibco message

     * {@code msg}.

     *

     * @param message

     *            Tibco Rendez-vous message.

     * @param alert

     *            Alert instance.

     */

    private void addAlertFields(TibrvMsg message, Alert alert) {

        try {

            for (Entry<String, Object> entry : alert.entrySet()) {

                message.add(entry.getKey(), entry.getValue());

            }

        } catch (TibrvException e) {

            getLogger().error("Error adding alert field", e);

        }

    }

}

package sgcib.tmon.worker.common.task.publisher;



import java.util.HashMap;

import java.util.Map;

import java.util.Map.Entry;

import java.util.Optional;



import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.utils.AlertUtils;



import com.tibco.tibrv.TibrvException;

import com.tibco.tibrv.TibrvMsg;



/**

* @author ablaszcz120213

*/

public class TmonV2Publisher extends TibcoPublisher {



    private Map<String, String> mappingAlertFieldV3ToCustomFieldV2;



    public TmonV2Publisher(String name, String serviceField, String networkField, String daemonField, String subjectField, Map<String, String> mappingAlertFieldV3ToCustomFieldV2) {

        super(name, serviceField, networkField, daemonField, subjectField);

        this.mappingAlertFieldV3ToCustomFieldV2 = mappingAlertFieldV3ToCustomFieldV2;

    }



    @Override

    public Queryable send(String topic, Queryable item) {



        Alert alert = (Alert) item;



        TibrvMsg msg = new TibrvMsg();



        try {

            msg.setSendSubject(getSubject());



            msg.add("type", "externalAlertFromWorker");

            msg.add("eventQueue", "alerts");

            msg.add("key", alert.getId());



            if (AlertUtils.isClosedOrCancelled(alert)) {

                msg.add("level", 0); // zero means closed in TMon server

            } else {

                msg.add("level", alert.getPriority().getValue());

            }



            msg.add("text", alert.getUserMessage() + "" + alert.getTechnicalMessage());

            msg.add("alertType", alert.getType());



            addAlertFields(msg, alert);



            getTransport().send(msg);

        } catch (TibrvException e) {

            getLogger().error("Error while sending the message", e);

        }



        return item;

    }



    /**

     * Add all fields from the given Alert {@code alert} into the Tibco message

     * {@code msg}.

     *

     * @param message

     *            Tibco Rendez-vous message.

     * @param alert

     *            Instance of {@link Alert}.

     */

    private void addAlertFields(TibrvMsg message, Alert alert) {



        String key = "";

        Object value = "";



        Optional<Map<String, String>> opt = Optional.ofNullable(mappingAlertFieldV3ToCustomFieldV2);



        try {



            for (Entry<String, Object> entry : alert.entrySet()) {



                key = entry.getKey();

                value = entry.getValue();



                if (key.equalsIgnoreCase("deal")) {

                    String customField1 = "";

                    // we iterate on deal field to construct customField1

                    for (Entry<String, Object> dealEntry : ((HashMap<String, Object>) value).entrySet()) {

                        customField1 += dealEntry.getKey() + "=" + dealEntry.getValue() + ", ";

                    }

                    value = customField1;

                }



                if (opt.isPresent() && opt.get().containsKey(key)) {

                    key = mappingAlertFieldV3ToCustomFieldV2.get(key);

                }



                value = Optional.ofNullable(value).orElse("");

                message.add(key, value.toString());

            }

        } catch (TibrvException e) {

            getLogger().error(String.format("Error adding alert field %s=%s", key, value), e);

        }

    }



}

package sgcib.tmon.worker.common.task.rules;



import java.io.IOException;

import java.util.List;

import java.util.Timer;

import java.util.TimerTask;



import org.joda.time.DateTime;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.cluster.WorkerContext;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.store.IStoreManager;

import sgcib.tmon.worker.common.store.chain.IChainStore;

import sgcib.tmon.worker.configuration.ChainRuleConfiguration;



import com.fasterxml.jackson.databind.ObjectMapper;



/**

* Created by Stephane on 11/04/2015.

*/

public class ChainRuleTask extends RuleTask {



    private IChainStore chainStore;

    private Query reloadQuery;

    private Boolean chainsReloaded;

    private java.util.Timer timer;



    public ChainRuleTask(ChainRuleConfiguration configuration, IStoreManager storeManager, IAlertManager alertManager) {

        super(configuration, alertManager);

        this.chainStore = storeManager.getChainStore();

        this.reloadQuery = getReloadQuery(configuration.getReloadQuery());

        this.chainsReloaded = false;

    }



    public IChainStore getChainStore() {

        return chainStore;

    }



    @Override

    public void start() {

        super.start();

        if (timer == null) {

            this.timer = new Timer();

            TimerTask task = new TimerTask() {

                @Override

                public void run() {

                    if (!chainsReloaded && WorkerContext.getInstance().isMaster()) {

                        try {

                            chainsReloaded = true;

                            reloadChains();

                        } catch (Exception e) {

                            getLogger().error("Error in reload chains" + e);

                           // Clear all the objects loaded in the memory

                            if (ruleEntryPoint != null && ruleEntryPoint.getObjects() != null) {

                                ruleEntryPoint.getObjects().clear();

                            }

                            chainsReloaded = false;

                        }

                    }

                }

            };

            // Triggers every 5 seconds

            timer.scheduleAtFixedRate(task, 0, 5 * 1000);

        }

    }



    @Override

    public void stop() {

        if (timer != null) {

            timer.cancel();

        }



        super.stop();

    }



    @Override

    protected void setGlobals() {



        if (this.chainStore != null) {

            setGlobal("chainStore", this.chainStore);

        }

        super.setGlobals();

    }



    private Query getReloadQuery(String query) {

        if (query == null) {

            return null;

        }



        ObjectMapper mapper = new ObjectMapper();

        Query condition = null;

        try {

            condition = mapper.readValue(query, Query.class);

        } catch (IOException e) {

            getLogger().error("Cannot deserialize query " + query);

        }

        return condition;

    }



    private void reloadChains() {

        if (reloadQuery == null) {

            return;

        }

        if (this.chainStore != null) {

            IChainStore fromChainStore = this.chainStore;



            Query q = new Query(reloadQuery);

            q.addCriterion(Chain.type, "chain", QueryCriterionType.Is);

            q.addCriterion(Chain.timestamp, DateTime.now().minusDays(1), QueryCriterionType.GreaterThan);



            List<Chain> chains = fromChainStore.fetchChain(q);

            chains.forEach(ruleEntryPoint::insert);



            q = new Query(reloadQuery);

            q.addCriterion(Chain.type, "chainStep", QueryCriterionType.Is);

            q.addCriterion(Chain.timestamp, DateTime.now().minusDays(1), QueryCriterionType.GreaterThan);



            List<ChainStep> chainSteps = fromChainStore.fetchStep(q);

            chainSteps.forEach(ruleEntryPoint::insert);



            getSession().fireAllRules();

        }

    }

}package sgcib.tmon.worker.common.task.rules;



import java.util.List;

import java.util.Map;

import java.util.Timer;

import java.util.TimerTask;

import java.util.concurrent.BlockingQueue;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;

import java.util.concurrent.LinkedBlockingDeque;

import java.util.concurrent.TimeUnit;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.atomic.AtomicReference;

import java.util.stream.Collectors;



import org.joda.time.DateTime;

import org.kie.api.KieBase;

import org.kie.api.KieBaseConfiguration;

import org.kie.api.KieServices;

import org.kie.api.builder.KieBuilder;

import org.kie.api.builder.KieFileSystem;

import org.kie.api.conf.EventProcessingOption;

import org.kie.api.runtime.KieContainer;

import org.kie.api.runtime.KieSession;

import org.kie.api.runtime.rule.EntryPoint;

import org.mvel2.optimizers.OptimizerFactory;



import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.TaskBase;

import sgcib.tmon.worker.configuration.RuleConfiguration;



import com.fasterxml.jackson.databind.ObjectMapper;

import com.fasterxml.jackson.datatype.joda.JodaModule;

import com.google.common.annotations.VisibleForTesting;

import com.google.common.collect.ImmutableList;



/**

* Created by Stephane on 31/03/2015.

*/

public class RuleTask extends TaskBase {



    private final List<String> rules;

    private final Map<String, Object> globals;

    private final ExecutorService executor;

    private final AtomicBoolean isRunning;

    private final AtomicBoolean useStream;

    private Timer timer;

    private KieBase kbase;

    private KieSession ksession;

    protected EntryPoint ruleEntryPoint;

    protected AtomicReference<DateTime> now;



    private BlockingQueue<Queryable> items = new LinkedBlockingDeque<Queryable>();



    public RuleTask(RuleConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        this.rules = ImmutableList.copyOf(configuration.getRules());

        this.globals = new ConcurrentHashMap<String, Object>();

        this.useStream = new AtomicBoolean(false);

        this.isRunning = new AtomicBoolean(false);

        this.executor = Executors.newSingleThreadExecutor();

        this.now = new AtomicReference<>(DateTime.now());



        setGlobal("logger", getLogger());

        setGlobal("alertManager", alertManager);

        setGlobal("task", this);

        setGlobal("now", now);



    }



    @Override

    protected boolean canProcess() {

        return rules != null && rules.size() > 0;

    }



    @Override

   protected Queryable doProcess(Queryable item) throws WorkerException {

        if (item != null) {

            item.setRuleTaskName(this.getName());

            ruleEntryPoint.insert(convert(item));

            ksession.fireAllRules();

        }

        return item;

    }



    @Override

    protected List<Queryable> doProcessMultiple(List<Queryable> items) throws WorkerException {



        List<Queryable> filteredItems = items.stream().filter(item -> isNotDroppable(item)).collect(Collectors.toList());



        for (Queryable item : filteredItems) {

            item.setRuleTaskName(this.getName());

            ruleEntryPoint.insert(convert(item));

        }

        ksession.fireAllRules();



        return filteredItems;

    }



    private Queryable convert(Queryable item) {

        if (item != null) {

            item.setRuleTaskName(this.getName());

            switch (getAffinity()) {

            case None:

                return item;

            case Event:

                Event event = new Event();

                event.putAll(item);

                return event;

            case ChainStep:

                ChainStep chainStep = new ChainStep(item.getName());

                chainStep.putAll(item);

                return chainStep;

            case Chain:

                Chain chain = new Chain();

                chain.putAll(item);

                return chain;

            case Alert:

                Alert alert = new Alert();

                alert.putAll(item);

                return alert;

            case Metric:

                Metric metric = new Metric();

                metric.putAll(item);

                return metric;

            default:

                break;

            }

        }

        return item;

    }



    @Override

    public String getErrorField() {

        return "ruleError";

    }



    @Override

    public void start() throws WorkerException {



        OptimizerFactory.setDefaultOptimizer("ASM");

        KieServices ks = KieServices.Factory.get();

        KieFileSystem kFileSystem = ks.newKieFileSystem();



        int count = 0;

        for (String rule : rules) {

            kFileSystem.write("src/main/resources/" + getName() + "/rule" + count + ".drl", rule);

            count++;

        }



        KieBuilder kbuilder = ks.newKieBuilder(kFileSystem);

        kbuilder.buildAll();



        if (kbuilder.getResults().hasMessages(org.kie.api.builder.Message.Level.ERROR)) {

            getLogger().error(kbuilder.getResults().toString());

            throw new WorkerException("Cannot add the rules: " + kbuilder.getResults().toString());

        }



        KieContainer kContainer = ks.newKieContainer(ks.getRepository().getDefaultReleaseId());

        KieBaseConfiguration config = ks.newKieBaseConfiguration();



        /**

         * When the rulebase is compiled in the CLOUD (default) event processing

         * mode, it behaves just like a regular rulebase. When the rulebase is

         * compiled in the STREAM event processing mode, additional assumptions

         * are made.

         */

        if (!useStream.get()) {

            config.setOption(EventProcessingOption.CLOUD);

        } else {

            config.setOption(EventProcessingOption.STREAM);

        }



        kbase = kContainer.newKieBase(config);

        ksession = kContainer.newKieSession();



        getLogger().info("Starting task with {} rules ...", rules.size());



        ruleEntryPoint = ksession.getEntryPoint("eventEntry");



        if (ruleEntryPoint == null) {

            getLogger().error("Null entry point");

            throw new WorkerException("Invalid rule entry point");

        }



        setGlobals();



        isRunning.set(true);



        // fireUntilHalt method is only called when STREAM mode is enabled.

        if (useStream.get()) {

            executor.submit(() -> {

                do {

                    try {

                        ksession.fireUntilHalt();

                    } catch (Exception error) {

                        getLogger().error("Error in rule processing", error);

                    }

                    getLogger().info("End of rule processing");

                } while (isRunning.get());

            });

        } else {



            if (timer == null) {

                this.timer = new Timer();



                TimerTask task = new TimerTask() {

                    @Override

                    public void run() {

                        now.set(DateTime.now());

                        ksession.fireAllRules();

                        Event event = new Event("ruleTaskData", "workerData");

                        event.setValue("task", getName());

                        event.setValue("memorySize", ksession.getFactCount());

                        ManageableBase.publish(event);

                    }

                };

                timer.scheduleAtFixedRate(task, 0, 1000);

            }



        }

        getLogger().info(" ...task started.");

    }



    protected void setGlobals() {

        for (Map.Entry<String, Object> entry : globals.entrySet()) {

            ksession.getGlobals().set(entry.getKey(), entry.getValue());

        }

    }



    public void setGlobal(String name, Object object) {

        globals.put(name, object);

    }



    public Object getGlobal(String name) {

        return globals.get(name);

    }



    @Override

    public void stop() throws WorkerException {

        try {

            isRunning.set(false);

            executor.shutdown();

            executor.awaitTermination(50, TimeUnit.SECONDS);

        } catch (InterruptedException e) {

            getLogger().error("Error while stopping.", e);

        }

        if (!executor.isTerminated()) {

            getLogger().warn("Cancel non-finished tasks for {}", getName());

            executor.shutdownNow();

        }



        if (timer != null) {

            timer.cancel();

        }



        if (ksession != null) {

            ksession.halt();

            ksession.dispose();

        }



        getLogger().info("Stopped");

    }



    @VisibleForTesting

    public KieSession getSession() {

        return this.ksession;

    }



    public String dump() {

        StringBuilder builder = new StringBuilder();

        if (ksession != null) {

            List<Object> objects = ImmutableList.copyOf(ksession.getObjects());

            ObjectMapper mapper = new ObjectMapper();

            mapper.registerModule(new JodaModule());

            mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

            try {

                builder.append(mapper.writeValueAsString(objects));

            } catch (Exception error) {

                getLogger().error("Cannot dump memory", getName());

            }



        }

        return builder.toString();

    }



}

Gmail	Stephane Lopes-Bogalho <stephane.lopes.bogalho@gmail.com>
Review pour Mardi
LOPES Stephane <stephane.lopes@sgcib.com>	19 novembre 2015 17:28
 : "stephane.lopes.bogalho@gmail.com" <stephane.lopes.bogalho@gmail.com>
package sgcib.tmon.worker.common.alert;



import java.util.List;

import java.util.concurrent.atomic.AtomicReference;



import org.springframework.cache.annotation.Cacheable;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertPriority;

import sgcib.tmon.worker.common.model.AlertStatus;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.QueryCriterionType;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.alert.IAlertStore;

import sgcib.tmon.worker.common.task.ITaskManager;

import sgcib.tmon.worker.configuration.CacheConfiguration;



/**

* Created by slopes041604 on 02/06/2015.

*/

public class AlertManager extends ManageableBase implements IAlertManager {



    private final IAlertStore store;

    private AtomicReference<ITaskManager> taskManager;

    private int timeout;



    public AlertManager(IAlertStore store) {

        this(store, getConfiguration().getTimeoutInSeconds());

    }



    public AlertManager(IAlertStore store, int timeout) {

        super("AlertManager");

        this.store = store;

        this.taskManager = new AtomicReference<ITaskManager>();

        this.timeout = timeout;

    }



    @Override

    public void save(Alert alert) {

        saveAlert(alert);

    }



    @Override

    public void raiseAlert(Alert alert) {

        getLogger().info("Raising Alert: " + alert);

        saveAlert(alert);

        publishAlert(alert);

    }



    @Override

    public Alert raiseAlert(AlertPriority priority, String message, String publisher, Queryable queryable, String... fieldsToCopy) {

        Alert alert = new Alert(priority, message, queryable, fieldsToCopy);

        alert.setStatus(AlertStatus.Open);

        alert.setPublisher(publisher);

        raiseAlert(alert);

        return alert;

    }



    @Override

    public List<Alert> getAlerts(IQuery query) {

        if (store != null) {

            return store.read(query);

        }

        return null;

    }



    @Override

    @Cacheable(CacheConfiguration.CACHE_ALERT_BY_ID)

    public Alert getAlertById(String id) {

        if (store != null) {

            return store.read(id);

        }

        return null;

    }



    @Override

    public List<Alert> getAlertsByOrigin(String origin, IQuery query) {

        if (store != null) {

            if (query != null) {

                query.addCriterion(Alert.origin, origin, QueryCriterionType.Is);

                return store.read(query);

            } else {

                return store.read(new Query().addCriterion(Alert.origin, origin, QueryCriterionType.Is));

            }

        }

        return null;

    }



    @Override

    public void start() throws WorkerException {

        getLogger().debug("Starting alert manager");

    }



    @Override

    public void stop() throws WorkerException {

        getLogger().debug("Stopping alert manager");

    }



    private void saveAlert(Alert alert) {

        if (store != null) {

            store.create(alert);

        }

    }



    private void publishAlert(Alert alert) {

        if (taskManager != null) {

            String publisher = alert.getPublisher();

            if (publisher != null) {

                ITaskManager publisherManager = taskManager.get();

                if (publisherManager != null) {

                    publisherManager.process(alert, publisher, timeout);

                }

            }

        }

    }



    @Override

    public ITaskManager getTaskManager() {

        return taskManager.get();

    }



    @Override

    public void setTaskManager(ITaskManager taskManager) {

        this.taskManager.set(taskManager);

    }



}

package sgcib.tmon.worker.common.alert;



import java.util.List;



import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertPriority;

import sgcib.tmon.worker.common.model.IQuery;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.task.ITaskManager;



/**

* Created by slopes041604 on 02/06/2015.

*/

public interface IAlertManager extends IManageable {



    /**

     * Raise an alert and publish it to a publisher.

     * @param alert

     *            The given alert.

     */

    void raiseAlert(Alert alert);



    void save(Alert alert);



    Alert raiseAlert(AlertPriority priority, String message, String publisher, Queryable queryable, String... fieldsToCopy);



    List<Alert> getAlerts(IQuery query);



    List<Alert> getAlertsByOrigin(String origin, IQuery query);



    Alert getAlertById(String id);



    ITaskManager getTaskManager();



    void setTaskManager(ITaskManager taskManager);

}



package sgcib.tmon.worker.common.eventschecker;



import javax.xml.bind.annotation.XmlEnum;

import javax.xml.bind.annotation.XmlEnumValue;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for basicType.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

* <p>

* <pre>

* &lt;simpleType name="basicType">

*   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">

*     &lt;enumeration value="string"/>

*     &lt;enumeration value="integer"/>

*     &lt;enumeration value="double"/>

*     &lt;enumeration value="datetime"/>

*     &lt;enumeration value="date"/>

*     &lt;enumeration value="uuid"/>

*     &lt;enumeration value="boolean"/>

*   &lt;/restriction>

* &lt;/simpleType>

* </pre>

*

 */

@XmlType(name = "basicType", namespace = "my://EventType")

@XmlEnum

public enum BasicType {



    @XmlEnumValue("string")

    STRING("string"),

    @XmlEnumValue("integer")

    INTEGER("integer"),

    @XmlEnumValue("double")

    DOUBLE("double"),

    @XmlEnumValue("datetime")

    DATETIME("datetime"),

    @XmlEnumValue("date")

    DATE("date"),

    @XmlEnumValue("uuid")

    UUID("uuid"),

    @XmlEnumValue("boolean")

    BOOLEAN("boolean");

    private final String value;



    BasicType(String v) {

        value = v;

    }



    public String value() {

        return value;

    }



    public static BasicType fromValue(String v) {

        for (BasicType c: BasicType.values()) {

            if (c.value.equals(v)) {

                return c;

            }

        }

        throw new IllegalArgumentException(v);

    }



}



package sgcib.tmon.worker.common.eventschecker;



import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for basicTypeField complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="basicTypeField">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="type" type="{my://EventType}basicType" default="string" />

*       &lt;attribute name="mandatory" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*       &lt;attribute name="litteralValue" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="format" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "basicTypeField", namespace = "my://EventType")

public class BasicTypeField {



    @XmlAttribute(name = "name", required = true)

    protected String name;

    @XmlAttribute(name = "type")

    protected BasicType type;

    @XmlAttribute(name = "mandatory")

    protected Boolean mandatory;

    @XmlAttribute(name = "litteralValue")

    protected String litteralValue;

    @XmlAttribute(name = "format")

    protected String format;

    @XmlAttribute(name = "array")

    protected Boolean array;



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the type property.

     *

     * @return

     *     possible object is

     *     {@link BasicType }

     *

     */

    public BasicType getType() {

        if (type == null) {

            return BasicType.STRING;

        } else {

            return type;

        }

    }



    /**

     * Sets the value of the type property.

     *

     * @param value

     *     allowed object is

     *     {@link BasicType }

     *

     */

   public void setType(BasicType value) {

        this.type = value;

    }



    /**

     * Gets the value of the mandatory property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isMandatory() {

        if (mandatory == null) {

            return true;

        } else {

            return mandatory;

        }

    }



    /**

     * Sets the value of the mandatory property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setMandatory(Boolean value) {

        this.mandatory = value;

    }



    /**

     * Gets the value of the litteralValue property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getLitteralValue() {

        return litteralValue;

    }



    /**

     * Sets the value of the litteralValue property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setLitteralValue(String value) {

        this.litteralValue = value;

    }



    /**

     * Gets the value of the format property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getFormat() {

        return format;

    }



    /**

     * Sets the value of the format property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setFormat(String value) {

        this.format = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlElement;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for enumType complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="enumType">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;sequence>

*         &lt;element name="value" maxOccurs="unbounded">

*           &lt;complexType>

*             &lt;complexContent>

*               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*                 &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}string" />

*               &lt;/restriction>

*             &lt;/complexContent>

*           &lt;/complexType>

*         &lt;/element>

*       &lt;/sequence>

*       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="restrictive" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "enumType", namespace = "my://EventType", propOrder = {

    "value"

})

public class EnumType {



    @XmlElement(namespace = "my://EventType", required = true)

    protected List<EnumType.Value> value;

    @XmlAttribute(name = "name", required = true)

    protected String name;

    @XmlAttribute(name = "restrictive")

    protected Boolean restrictive;

    @XmlAttribute(name = "array")

    protected Boolean array;



    /**

     * Gets the value of the value property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the value property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getValue().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link EnumType.Value }

     *

     *

     */

    public List<EnumType.Value> getValue() {

        if (value == null) {

            value = new ArrayList<EnumType.Value>();

        }

        return this.value;

    }



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the restrictive property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isRestrictive() {

        if (restrictive == null) {

            return true;

        } else {

            return restrictive;

        }

    }



    /**

     * Sets the value of the restrictive property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setRestrictive(Boolean value) {

        this.restrictive = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }





    /**

     * <p>Java class for anonymous complex type.

     *

     * <p>The following schema fragment specifies the expected content contained within this class.

     *

     * <pre>

     * &lt;complexType>

     *   &lt;complexContent>

     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

     *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}string" />

     *     &lt;/restriction>

     *   &lt;/complexContent>

     * &lt;/complexType>

     * </pre>

     *

     *

     */

    @XmlAccessorType(XmlAccessType.FIELD)

    @XmlType(name = "")

    public static class Value {



        @XmlAttribute(name = "value")

        protected String value;



        /**

         * Gets the value of the value property.

         *

         * @return

         *     possible object is

         *     {@link String }

         *

         */

        public String getValue() {

            return value;

        }



        /**

         * Sets the value of the value property.

         *

         * @param value

         *     allowed object is

         *     {@link String }

         *

         */

        public void setValue(String value) {

            this.value = value;

        }



    }



}



package sgcib.tmon.worker.common.eventschecker;



import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for enumTypeField complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="enumTypeField">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="type" type="{http://www.w3.org/2001/XMLSchema}string" default="string" />

*       &lt;attribute name="mandatory" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "enumTypeField", namespace = "my://EventType")

public class EnumTypeField {



    @XmlAttribute(name = "name", required = true)

    protected String name;

    @XmlAttribute(name = "type")

    protected String type;

    @XmlAttribute(name = "mandatory")

    protected Boolean mandatory;

    @XmlAttribute(name = "array")

    protected Boolean array;



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the type property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getType() {

        if (type == null) {

            return "string";

        } else {

            return type;

        }

    }



    /**

     * Sets the value of the type property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setType(String value) {

        this.type = value;

    }



    /**

     * Gets the value of the mandatory property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isMandatory() {

        if (mandatory == null) {

            return true;

        } else {

            return mandatory;

        }

    }



    /**

     * Sets the value of the mandatory property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setMandatory(Boolean value) {

        this.mandatory = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }



}

package sgcib.tmon.worker.common.eventschecker;



import java.io.StringReader;

import java.util.HashMap;

import java.util.List;

import java.util.Set;



import javax.xml.bind.JAXBContext;

import javax.xml.bind.JAXBException;

import javax.xml.bind.Unmarshaller;



import org.joda.time.DateTime;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.common.model.Queryable;



import com.google.common.collect.Maps;



/**

* Created by adeshmuk060910 on 8/27/2015.

*/

public class EventTypeChecker {



    private final static Logger logger = LoggerFactory.getLogger(EventTypeChecker.class);



    private final EventTypes types;

    private final HashMap<String, Object> globals = Maps.newHashMap();



    private static String component = "component";



    public EventTypeChecker(EventTypes types) {

        this.types = types;

        try {

            ExtractSharedTypes(types, globals);

        } catch (Exception e) {

            logger.error(e.getMessage(), e);

        }



    }



    private static void ExtractSharedTypes(EventTypes types, HashMap<String, Object> globals) throws Exception {

        for (Object globalDefinition : types.globals.getEnumOrStructure()) {

            if (globalDefinition instanceof EnumType) {

                EnumType enumDef = (EnumType) globalDefinition;



                if (globals.containsKey(enumDef.name)) {

                    throw new Exception("More than one definition for enum type : " + enumDef.name);

                }

                globals.put(enumDef.name, enumDef);

           } else if (globalDefinition instanceof StructuredFieldDeclaration) {

                StructuredFieldDeclaration structDef = (StructuredFieldDeclaration) globalDefinition;



                if (globals.containsKey(structDef.name)) {

                    throw new Exception("More than one definition for struct type : " + structDef.name);

                }

                if (structDef.fieldOrStructureOrFieldEnum == null) {

                    throw new Exception("Empty struct definition for : " + structDef.name);

                }

                globals.put(structDef.name, structDef);

            } else {

                throw new Exception("unknowned type in globals: " + globalDefinition);

            }

        }

    }



    public void DoCheckType(Queryable itemToCheck) throws Exception {

        EventTypeDeclaration declaration = GetEventTypeDeclaration(itemToCheck);

        if (declaration == null) {

            throw new Exception("Event Declaration not found for " + itemToCheck.getType());

        }



        DoCheckType(declaration, itemToCheck);

    }



    private EventTypeDeclaration GetEventTypeDeclaration(Queryable itemToCheck) throws Exception {

        if (null == itemToCheck.get(component) || null == itemToCheck.getType()) {

           throw new Exception("component and type are both madatory in event for " + itemToCheck);

        }



        for (EventTypeDeclaration event : this.types.getEvent()) {

            if (itemToCheck.get(component).equals(event.getTmonComponent()) && itemToCheck.getType().equals(event.tmonEventType)) {

                return event;

            }

        }

        return null;

    }



    private void DoCheckType(EventTypeDeclaration declaration, HashMap<String, Object> itemToCheck) throws Exception {

        DoCheckTypeStruct(declaration, itemToCheck);

    }



    private void DoCheckTypeStruct(EventTypeDeclaration declaration, HashMap<String, Object> itemToCheck) throws Exception {

        for (Object item : declaration.getFieldOrRefFieldOrStructure()) {

            DoCheckItem(item, itemToCheck);

        }

    }



    private void DoCheckItem(Object item, HashMap<String, Object> itemToCheck) throws Exception {

        if (item instanceof BasicTypeField) {

            BasicTypeField basicTypeitem = ((BasicTypeField) item);

            if (basicTypeitem.isMandatory()) {

                if (!itemToCheck.containsKey(basicTypeitem.name)) {

                    throw new Exception(String.format("missing field %s in event %s", basicTypeitem.name, itemToCheck));

                }

                DoCheckTypeAtomic(basicTypeitem, itemToCheck.get(basicTypeitem.name));

            } else {

                // Check if optional value is properly filled.

                if (itemToCheck.containsKey(basicTypeitem.name)) {

                    DoCheckTypeAtomic(basicTypeitem, itemToCheck.get(basicTypeitem.name));

                }

            }

        } else if (item instanceof EnumTypeField) {

            EnumTypeField enumTypeitem = ((EnumTypeField) item);

            if (enumTypeitem.isMandatory()) {

                if (!itemToCheck.containsKey(enumTypeitem.name)) {

                    throw new Exception(String.format("missing field %s in event %s", enumTypeitem.name, itemToCheck));

                }

                DoCheckEnum(enumTypeitem, itemToCheck);

            }

        } else if (item instanceof ReferenceTypeField) {

            ReferenceTypeField refTypeitem = ((ReferenceTypeField) item);

            if (refTypeitem.isMandatory()) {

                if (!itemToCheck.containsKey(refTypeitem.name) && refTypeitem.isMandatory()) {

                    throw new Exception(String.format("missing field %s in event %s", refTypeitem.name, itemToCheck));

                }

                Object refDeclaration = GetGlobalDeclaration(refTypeitem.type);

                if (refDeclaration == null) {

                    throw new Exception(String.format("Declaration not found for %s.", refTypeitem.type));

                }



                if (refTypeitem.isArray()) {

                    List<HashMap<String, Object>> basicListItem = (List<HashMap<String, Object>>) itemToCheck.get(refTypeitem.name);

                    for (HashMap<String, Object> ob : basicListItem) {

                        DoCheckItem(refDeclaration, ob);

                    }

                    return;

                }



                StructuredFieldDeclaration structDec = (StructuredFieldDeclaration) refDeclaration;

                HashMap<String, Object> toCheck = (HashMap<String, Object>) itemToCheck.get(refTypeitem.name);

                if (structDec.isAllFieldsExplicit()) {

                    checkAllExplicitDeclaration(toCheck.keySet(), structDec.getFieldOrStructureOrFieldEnum());

                }

                for (Object s : structDec.getFieldOrStructureOrFieldEnum()) {

                    DoCheckItem(s, toCheck);

                }

            }

        } else if (item instanceof StructuredFieldType) {

            StructuredFieldType structTypeItem = ((StructuredFieldType) item);

            if (structTypeItem.isMandatory()) {

                if (!itemToCheck.containsKey(structTypeItem.name)) {

                    throw new Exception(String.format("missing field %s in event %s", structTypeItem.name, itemToCheck));

                }

                List<Object> structDeclaration = structTypeItem.getFieldOrStructureOrFieldEnum();

                if (structTypeItem.isArray()) {

                    List<HashMap<String, Object>> basicListItem = (List<HashMap<String, Object>>) itemToCheck.get(structTypeItem.name);

                    for (HashMap<String, Object> ob : basicListItem) {

                        DoCheckItem(structTypeItem, ob);

                    }

                    return;

                }

                if (structTypeItem.isAllFieldsExplicit()) {

                    HashMap<String, Object> toCheck = ((HashMap<String, Object>) itemToCheck.get(structTypeItem.name));

                    checkAllExplicitDeclaration(toCheck.keySet(), structDeclaration);

                }

                for (Object val : structDeclaration) {

                    DoCheckItem(val, (HashMap<String, Object>) itemToCheck.get(structTypeItem.name));

                }

            }

        }

    }



    private void checkAllExplicitDeclaration(Set<String> eventValues, List<Object> eventDeclarations) throws Exception {

        for (String key : eventValues) {

            boolean declared = false;

            for (Object struct : eventDeclarations) {

                try {

                    if (struct.getClass().getDeclaredField("name").get(struct).equals(key)) {

                        declared = true;

                        break;

                    }

                } catch (Exception e) {

                    throw new Exception("error on checkIfDeclarationIsPresent", e);

                }

            }

            if (!declared) {

                throw new Exception(String.format("Extra item found %s.", key));

            }

        }

    }



    private Object GetGlobalDeclaration(String name) {

        return globals.get(name);

    }



    private static void DoCheckTypeAtomic(BasicTypeField basicTypeitem, Object o) throws Exception {

        if (basicTypeitem.isArray()) {

            List<Object> basicListItem = (List<Object>) o;

            BasicTypeField typeField = new BasicTypeField();

            typeField.setName(basicTypeitem.getName());

            typeField.setType(basicTypeitem.getType());

            typeField.setFormat(basicTypeitem.getFormat());

            typeField.setLitteralValue(basicTypeitem.getLitteralValue());

            typeField.setArray(false);

            for (Object ob : basicListItem) {

                DoCheckTypeAtomic(typeField, ob);

            }

            return;

        }



        if (basicTypeitem.type == BasicType.DOUBLE) {

            Double.parseDouble(o.toString());

        } else if (basicTypeitem.type == BasicType.DATE || basicTypeitem.type == BasicType.DATETIME) {

            DateTime.parse(o.toString());

        } else if (basicTypeitem.type == BasicType.BOOLEAN) {

            Boolean.parseBoolean(o.toString());

        } else if (basicTypeitem.type == BasicType.INTEGER) {

            Integer.parseInt(o.toString());

        }

    }



    public static EventTypes GetTypesDefination(String xmlString) {

        JAXBContext context = null;

        try {

            context = JAXBContext.newInstance(EventTypes.class);

            Unmarshaller unmarshaller = context.createUnmarshaller();

            StringReader reader = new StringReader(xmlString);

            EventTypes d = (EventTypes) unmarshaller.unmarshal(reader);

            return d;

        } catch (JAXBException e) {

            logger.error(e.getMessage(), e);

        }



        return null;

    }



    private void DoCheckEnum(EnumTypeField basicTypeitem, HashMap<String, Object> eventToSend) throws Exception {

        Object enumGlobalDeclaration = GetGlobalDeclaration(basicTypeitem.type);

        if (enumGlobalDeclaration == null) {

            throw new Exception(String.format("Declaration not found for %s.", basicTypeitem.type));

        }

        EnumType enumType = (EnumType) enumGlobalDeclaration;

        Boolean result = false;

        if (basicTypeitem.isArray()) {

            List<String> basicListItem = (List<String>) eventToSend.get(basicTypeitem.name);

            for (String ob : basicListItem) {

                for (EnumType.Value val : enumType.value) {

                    if (val.getValue().toString().equals(ob)) {

                        result = true;

                    }

                }

            }

        } else {

            for (EnumType.Value val : enumType.value) {

                if (val.getValue().toString().equals(eventToSend.get(basicTypeitem.name))) {

                    result = true;

                }

            }

        }



        if (!result) {

            throw new Exception(String.format("Value not enum for %s.", basicTypeitem.name));

        }

    }

}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlElement;

import javax.xml.bind.annotation.XmlElements;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for eventTypeDeclaration complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="eventTypeDeclaration">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;choice maxOccurs="unbounded">

*         &lt;element name="field" type="{my://EventType}basicTypeField"/>

*         &lt;element name="refField" type="{my://EventType}referenceTypeField"/>

*         &lt;element name="structure" type="{my://EventType}structuredFieldType"/>

*         &lt;element name="fieldEnum" type="{my://EventType}enumTypeField"/>

*       &lt;/choice>

*       &lt;attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="tmonComponent" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="tmonEventType" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "eventTypeDeclaration", namespace = "my://EventType", propOrder = {

    "fieldOrRefFieldOrStructure"

})

public class EventTypeDeclaration {



    @XmlElements({

        @XmlElement(name = "field", namespace = "my://EventType", type = BasicTypeField.class),

        @XmlElement(name = "refField", namespace = "my://EventType", type = ReferenceTypeField.class),

        @XmlElement(name = "structure", namespace = "my://EventType", type = StructuredFieldType.class),

        @XmlElement(name = "fieldEnum", namespace = "my://EventType", type = EnumTypeField.class)

    })

    protected List<Object> fieldOrRefFieldOrStructure;

    @XmlAttribute(name = "name")

    protected String name;

    @XmlAttribute(name = "tmonComponent", required = true)

    protected String tmonComponent;

    @XmlAttribute(name = "tmonEventType", required = true)

    protected String tmonEventType;



    /**

     * Gets the value of the fieldOrRefFieldOrStructure property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the fieldOrRefFieldOrStructure property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getFieldOrRefFieldOrStructure().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link BasicTypeField }

     * {@link ReferenceTypeField }

     * {@link StructuredFieldType }

     * {@link EnumTypeField }

     *

     *

     */

    public List<Object> getFieldOrRefFieldOrStructure() {

        if (fieldOrRefFieldOrStructure == null) {

            fieldOrRefFieldOrStructure = new ArrayList<Object>();

        }

        return this.fieldOrRefFieldOrStructure;

    }



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

    * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the tmonComponent property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getTmonComponent() {

        return tmonComponent;

    }



    /**

     * Sets the value of the tmonComponent property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setTmonComponent(String value) {

        this.tmonComponent = value;

    }



    /**

     * Gets the value of the tmonEventType property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getTmonEventType() {

        return tmonEventType;

    }



    /**

     * Sets the value of the tmonEventType property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setTmonEventType(String value) {

        this.tmonEventType = value;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.*;





/**

* <p>Java class for eventTypes complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="eventTypes">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;sequence>

*         &lt;element name="globals" type="{my://EventType}globalTypes" minOccurs="0"/>

*         &lt;element name="event" type="{my://EventType}eventTypeDeclaration" maxOccurs="unbounded"/>

*       &lt;/sequence>

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "Types", namespace = "my://EventType", propOrder = {

    "globals",

    "event"

})

@XmlRootElement(name = "Types", namespace = "my://EventType")

public class EventTypes {



    @XmlElement(namespace = "my://EventType")

    protected GlobalTypes globals;

    @XmlElement(namespace = "my://EventType", required = true)

    protected List<EventTypeDeclaration> event;



    /**

     * Gets the value of the globals property.

     *

     * @return

     *     possible object is

     *     {@link GlobalTypes }

     *

     */

    public GlobalTypes getGlobals() {

        return globals;

    }



    /**

     * Sets the value of the globals property.

     *

     * @param value

     *     allowed object is

     *     {@link GlobalTypes }

     *

     */

    public void setGlobals(GlobalTypes value) {

        this.globals = value;

    }



    /**

     * Gets the value of the event property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the event property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getEvent().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link EventTypeDeclaration }

     *

     *

     */

    public List<EventTypeDeclaration> getEvent() {

        if (event == null) {

            event = new ArrayList<EventTypeDeclaration>();

        }

        return this.event;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlElement;

import javax.xml.bind.annotation.XmlElements;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for globalTypes complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="globalTypes">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;choice maxOccurs="unbounded">

*         &lt;element name="enum" type="{my://EventType}enumType"/>

*         &lt;element name="structure" type="{my://EventType}structuredFieldDeclaration"/>

*       &lt;/choice>

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "globalTypes", namespace = "my://EventType", propOrder = {

    "enumOrStructure"

})

public class GlobalTypes {



    @XmlElements({

        @XmlElement(name = "enum", namespace = "my://EventType", type = EnumType.class),

        @XmlElement(name = "structure", namespace = "my://EventType", type = StructuredFieldDeclaration.class)

    })

    protected List<Object> enumOrStructure;



    /**

     * Gets the value of the enumOrStructure property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the enumOrStructure property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getEnumOrStructure().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link EnumType }

     * {@link StructuredFieldDeclaration }

     *

     *

     */

    public List<Object> getEnumOrStructure() {

        if (enumOrStructure == null) {

            enumOrStructure = new ArrayList<Object>();

        }

        return this.enumOrStructure;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import javax.xml.bind.JAXBElement;

import javax.xml.bind.annotation.XmlElementDecl;

import javax.xml.bind.annotation.XmlRegistry;

import javax.xml.namespace.QName;





/**

* This object contains factory methods for each

 * Java content interface and Java element interface

 * generated in the sgcib.tmon.worker.events package.

 * <p>An ObjectFactory allows you to programatically

 * construct new instances of the Java representation

 * for XML content. The Java representation of XML

 * content can consist of schema derived interfaces

 * and classes representing the binding of schema

 * type definitions, element declarations and model

 * groups.  Factory methods for each of these are

 * provided in this class.

*

 */

@XmlRegistry

public class ObjectFactory {



    private final static QName _Types_QNAME = new QName("my://EventType", "Types");



    /**

     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: sgcib.tmon.worker.events

     *

     */

    public ObjectFactory() {

    }



    /**

     * Create an instance of {@link EnumType }

     *

     */

    public EnumType createEnumType() {

        return new EnumType();

    }



    /**

     * Create an instance of {@link EventTypes }

     *

     */

    public EventTypes createEventTypes() {

        return new EventTypes();

    }



    /**

     * Create an instance of {@link EventTypeDeclaration }

     *

     */

    public EventTypeDeclaration createEventTypeDeclaration() {

        return new EventTypeDeclaration();

    }



    /**

     * Create an instance of {@link StructuredFieldType }

     *

     */

    public StructuredFieldType createStructuredFieldType() {

        return new StructuredFieldType();

    }



    /**

     * Create an instance of {@link StructuredFieldDeclaration }

     *

     */

    public StructuredFieldDeclaration createStructuredFieldDeclaration() {

        return new StructuredFieldDeclaration();

    }



    /**

     * Create an instance of {@link ReferenceTypeField }

     *

     */

    public ReferenceTypeField createReferenceTypeField() {

        return new ReferenceTypeField();

   }



    /**

     * Create an instance of {@link GlobalTypes }

     *

     */

    public GlobalTypes createGlobalTypes() {

        return new GlobalTypes();

    }



    /**

     * Create an instance of {@link EnumTypeField }

     *

     */

    public EnumTypeField createEnumTypeField() {

        return new EnumTypeField();

    }



    /**

     * Create an instance of {@link BasicTypeField }

     *

     */

    public BasicTypeField createBasicTypeField() {

        return new BasicTypeField();

    }



    /**

     * Create an instance of {@link EnumType.Value }

     *

     */

    public EnumType.Value createEnumTypeValue() {

        return new EnumType.Value();

    }



    /**

     * Create an instance of {@link JAXBElement }{@code <}{@link EventTypes }{@code >}}

     *

     */

    @XmlElementDecl(namespace = "my://EventType", name = "Types")

    public JAXBElement<EventTypes> createTypes(EventTypes value) {

        return new JAXBElement<EventTypes>(_Types_QNAME, EventTypes.class, null, value);

    }



}



package sgcib.tmon.worker.common.eventschecker;



import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for referenceTypeField complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="referenceTypeField">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="type" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="mandatory" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "referenceTypeField", namespace = "my://EventType")

public class ReferenceTypeField {



    @XmlAttribute(name = "name", required = true)

    protected String name;

    @XmlAttribute(name = "type", required = true)

    protected String type;

    @XmlAttribute(name = "mandatory")

    protected Boolean mandatory;

    @XmlAttribute(name = "array")

    protected Boolean array;



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the type property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getType() {

        return type;

    }



    /**

     * Sets the value of the type property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setType(String value) {

        this.type = value;

    }



    /**

     * Gets the value of the mandatory property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isMandatory() {

        if (mandatory == null) {

            return true;

        } else {

            return mandatory;

        }

    }



    /**

     * Sets the value of the mandatory property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setMandatory(Boolean value) {

        this.mandatory = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlElement;

import javax.xml.bind.annotation.XmlElements;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for structuredFieldDeclaration complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="structuredFieldDeclaration">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;choice maxOccurs="unbounded">

*         &lt;element name="field" type="{my://EventType}basicTypeField"/>

*         &lt;element name="structure" type="{my://EventType}structuredFieldType"/>

*         &lt;element name="fieldEnum" type="{my://EventType}enumTypeField"/>

*       &lt;/choice>

*       &lt;attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*       &lt;attribute name="allFieldsExplicit" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "structuredFieldDeclaration", namespace = "my://EventType", propOrder = {

    "fieldOrStructureOrFieldEnum"

})

public class StructuredFieldDeclaration {



    @XmlElements({

        @XmlElement(name = "field", namespace = "my://EventType", type = BasicTypeField.class),

        @XmlElement(name = "structure", namespace = "my://EventType", type = StructuredFieldType.class),

        @XmlElement(name = "fieldEnum", namespace = "my://EventType", type = EnumTypeField.class)

    })

    protected List<Object> fieldOrStructureOrFieldEnum;

    @XmlAttribute(name = "name")

    protected String name;

    @XmlAttribute(name = "array")

    protected Boolean array;

    @XmlAttribute(name = "allFieldsExplicit")

    protected Boolean allFieldsExplicit;



    /**

     * Gets the value of the fieldOrStructureOrFieldEnum property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the fieldOrStructureOrFieldEnum property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getFieldOrStructureOrFieldEnum().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link BasicTypeField }

     * {@link StructuredFieldType }

     * {@link EnumTypeField }

     *

     *

     */

    public List<Object> getFieldOrStructureOrFieldEnum() {

        if (fieldOrStructureOrFieldEnum == null) {

            fieldOrStructureOrFieldEnum = new ArrayList<Object>();

        }

        return this.fieldOrStructureOrFieldEnum;

    }



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }



    /**

     * Gets the value of the allFieldsExplicit property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isAllFieldsExplicit() {

        if (allFieldsExplicit == null) {

            return true;

        } else {

            return allFieldsExplicit;

        }

    }



    /**

     * Sets the value of the allFieldsExplicit property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setAllFieldsExplicit(Boolean value) {

        this.allFieldsExplicit = value;

    }



}



package sgcib.tmon.worker.common.eventschecker;



import java.util.ArrayList;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;

import javax.xml.bind.annotation.XmlAccessorType;

import javax.xml.bind.annotation.XmlAttribute;

import javax.xml.bind.annotation.XmlElement;

import javax.xml.bind.annotation.XmlElements;

import javax.xml.bind.annotation.XmlType;





/**

* <p>Java class for structuredFieldType complex type.

*

 * <p>The following schema fragment specifies the expected content contained within this class.

*

 * <pre>

* &lt;complexType name="structuredFieldType">

*   &lt;complexContent>

*     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">

*       &lt;choice maxOccurs="unbounded">

*         &lt;element name="field" type="{my://EventType}basicTypeField"/>

*         &lt;element name="structure" type="{my://EventType}structuredFieldType"/>

*         &lt;element name="fieldEnum" type="{my://EventType}enumTypeField"/>

*       &lt;/choice>

*       &lt;attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />

*       &lt;attribute name="mandatory" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*       &lt;attribute name="array" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />

*       &lt;attribute name="allFieldsExplicit" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />

*     &lt;/restriction>

*   &lt;/complexContent>

* &lt;/complexType>

* </pre>

*

 *

 */

@XmlAccessorType(XmlAccessType.FIELD)

@XmlType(name = "structuredFieldType", namespace = "my://EventType", propOrder = {

    "fieldOrStructureOrFieldEnum"

})

public class StructuredFieldType {



    @XmlElements({

        @XmlElement(name = "field", namespace = "my://EventType", type = BasicTypeField.class),

        @XmlElement(name = "structure", namespace = "my://EventType", type = StructuredFieldType.class),

        @XmlElement(name = "fieldEnum", namespace = "my://EventType", type = EnumTypeField.class)

    })

    protected List<Object> fieldOrStructureOrFieldEnum;

    @XmlAttribute(name = "name", required = true)

    protected String name;

    @XmlAttribute(name = "mandatory")

    protected Boolean mandatory;

    @XmlAttribute(name = "array")

    protected Boolean array;

    @XmlAttribute(name = "allFieldsExplicit")

    protected Boolean allFieldsExplicit;



    /**

     * Gets the value of the fieldOrStructureOrFieldEnum property.

     *

     * <p>

     * This accessor method returns a reference to the live list,

     * not a snapshot. Therefore any modification you make to the

     * returned list will be present inside the JAXB object.

     * This is why there is not a <CODE>set</CODE> method for the fieldOrStructureOrFieldEnum property.

     *

     * <p>

     * For example, to add a new item, do as follows:

     * <pre>

     *    getFieldOrStructureOrFieldEnum().add(newItem);

     * </pre>

     *

     *

     * <p>

     * Objects of the following type(s) are allowed in the list

     * {@link BasicTypeField }

     * {@link StructuredFieldType }

     * {@link EnumTypeField }

     *

     *

     */

    public List<Object> getFieldOrStructureOrFieldEnum() {

        if (fieldOrStructureOrFieldEnum == null) {

            fieldOrStructureOrFieldEnum = new ArrayList<Object>();

        }

        return this.fieldOrStructureOrFieldEnum;

    }



    /**

     * Gets the value of the name property.

     *

     * @return

     *     possible object is

     *     {@link String }

     *

     */

    public String getName() {

        return name;

    }



    /**

     * Sets the value of the name property.

     *

     * @param value

     *     allowed object is

     *     {@link String }

     *

     */

    public void setName(String value) {

        this.name = value;

    }



    /**

     * Gets the value of the mandatory property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isMandatory() {

        if (mandatory == null) {

            return true;

        } else {

            return mandatory;

        }

    }



    /**

     * Sets the value of the mandatory property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setMandatory(Boolean value) {

        this.mandatory = value;

    }



    /**

     * Gets the value of the array property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isArray() {

        if (array == null) {

            return false;

        } else {

            return array;

        }

    }



    /**

     * Sets the value of the array property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setArray(Boolean value) {

        this.array = value;

    }



    /**

     * Gets the value of the allFieldsExplicit property.

     *

     * @return

     *     possible object is

     *     {@link Boolean }

     *

     */

    public boolean isAllFieldsExplicit() {

        if (allFieldsExplicit == null) {

            return false;

        } else {

            return allFieldsExplicit;

        }

    }



    /**

     * Sets the value of the allFieldsExplicit property.

     *

     * @param value

     *     allowed object is

     *     {@link Boolean }

     *

     */

    public void setAllFieldsExplicit(Boolean value) {

        this.allFieldsExplicit = value;

    }



}

package sgcib.tmon.worker.common.exception;




package sgcib.tmon.worker.common.lifecycle;




/**

* Date: 28/10/13

* Time: 14:53

* This file is part of biopsy.

* biopsy is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* biopsy is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with biopsy.  If not, see <http://www.gnu.org/licenses/>.

*/

public interface IService extends IManageable {

    String getName();

    HealthCheck getHealthCheck();

}

package sgcib.tmon.worker.common.lifecycle;



import java.net.InetAddress;

import java.net.UnknownHostException;



import org.apache.commons.lang3.StringUtils;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;

import sgcib.tmon.worker.configuration.WorkerConfiguration;



package sgcib.tmon.worker.common.messaging;



import java.util.Optional;

import java.util.UUID;



import javax.annotation.PreDestroy;

import javax.jms.JMSException;



import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.arc.eai.jms.emswrapper.EMSWrapper;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.utils.WorkerConfigurationUtils;

import sgcib.tmon.worker.configuration.TaskConfiguration;

import sgcib.tmon.worker.service.EmsRequestResponseService;



/**

* @author ablaszcz120213

*

*/

public class RequestReplyMessaging {



    private static final Logger LOGGER = LoggerFactory.getLogger(RequestReplyMessaging.class);



    // Used to distinguish the current Ems Wrapper instance from Ems Wrapper

    // instance of Publisher Task. A worker may be a cluster member too.

    private static final String OTHER_ID = UUID.randomUUID().toString();



    private IAlertManager alertManager;

    private EMSWrapper emsWrapper;



    /**

     * Instantiate a new EMS Wrapper with a request / response service.

     *

     * @param configuration

     *            Task configuration.

     * @param alertManager

     *            Alert manager.

     * @param publisherName

     *            Publisher name.

     */

    public RequestReplyMessaging(TaskConfiguration configuration, IAlertManager alertManager, String publisherName) {

        this.alertManager = alertManager;

        Optional<EMSWrapper> opt = WorkerConfigurationUtils.emsWrapper(configuration);

        if (opt.isPresent()) {

            emsWrapper = opt.get();

            emsWrapper.setOther(OTHER_ID);

            emsWrapper.getConnection();

            try {

                emsWrapper.addRequestResponseService(emsWrapper.getReplyPrefix(), new EmsRequestResponseService(this.alertManager, publisherName));

                LOGGER.info("Request / reply messaging started on topic {}", emsWrapper.getReplyPrefix());

           } catch (JMSException e) {

                LOGGER.error("Error while subscribing request / response service : {}", e.getMessage(), e);

            }

        }

    }



    @PreDestroy

    public void close() {

        try {

            emsWrapper.close();

        } catch (JMSException e) {

            LOGGER.error("Error while stopping EMS Wrapper : {}", e.getMessage(), e);

        }

    }

}

/**

* @author ablaszcz120213

*

*/

package sgcib.tmon.worker.common.messaging;package sgcib.tmon.worker.common.model;



import java.util.Arrays;

import java.util.List;

import java.util.Map;

import java.util.UUID;



import org.joda.time.DateTime;



import sgcib.tmon.worker.common.utils.OptionalObjectUtils;




package sgcib.tmon.worker.common.model;




package sgcib.tmon.worker.common.model;



/**

* Created with IntelliJ IDEA.

* User: slopes041604

* Date: 26/09/13

* Time: 09:19

* To change this template use File | Settings | File Templates.

*/



package sgcib.tmon.worker.common.model;



import java.util.ArrayList;

import java.util.List;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormat;

import org.joda.time.format.DateTimeFormatter;



import sgcib.tmon.worker.common.store.event.EventStore;

import sgcib.tmon.worker.common.store.event.IEventStore;



/**

* Created by ekolonis120213 on 25/03/14.

*/

public class BasicCutoff extends CutoffBase {



    public static String eventName = "eventName";

    public static String eventField = "eventField";

    public static String eventTimestamp = "eventTimestamp";

    public static String eventType = "eventType";

    public static String metricField = "metricField";

    public static String overUnder = "overUnder";

    public static String queryFilter = "queryFilter";

    public static String startingDate = "startingDate";

    public static String targetDate1 = "targetDate1";

    public static String targetDate2 = "targetDate2";

    public static String targetDate3 = "targetDate3";

    public static String targetDate4 = "targetDate4";

    public static String targetDate5 = "targetDate5";

    // public static String resetFrequency = "resetFrequency";

    public static String targetValue1 = "targetValue1";

    public static String targetValue2 = "targetValue2";

    public static String targetValue3 = "targetValue3";

    public static String targetValue4 = "targetValue4";

    public static String targetValue5 = "targetValue5";



    private IEventStore store;



    public BasicCutoff() {

       super("");

        setEventTimestamp("@timestamp");

        setOverUnder("OVER");

    }



    public BasicCutoff(String name) {

        super(name);

        setEventTimestamp("@timestamp");

        setOverUnder("OVER");

    }



    public IEventStore getStore() {

        return store;

    }



    public void setStore(IEventStore store) {

        this.store = store;

    }



    @Override

    protected Alert[] doValidate(DateTime upperLimit, EventStore eventStore) {



        DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss");

        DateTime start = formatter.parseDateTime(getStartingDate());



        IQuery query = new Query();

        query.addCriterion(Event.type, getEventType(), QueryCriterionType.Is);

        query.addCriterion(Event.timestamp, start, QueryCriterionType.GreaterOrEqualThan);

        query.addCriterion(Event.timestamp, upperLimit, QueryCriterionType.LesserOrEqualThan);

        // DateTime alertTime = DateTime.now();

        if (getMetricField().equals("COUNT")) {



            List<Event> events = eventStore.read(query);

            int hits = 0;

            for (Event event : events) {

                if ((event != null) && (event.getName().equals(getEventName()))) {

                    hits++;

                }

            }

            return checkCountTarget(hits, upperLimit);



        } else {

            Metric metric = eventStore.fetchMetric(query, getEventName(), getEventField());

            if (metric != null) {

                return checkTarget(metric, eventStore, upperLimit);

            } else {

                return null;

            }

        }



    }



    private Alert[] checkCountTarget(int count, DateTime alertTime) {



        List<Alert> alerts = new ArrayList<Alert>();



        DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss");

        DateTime targetDate1 = formatter.parseDateTime(getTargetDate1());

        DateTime targetDate2 = targetDate1.minusMinutes(getTargetDate2());

        DateTime targetDate3 = targetDate1.minusMinutes(getTargetDate3());

        DateTime targetDate4 = targetDate1.minusMinutes(getTargetDate4());

        DateTime targetDate5 = targetDate1.minusMinutes(getTargetDate5());



        if (targetDate1.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (count < getTargetValue1())) {

                alerts.add(buildAlert(AlertPriority.Critical, getEventName(), count, getTargetValue1(), alertTime));

           } else if (getOverUnder().equals("UNDER") && (count > getTargetValue1())) {

                alerts.add(buildAlert(AlertPriority.Critical, getEventName(), count, getTargetValue1(), alertTime));

            }

        } else if (targetDate1.compareTo(alertTime) > 0 && targetDate2.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (count < getTargetValue2())) {

                alerts.add(buildAlert(AlertPriority.High, getEventName(), count, getTargetValue2(), alertTime));

           } else if (getOverUnder().equals("UNDER") && (count > getTargetValue2())) {

                alerts.add(buildAlert(AlertPriority.High, getEventName(), count, getTargetValue2(), alertTime));

            }

        } else if (targetDate2.compareTo(alertTime) > 0 && targetDate3.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (count < getTargetValue3())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), count, getTargetValue3(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (count > getTargetValue3())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), count, getTargetValue3(), alertTime));

            }

        } else if (targetDate3.compareTo(alertTime) > 0 && targetDate4.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (count < getTargetValue4())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), count, getTargetValue4(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (count > getTargetValue4())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), count, getTargetValue4(), alertTime));

            }

        } else if (targetDate4.compareTo(alertTime) > 0 && targetDate5.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (count < getTargetValue5())) {

                alerts.add(buildAlert(AlertPriority.Low, getEventName(), count, getTargetValue5(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (count > getTargetValue5())) {

                alerts.add(buildAlert(AlertPriority.Low, getEventName(), count, getTargetValue5(), alertTime));

            }

        }



        return alerts.toArray(new Alert[alerts.size()]);



    }



    private Alert[] checkTarget(Metric metric, EventStore eventStore, DateTime alertTime) {



        List<Alert> alerts = new ArrayList<Alert>();



        DateTimeFormatter formatter = DateTimeFormat.forPattern("dd/MM/yyyy HH:mm:ss");

        DateTime targetDate1 = formatter.parseDateTime(getTargetDate1());

        DateTime targetDate2 = targetDate1.minusMinutes(getTargetDate2());

        DateTime targetDate3 = targetDate1.minusMinutes(getTargetDate3());

        DateTime targetDate4 = targetDate1.minusMinutes(getTargetDate4());

        DateTime targetDate5 = targetDate1.minusMinutes(getTargetDate5());



        long eventValue = 0;

       switch (getMetricField()) {

        case "COUNT":

            eventValue = metric.getCount();

            break;

        case "MEAN":

            eventValue = (long) metric.getMean();

            break;

        case "MAX":

            eventValue = (long) metric.getMaximum();

            break;

        case "MIN":

            eventValue = (long) metric.getMinimum();

            break;

        }



        if (targetDate1.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (eventValue < getTargetValue1())) {

                alerts.add(buildAlert(AlertPriority.Critical, getEventName(), getTargetValue1(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (eventValue > getTargetValue1())) {

                alerts.add(buildAlert(AlertPriority.Critical, getEventName(), getTargetValue1(), alertTime));

            }

        } else if (targetDate1.compareTo(alertTime) > 0 && targetDate2.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (eventValue < getTargetValue2())) {

                alerts.add(buildAlert(AlertPriority.High, getEventName(), getTargetValue2(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (eventValue > getTargetValue2())) {

                alerts.add(buildAlert(AlertPriority.High, getEventName(), getTargetValue2(), alertTime));

            }

        } else if (targetDate2.compareTo(alertTime) > 0 && targetDate3.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (eventValue < getTargetValue3())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), getTargetValue3(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (eventValue > getTargetValue3())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), getTargetValue3(), alertTime));

            }

        } else if (targetDate3.compareTo(alertTime) > 0 && targetDate4.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (eventValue < getTargetValue4())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), getTargetValue4(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (eventValue > getTargetValue4())) {

                alerts.add(buildAlert(AlertPriority.Medium, getEventName(), getTargetValue4(), alertTime));

            }

        } else if (targetDate4.compareTo(alertTime) > 0 && targetDate5.compareTo(alertTime) <= 0) {

            if (getOverUnder().equals("OVER") && (eventValue < getTargetValue5())) {

                alerts.add(buildAlert(AlertPriority.Low, getEventName(), getTargetValue5(), alertTime));

            } else if (getOverUnder().equals("UNDER") && (eventValue > getTargetValue5())) {

                alerts.add(buildAlert(AlertPriority.Low, getEventName(), getTargetValue5(), alertTime));

            }

        }



        return alerts.toArray(new Alert[alerts.size()]);



    }



    private Alert buildAlert(AlertPriority priority, String value, int count, double threshold, DateTime eventTime) {



        StringBuilder message = new StringBuilder();

        if (priority != AlertPriority.Info) {

            message.append("The cutoff on the events count of ").append(getEventType()).append(", ").append(getEventName()).append(" has been broken. The value is = ").append(count).append(" has not been ").append(getOverUnder())

                    .append(" the threshold (").append(threshold).append(") at ").append(eventTime).append(" ").append(".");



        } else {

            message.append("Current situation complies with Cutoff");

        }

        Alert alert = new Alert(priority, this.getName(), message.toString(), message.toString(), "cutoff");

        alert.setComponent(getComponent()); // TODO : edit these fields for

                                            // cutoff

        alert.setOrigin(this.getName());

        alert.setBrokenSla(this.getName());

        alert.setStatus(AlertStatus.Open);

        alert.setUserMessage(message.toString());

        return alert;

    }



    private Alert buildAlert(AlertPriority priority, String value, double threshold, DateTime eventTime) {



        StringBuilder message = new StringBuilder();

        if (priority != AlertPriority.Info) {

            message.append("The cutoff on field ").append(getEventField()).append(" from ").append(getEventName()).append(" has been broken. The value  ").append(value).append(" has not been ").append(getOverUnder()).append(" the threshold (")

                    .append(threshold).append(") at ").append(eventTime).append(" ").append(".");



        } else {

            message.append("Current situation complies with Cutoff");

        }

        Alert alert = new Alert(priority, this.getName(), message.toString(), message.toString(), "cutoff");

        alert.setComponent(getComponent()); // TODO : edit these fields for

                                            // cutoff

        alert.setOrigin(this.getName());

        alert.setBrokenSla(this.getName());

        alert.setStatus(AlertStatus.Open);

        alert.setUserMessage(message.toString());

        return alert;

    }



    public String getEventType() {

        return (String) get(BasicCutoff.eventType);

    }



    public void setEventType(String eventType) {

        put(BasicCutoff.eventType, eventType);

    }



    public String getEventName() {

        return (String) get(BasicCutoff.eventName);

    }



    public void setEventName(String eventName) {

        put(BasicCutoff.eventName, eventName);

    }



    public double getTargetValue1() {

        return Double.valueOf(get(BasicCutoff.targetValue1).toString());

    }



    public void setTargetValue1(double targetValue1) {

        put(BasicCutoff.targetValue1, targetValue1);

    }



    public double getTargetValue2() {

        return Double.valueOf(get(BasicCutoff.targetValue2).toString());

    }



    public void setTargetValue2(double targetValue2) {

        put(BasicCutoff.targetValue2, targetValue2);

    }



    public double getTargetValue3() {

        return Double.valueOf(get(BasicCutoff.targetValue3).toString());

    }



    public void setTargetValue3(double targetValue3) {

        put(BasicCutoff.targetValue3, targetValue3);

    }



    public double getTargetValue4() {

        return Double.valueOf(get(BasicCutoff.targetValue4).toString());

    }



    public void setTargetValue4(double targetValue4) {

        put(BasicCutoff.targetValue4, targetValue4);

    }



    public double getTargetValue5() {

        return Double.valueOf(get(BasicCutoff.targetValue5).toString());

    }



    public void setTargetValue5(double targetValue5) {

        put(BasicCutoff.targetValue5, targetValue5);

    }



    public String getEventField() {

        return (String) get(BasicCutoff.eventField);

    }



    public void setEventField(String eventField) {

        put(BasicCutoff.eventField, eventField);

    }



    public String getQueryFilter() {

        return (String) get(BasicCutoff.queryFilter);

    }



    public void setQueryFilter(String queryFilter) {

        put(BasicCutoff.queryFilter, queryFilter);

    }



    public String getMetricField() {

        return (String) get(BasicCutoff.metricField);

    }



    public void setMetricField(String metricField) {

        put(BasicCutoff.metricField, metricField);

    }



    public String getOverUnder() {

        return (String) get(BasicCutoff.overUnder);

    }



    public void setOverUnder(String overUnder) {

        put(BasicCutoff.overUnder, overUnder);

    }



    public String getStartingDate() {

        return (String) get(startingDate);

    }



    public void setStartingDate(String startingDate) {

        put(BasicCutoff.startingDate, startingDate);

    }



   public String getTargetDate1() {

        return (String) get(targetDate1);

    }



    public void setTargetDate1(String targetDate1) {

        put(BasicCutoff.targetDate1, targetDate1);

    }



    public int getTargetDate2() {

        return (Integer) get(BasicCutoff.targetDate2);

    }



    public void setTargetDate2(int targetDate2) {

        put(BasicCutoff.targetDate2, targetDate2);

    }



    public int getTargetDate3() {

        return (Integer) get(BasicCutoff.targetDate3);

    }



    public void setTargetDate3(int targetDate3) {

        put(BasicCutoff.targetDate3, targetDate3);

    }



    public int getTargetDate4() {

        return (Integer) get(BasicCutoff.targetDate4);

    }



    public void setTargetDate4(int targetDate4) {

        put(BasicCutoff.targetDate4, targetDate4);

    }



    public int getTargetDate5() {

        return (Integer) get(BasicCutoff.targetDate5);

    }



    public void setTargetDate5(int targetDate5) {

        put(BasicCutoff.targetDate5, targetDate5);

    }



    // public String getResetFrequency() {

    // return (String) get(resetFrequency);

    // }

    //

    // public void setResetFrequency(String resetFrequency) {

    // put(BasicCutoff.resetFrequency, resetFrequency);

    // }



    public String getEventTimestamp() {

        return (String) get(BasicCutoff.eventTimestamp);

    }



    public void setEventTimestamp(String eventTimestamp) {

        put(BasicCutoff.eventTimestamp, eventTimestamp);

    }



}package sgcib.tmon.worker.common.model;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.concurrent.TimeUnit;



import org.joda.time.DateTime;



import sgcib.tmon.worker.common.store.queryable.IQueryableStore;

import sgcib.tmon.worker.common.utils.OptionalObjectUtils;



import com.google.common.collect.ImmutableList;



public class BasicServiceLevelAgreement extends ServiceLevelAgreement {



    public static String eventName = "eventName";

    public static String eventField = "eventField";

    public static String eventType = "eventType";

    public static String period = "period";

    public static String timeUnit = "timeUnit";

    public static String targetOverBreached = "targetOverBreached";

    public static String targetBreached = "targetBreached";

    public static String targetThreatened = "targetThreatened";

    public static String targetMet = "targetMet";

    public static String isReverse = "isReverse";

    public static String overview = "overview";

    public static String view = "view";

    public static String queryFilter = "queryFilter";

    public static String consistencyOffset = "consistencyOffset";

    public static String metricField = "metricField";

    public static String alias = "alias";



    public BasicServiceLevelAgreement() {

        super();

        isReverse(false);

        setServiceLevelAgreementType(ServiceLevelAgreementType.Basic);

        setMetricField(Metric.mean);

        isByInstance(false);

        setInstanceName("");

        setConsistencyOffset(0);

    }



    public BasicServiceLevelAgreement(Map data) {

        super(data);

    }



    public BasicServiceLevelAgreement(String name) {

        super(name);

        isReverse(false);

        setServiceLevelAgreementType(ServiceLevelAgreementType.Basic);

        setMetricField(Metric.mean);

        isByInstance(false);

        setInstanceName("");

        setConsistencyOffset(0);

    }



    // Properties

    public String getQueryFilter() {

        return (String) get(BasicServiceLevelAgreement.queryFilter);

    }



    public void setQueryFilter(String queryFilter) {

        put(BasicServiceLevelAgreement.queryFilter, queryFilter);

    }



    public String getEventType() {

        return (String) get(BasicServiceLevelAgreement.eventType);

    }



    public void setEventType(String type) {

        put(BasicServiceLevelAgreement.eventType, type);

    }



    public double getTargetMet() {

        return Double.valueOf(get(BasicServiceLevelAgreement.targetMet).toString());

    }



    public void setTargetMet(double targetMet) {

        put(BasicServiceLevelAgreement.targetMet, targetMet);

    }



    public String getEventName() {

        return (String) get(BasicServiceLevelAgreement.eventName);

    }



    public void setEventName(String eventName) {

       put(BasicServiceLevelAgreement.eventName, eventName);

    }



    public String getEventField() {

        return (String) get(BasicServiceLevelAgreement.eventField);

    }



    public void setEventField(String fieldName) {

        put(BasicServiceLevelAgreement.eventField, fieldName);

    }



    @Override

    public int getPeriod() {

        return (Integer) get(BasicServiceLevelAgreement.period);

    }



    public void setPeriod(int period) {

        put(BasicServiceLevelAgreement.period, period);

    }



    @Override

    public TimeUnit getTimeUnit() {

        return TimeUnit.valueOf((String) get(BasicServiceLevelAgreement.timeUnit));

    }



    public void setTimeUnit(TimeUnit timeUnit) {

        put(BasicServiceLevelAgreement.timeUnit, timeUnit.toString());

    }



    public double getTargetOverBreached() {

        return Double.valueOf(get(BasicServiceLevelAgreement.targetOverBreached).toString());

    }



    public void setTargetOverBreached(double targetOverBreached) {

        put(BasicServiceLevelAgreement.targetOverBreached, targetOverBreached);

    }



    public double getTargetBreached() {

        return Double.valueOf(get(BasicServiceLevelAgreement.targetBreached).toString());

    }



    public void setTargetBreached(double targetBreached) {

        put(BasicServiceLevelAgreement.targetBreached, targetBreached);

    }



    public double getTargetThreatened() {

        return Double.valueOf(get(BasicServiceLevelAgreement.targetThreatened).toString());

    }



    public void setTargetThreatened(double targetThreatened) {

        put(BasicServiceLevelAgreement.targetThreatened, targetThreatened);

    }



    public boolean isReverse() {

        return Boolean.parseBoolean(get(BasicServiceLevelAgreement.isReverse).toString());

    }



    public void isReverse(boolean isReverse) {

        put(BasicServiceLevelAgreement.isReverse, isReverse);

    }



    public String getView() {

        return (String) get(BasicServiceLevelAgreement.view);

    }



    public void setView(String view) {

        put(BasicServiceLevelAgreement.view, view);

    }



    public boolean isByInstance() {

        return OptionalObjectUtils.booleanValue(get(ServiceLevelAgreement.byInstance), false);

    }



    public void isByInstance(boolean byInstance) {

        put(ServiceLevelAgreement.byInstance, byInstance);

    }



    public String getInstanceName() {

        return (String) get(ServiceLevelAgreement.instanceName);

    }



    public void setInstanceName(String instanceName) {

        put(ServiceLevelAgreement.instanceName, instanceName);

    }



    public int getConsistencyOffset() {

        return Integer.valueOf(get(BasicServiceLevelAgreement.consistencyOffset).toString());

    }



    public void setConsistencyOffset(int consistencyOffset) {

        put(BasicServiceLevelAgreement.consistencyOffset, consistencyOffset);

    }



    public void setMetricField(String metricField) {

        put(BasicServiceLevelAgreement.metricField, metricField);

    }



    public String getMetricField() {

        return (String) get(BasicServiceLevelAgreement.metricField);

    }



    public void setOverview(String overview) {

        put(BasicServiceLevelAgreement.overview, overview);

    }



    public String getOverview() {

        return (String) get(BasicServiceLevelAgreement.overview);

    }



    public void setCloseQuietly(int minutes) {

        put(BasicServiceLevelAgreement.closeQuietly, minutes);

    }



    public String getAlias() {

       return OptionalObjectUtils.stringValue(get(BasicServiceLevelAgreement.alias), null);

    }



    public void setAlias(String alias) {

        put(BasicServiceLevelAgreement.alias, alias);

    }



    @Override

    public List<Alert> validate(IQueryableStore store) {

        IQuery query = buidlQuery();

        List<Metric> metrics = new ArrayList<>();

        if (isByInstance()) {

            metrics.addAll(store.fetchMetricsByInstance(query, getEventType(), getEventField(), getInstanceName()).values());

        } else {

            metrics.add(store.fetchMetric(query, getAlias(), getEventType(), getEventField()));

        }

        return checkMetrics(metrics);

    }



    private IQuery buidlQuery() {

        DateTime consistentNow = getConsistentNow();

        IQuery query = new Query();

        query.addCriterion(Event.name, getEventName(), QueryCriterionType.Is);

        query.addCriterion(Event.type, getEventType(), QueryCriterionType.Is);

        query.addCriterion(Event.timestamp, getLowerBound(consistentNow), QueryCriterionType.GreaterOrEqualThan);

        query.addCriterion(Event.timestamp, getUpperBound(consistentNow), QueryCriterionType.LesserOrEqualThan);

        query.setQueryFilter(getQueryFilter());

        return query;

    }



    private List<Alert> checkMetrics(List<Metric> metrics) {

        ImmutableList.Builder<Alert> builder = new ImmutableList.Builder<>();

        for (Metric metric : metrics) {

            double value = (double) metric.get(getMetricField());

            if (metric.getCount() > 0) {

                Alert alert = checkMetric(metric, value);

                if (alert != null) {

                    builder.add(alert);

                }

            }

        }

        return builder.build();

    }



    private Alert checkMetric(Metric metric, double value) {

        if (!isReverse()) {

            if (metric.getMean() > getTargetOverBreached()) {

                return buildAlert(AlertPriority.Critical, value, getTargetOverBreached());

            }

            if (metric.getMean() > getTargetBreached()) {

                return buildAlert(AlertPriority.High, value, getTargetBreached());

            }

            if (metric.getMean() > getTargetThreatened()) {

                return buildAlert(AlertPriority.Medium, value, getTargetThreatened());

            }

            if (metric.getMean() > getTargetMet()) {

                return buildAlert(AlertPriority.Low, value, getTargetMet());

            }

            return buildAlert(AlertPriority.Info, value, 0.0);

        } else {

            if (metric.getMean() < getTargetOverBreached()) {

                return buildAlert(AlertPriority.Critical, value, getTargetOverBreached());

            }

            if (metric.getMean() < getTargetBreached()) {

                return buildAlert(AlertPriority.High, value, getTargetBreached());

            }

            if (metric.getMean() < getTargetThreatened()) {

                return buildAlert(AlertPriority.Medium, value, getTargetThreatened());

            }

            if (metric.getMean() < getTargetMet()) {

                return buildAlert(AlertPriority.Low, value, getTargetMet());

            }

            return buildAlert(AlertPriority.Info, value, 0.0);

        }

    }



    private Alert buildAlert(AlertPriority priority, double value, double threshold) {

        DateTime now = new DateTime().toDateTimeISO();



        StringBuilder message = new StringBuilder();

        if (priority != AlertPriority.Info) {

            message.append("The sla on field ").append(getEventField()).append(" from ").append(getEventName()).append(" has been broken. The mean  ").append(value).append(" has been over the threshold (").append(threshold).append(") for the last ")

                    .append(getPeriod()).append(" ").append(getTimeUnit().toString().toLowerCase()).append(".");



        } else {

            message.append("Current situation complies with SLA");

        }

        Alert alert = new Alert(priority, this.getName(), message.toString(), message.toString(), getName());

        alert.setPublisher(getPublisherName());

        alert.setBrokenSla(this.getName());

        alert.setStatus(AlertStatus.Open);

        return alert;

    }



    private DateTime getConsistentNow() {

        DateTime now = DateTime.now();

        switch (getTimeUnit()) {

        case MILLISECONDS:

            return now.minusMillis(getConsistencyOffset());

        case SECONDS:

            return now.minusSeconds(getConsistencyOffset());

        case MINUTES:

            return now.minusMinutes(getConsistencyOffset());

        case HOURS:

            return now.minusHours(getConsistencyOffset());

        case DAYS:

            return now.minusDays(getConsistencyOffset());

        default:

            break;

        }

        return now;

    }



    private DateTime getLowerBound(DateTime consistentNow) {

        DateTime lowerLimit = consistentNow;

        switch (getTimeUnit()) {

        case MILLISECONDS:

            lowerLimit = lowerLimit.minusMillis(getPeriod());

            break;

        case SECONDS:

            lowerLimit = lowerLimit.minusSeconds(getPeriod());

            break;

        case MINUTES:

            lowerLimit = lowerLimit.minusMinutes(getPeriod());

            break;

        case HOURS:

            lowerLimit = lowerLimit.minusHours(getPeriod());

            break;

        case DAYS:

            lowerLimit = lowerLimit.minusDays(getPeriod());

            break;

        default:

            break;

        }

        return lowerLimit;

    }



    private DateTime getUpperBound(DateTime consistentNow) {

        return consistentNow;

    }

}

package sgcib.tmon.worker.common.model;



import java.util.HashMap;



public class CachedEntry extends HashMap<String, Object> {

                public static String creationDate = "creationDate";

                public static String name = "name";

                public static String type = "type";



                public CachedEntry() {

                }



                public CachedEntry(String name, String type) {

                                this.setName(name);

                                this.setType(type);

                }



                public String getCreationDate() {

                                return (String) this.get(CachedEntry.creationDate);

                }



                public void setCreationDate(String creationDate) {

                                this.put(CachedEntry.creationDate, creationDate);

                }



                public String getName() {

                                return (String) this.get(CachedEntry.name);

                }



                public void setName(String name) {

                                this.put(CachedEntry.name, name);

                }



                public String getType() {

                                return (String) this.get(CachedEntry.type);

                }



                public void setType(String type) {

                                this.put(CachedEntry.type, type);

                }

}

package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.event.EventStore;



import java.util.HashMap;



/**

* Created by ekolonis120213 on 25/03/14.

*/

public abstract class CutoffBase extends HashMap<String, Object> implements ICutoff{

    public static String name = "name";

    public static String creationDate = "creationDate";

//    public static String workflow = "workflow";

//    public static String task = "task";

//    public static String host = "host";

    public static String component = "component";



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();

    protected Logger logger;



    public CutoffBase() {

    }



    public CutoffBase(String name) {

        setName(name);

        logger = LoggerFactory.getLogger(this.name);

    }



    public String getName() {

        return (String) get(CutoffBase.name);

    }



    public void setName(String name) {

        put(CutoffBase.name, name);

    }



    public DateTime getCreationDate() {

        return dateTimeFormatter.parseDateTime((String) get(CutoffBase.creationDate));

    }



    public void setCreationDate(DateTime timestamp) {

        put(CutoffBase.creationDate, timestamp.toDateTimeISO().toString());

    }



    public String getComponent() {

        return (String) get(CutoffBase.component);

    }



    public void  setComponent(String component) {

        put(CutoffBase.component,component);

    }

//

//    public String getWorkflow() {

//        return (String) get(CutoffBase.workflow);

//    }

//

//    public void  setWorkflow(String workflow) {

//        put(CutoffBase.workflow,workflow);

//    }

//

//    public String getTask() {

//        return (String) get(CutoffBase.task);

//    }

//

//    public void  setTask(String task) {

//        put(CutoffBase.task,task);

//    }

//

//    public String getHost() {

//        return (String) get(CutoffBase.host);

//    }

//

//    public void  setHost(String host) {

//        put(CutoffBase.host,host);

//    }



    public Alert[] validate(DateTime timeStamp, EventStore eventStore) {

        logger.trace("Start validation ...");

        try {

            return doValidate(timeStamp, eventStore);

        } catch (WorkerException error) {

            logger.error("... validation failed", error);

        } finally {

            logger.trace("... validation done");

        }

        return null;

    }



    protected abstract Alert[] doValidate(DateTime timeStamp, EventStore eventStore);



}

package sgcib.tmon.worker.common.model;



import sgcib.tmon.worker.common.store.cutoff.ICutoffStore;

import sgcib.tmon.worker.common.store.event.IEventStore;



import java.util.List;

/**

* Created by ekolonis120213 on 27/03/14.

*/

public class CutoffFactory implements ICutoffFactory{

    private final IEventStore eventStore;

    private final ICutoffStore cutoffStore;



    public CutoffFactory(IEventStore eventStore, ICutoffStore cutoffStore) {



        this.eventStore = eventStore;

        this.cutoffStore = cutoffStore;

    }



    @Override

    public List<BasicCutoff> getAllCutoffs() {

        return this.cutoffStore.getAllCutoffs();

    }

}

package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;



import java.io.Serializable;

import java.util.Map;

import java.util.UUID;



package sgcib.tmon.worker.common.model;



import com.google.common.collect.ImmutableList;

import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;



import java.io.Serializable;

import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.UUID;



/**

* Created by slopes041604 on 29/05/2015.

*/

public class Feature extends Queryable implements Serializable {

    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();

    public static String feature = "feature";

    public static String creationDate = "creationDate";

    public static String lastModificationDate = "lastModificationDate";

    public static String deliveryDate = "deliveryDate";

    public static String releaseDate = "releaseDate";

    public static String timeToMarketInDays = "timeToMarketInDays";

    public static String timeToDeliveryInDays= "timeToDeliveryInDays";

    public static String tickets = "tickets";



    public Feature(String name) {

        setName(name);

        setType("feature");

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        setValue(Feature.tickets, new ArrayList<String>());

    }



    public Feature(Map data) {

        super(data);

    }



    public String getFeature() {

        return (String) get(Feature.feature);

    }



    public void setFeature(String feature) {

        put(Feature.feature, feature);

    }



    public DateTime getCreationDate() {

        if (containsKey(Feature.creationDate)) {

            return dateTimeFormatter.parseDateTime(get(Feature.creationDate).toString());

        }

        return null;

    }



    public void setCreationDate(DateTime creationDate) {

        put(Feature.creationDate, creationDate);

    }



    public DateTime getReleaseDate() {

        if (containsKey(Feature.releaseDate)) {

            return dateTimeFormatter.parseDateTime(get(Feature.releaseDate).toString());

        }

        return null;

    }



    public void setReleaseDate(DateTime releaseDate) {

        if (releaseDate != null) {

            put(Feature.releaseDate, releaseDate);

            DateTime creationDate = getCreationDate();

            if (creationDate != null && creationDate.toDateTimeISO().isBefore(releaseDate.toDateTimeISO())) {

                setTimeToMarketInDays((releaseDate.toDateTimeISO().getMillis() - creationDate.toDateTimeISO().getMillis()) / (24 * 3600 * 1000));

            }

        }

    }



    public void setTimeToDeliveryInDays(DateTime deliveryDate) {

        if (deliveryDate != null) {

            DateTime currentDeliveryDate = getDeliveryDate();

            if ( currentDeliveryDate == null || currentDeliveryDate.isAfter(deliveryDate)) {

                put(Feature.deliveryDate, deliveryDate);

                DateTime creationDate = getCreationDate();

                if (creationDate != null && creationDate.toDateTimeISO().isBefore(deliveryDate.toDateTimeISO())) {

                    setTimeToMarketInDays((deliveryDate.toDateTimeISO().getMillis() - creationDate.toDateTimeISO().getMillis()) / (24 * 3600 * 1000));

                }

            }

        }

    }



    public DateTime getDeliveryDate() {

        if (containsKey(Feature.deliveryDate)) {

            return dateTimeFormatter.parseDateTime(get(Feature.deliveryDate).toString());

        }

        return null;

    }



    public long getTimeToMarketInDays() {

        return (long) get(Feature.timeToMarketInDays);

    }



    public void setTimeToMarketInDays(long timeToMarket) {

        put(Feature.timeToMarketInDays, timeToMarket);

    }





    public DateTime getLastModificationDate() {

        if (containsKey(Feature.lastModificationDate)) {

            return dateTimeFormatter.parseDateTime(get(Feature.lastModificationDate).toString());

        }

        return null;

    }



    public void setLastModificationDate(DateTime lastModificationDate) {

        put(Feature.lastModificationDate, lastModificationDate);

    }



    public void addTiket(String ticket) {

        List<String> tickets = (List<String>) get(Feature.tickets);

        if (tickets != null && !tickets.contains(ticket)) {

            tickets.add(ticket);

        }

    }



    public List<String> getTickets() {

        return ImmutableList.copyOf((List<String>) get(Feature.tickets));

    }

}

package sgcib.tmon.worker.common.model;




package sgcib.tmon.worker.common.model;



public interface IClock {

    /**

     * @return an IDate representing the current date

     */

    IDate now();



    /**

     * @return an IDate representing a long time ago, like the Epoch.

     */

    IDate longTimeAgo();



    /**

     * @return an IDate representing the day before today

     */

    IDate yesterday();



    /**

     * @return an IDate representing 2 days ago

     */

    IDate twoDaysAgo();



    boolean isYesterdayOrBefore(IDate date);

}

package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.store.event.EventStore;




package sgcib.tmon.worker.common.model;




package sgcib.tmon.worker.common.model;



import java.io.Serializable;

import java.util.List;



/**

* Created by Stephane on 11/04/2015.

*/

public interface IQuery extends Serializable{

    IQuery addCriterion(List<QueryCriterion> criteria);

    IQuery addCriterion(QueryCriterion... criteria);

    IQuery addCriterion(String field, Comparable value, QueryCriterionType type);

    List<QueryCriterion> getCriteria();

    void setQueryFilter(String queryFilter);

    String getQueryFilter();

    boolean match(Queryable item);

    void sortAsc(String field);

    void sortDesc(String field);

}

package sgcib.tmon.worker.common.model;



import java.util.List;



import org.joda.time.DateTime;



import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



public interface IServiceLevelAgreement {



    String getName();



    DateTime getCreationDate();



    ServiceLevelAgreementType getServiceLevelAgreementType();



    List<Alert> validate(IQueryableStore store);

}

package sgcib.tmon.worker.common.model;



import java.util.List;





public  interface IServiceLevelAgreementFactory {

    ServiceLevelAgreement build ( String name);

    List<ServiceLevelAgreement> buildAll ();

}

package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;



public class JodaClock implements IClock {

    protected IDate nowMinusDays(int days) {

        JodaDate date = new JodaDate();

        date.datetime = date.datetime.minusDays(days);

        return date;

    }



    @Override

    public IDate now() {

        return nowMinusDays(0);

    }



    @Override

    public IDate longTimeAgo() {

        JodaDate date = new JodaDate();

        date.datetime = new DateTime(0l);

        return date;

    }



    /**

     * @return an IDate representing the day before today

     */

    @Override

    public IDate yesterday() {

        return nowMinusDays(1);

    }



    /**

     * @return an IDate representing 2 days ago

     */

    @Override

    public IDate twoDaysAgo() {

        return nowMinusDays(2);

    }



    @Override

    public boolean isYesterdayOrBefore(IDate date) {

        assert (date instanceof JodaDate);

        return ((JodaDate) date).datetime.withTimeAtStartOfDay().isBefore(((JodaDate) yesterday()).datetime.withTimeAtStartOfDay());

    }

}

package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;



public class JodaDate implements IDate {

    public DateTime datetime = DateTime.now();



    @Override

    public String toString() {

        return datetime.toString();

    }

}

package sgcib.tmon.worker.common.model;



/**

* Date: 18/08/13

* Time: 17:16

* This file is part of biopsy.

* biopsy is free software: you can redistribute it and/or modify

* it under the terms of the GNU General Public License as published by

* the Free Software Foundation, either version 3 of the License, or

* (at your option) any later version.

* biopsy is distributed in the hope that it will be useful,

* but WITHOUT ANY WARRANTY; without even the implied warranty of

* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License

* along with biopsy.  If not, see <http://www.gnu.org/licenses/>.

*/



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;



import java.util.Map;

import java.util.UUID;



public class Metric extends Queryable {



    public static String name = "name";

    public static String key = "key";

    public static String count = "count";

    public static String maximum = "maximum";

    public static String minimum = "minimum";

    public static String squareSum = "squareSum";

    public static String sum = "sum";

    public static String stop = "stop";

    public static String start = "start";

    public static String timeout = "timeout";

    public static String last = "last";

    public static String mean = "mean";

    public static String queryFilter = "queryFilter";



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    public Metric() {

        super("metric");

        reset();

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

    }



    public Metric(Map data) {

        super(data);

    }



    public Metric(String name) {

        this();

        setName(name);

    }



    public String getName() {

        return (String) get(Metric.name);

    }



    public void setName(String name) {

        put(Metric.name, name);

    }



    public String getKey() {

        return (String) get(Metric.key);

    }



    public void setKey(String key) {

        put(Metric.key, key);

    }



    public long getCount() {

        return (Long) get(Metric.count);

    }



    public void setCount(long count) {

        put(Metric.count, count);

    }



    public DateTime getStart() {

        return dateTimeFormatter.parseDateTime((String) get(Metric.start));

    }



    public void setStart(DateTime start) {

        put(Metric.start, start.toDateTimeISO().toString());

    }



    public DateTime getStop() {

        return dateTimeFormatter.parseDateTime((String) get(Metric.stop));

    }



    public void setStop(DateTime stop) {

        put(Metric.stop, stop.toDateTimeISO().toString());

    }



    public double getSum() {

        return (Double) get(Metric.sum);

    }



    public void setSum(double sum) {

        put(Metric.sum, sum);

    }



    public double getMinimum() {

        return (Double) get(Metric.minimum);

    }



    public void setMinimum(double minimum) {

        put(Metric.minimum, minimum);

    }



    public double getMaximum() {

        return (Double) get(Metric.maximum);

    }



    public void setMaximum(double maximum) {

        put(Metric.maximum, maximum);

    }



    public double getSquareSum() {

        return (Double) get(Metric.squareSum);

    }



    public void setSquareSum(double squareSum) {

        put(Metric.squareSum, squareSum);

    }



    public int getTimeout() {

        return (Integer) get(Metric.timeout);

    }



    public void setTimeout(int timeout) {

        put(Metric.timeout, timeout);

    }



    public double getLast() {

        return (Double)get(Metric.last);

    }



    public void setLast(double last) {

        put(Metric.last, last);

    }



    public double getMean() {

        return (Double)get(Metric.mean);

    }



    public void setMean(double mean) {

        put(Metric.mean, mean);

    }



    public synchronized double standardDeviation() {

        long count = getCount();

        double sum = getSum();

        if (count == 0)

            return 0.0;

        double sigma = (getSquareSum() / count)

                - ((sum * sum) / (count * count));

        return Math.sqrt(sigma);

    }



    /*public synchronized double getMean() {

        long count = getCount();

        if (count == 0)

            return 0;

        return getSum() / count;

    }*/



    public synchronized void add(double value) {

        setMean((getMean()*getCount()+value)/(getCount()+1));

        setCount(getCount() + 1);

        setMinimum(Math.min(getMinimum(), value));

        setMaximum(Math.max(getMaximum(), value));

        setSum(getSum() + value);

        setSquareSum(getSquareSum() + (value * value));

        setLast(value);

    }



    public synchronized void merge(Metric other) {

        if (other == null) return;

        setMean((getMean()*getCount() + other.getMean()*other.getCount())/(getCount()+other.getCount()));

       setCount(getCount() + other.getCount());

        setMinimum(Math.min(getMinimum(), other.getMinimum()));

        setMaximum(Math.max(getMaximum(), other.getMaximum()));

        setSum(getSum() + other.getSum());

        setSquareSum(getSquareSum() + other.getSquareSum());

        if (getStart() != null && other.getStart() != null && getStop() != null && other.getStop() != null) {



            if (getStart().isAfter(other.getStart())) {

                setStart(other.getStart());

            }



            if (getStop().isBefore(other.getStop())) {

                setStart(other.getStop());

            }

        }

    }



    public synchronized void reset() {

        setCount(0);

        setMinimum(Double.MAX_VALUE);

        setMaximum(Double.MIN_VALUE);

        setSum(0.0);

        setSquareSum(0.0);

        setStart(new DateTime());

        setStop(new DateTime());

        setTimeout(0);

        setLast(0);

        setMean(0.0);

    }



    public String getQueryFilter() {

        return (String) get(Metric.queryFilter);

    }



    public void setQueryFilter(String queryFilter) {

        put(Metric.queryFilter, queryFilter);

    }

}package sgcib.tmon.worker.common.model;



import java.io.Serializable;

import java.util.ArrayList;

import java.util.Collections;

import java.util.List;



import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.ObjectMapper;



/**

* Created by slopes041604 on 12/05/2015.

*/


package sgcib.tmon.worker.common.model;



import org.joda.time.DateTime;



import java.io.Serializable;



/**

* Created by Stephane on 11/04/2015.

*/


package sgcib.tmon.worker.common.model;



/**

* Created by Stephane on 11/04/2015.

*/



package sgcib.tmon.worker.common.model;



/**

* Created by pdedaran120210 on 13/05/2015.

*/

public class QueryFromReference extends Query implements IQuery {

    final Queryable reference;



    public QueryFromReference(Queryable reference) {

        this.reference = reference;

    }



    public QueryFromReference addCriterion(String chainField, String eventField) {

        addCriterion(chainField, (Comparable) reference.getValue(eventField), QueryCriterionType.Is);

        return this;

    }



    public QueryFromReference addCriterion(String field) {

        return addCriterion(field, field);

    }



}

package sgcib.tmon.worker.common.model;



import java.io.Serializable;

import java.lang.reflect.InvocationTargetException;

import java.util.*;



import javax.validation.constraints.NotNull;



import com.fasterxml.jackson.datatype.joda.JodaModule;

import org.joda.time.DateTime;

import org.joda.time.LocalDate;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.google.common.base.Function;

import com.google.common.collect.Lists;

import com.google.common.collect.Maps;

import com.google.common.collect.Ordering;



/**

* Created by slopes041604 on 12/05/2015.

*/

public class Queryable extends HashMap<String, Object> implements Serializable {



    private static final long DEFAULT_VERSION = 0l;



    public static final String key = "key";

    public static final String type = "type";

    public static final String name = "name";

    public static final String timestamp = "@timestamp";

    public static final String error = "error";

    public static final String drop = "drop";

    public static final String ruleTaskName = "ruleTaskName";

    public static final String version = "version";

    //Process Start Time

    public static String ruleStartDate = "ruleStartDate";



    private static final ObjectMapper mapper = new ObjectMapper();

    private static final long serialVersionUID = 1L;

    protected static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();

    public static Ordering<Queryable> orderByTimestamp = new Ordering<Queryable>() {

        @Override

        public int compare(Queryable q1, Queryable q2) {

            if (q1 == null && q2 == null) {

                return 1;

            }

            if (q1 == null) {

                return 1;

            }

            if (q2 == null) {

                return 0;

            }

            DateTime t1 = q1.getTimestamp();

            DateTime t2 = q2.getTimestamp();

            if (t1 == null && t2 == null) {

                return 1;

            }

            if (t1 == null) {

                return 1;

            }

            if (t2 == null) {

                return 0;

            }

            return t1.compareTo(t2);

        }

    };

    private static Logger LOGGER = LoggerFactory.getLogger(Queryable.class);



    /**

     * Default constructor. Whatever the constructor called, the property

     * {@code key} must be present.

     */

    public Queryable() {

        generateKey();

        setMapperDateTimeConfiguration();

    }



    public Queryable(Map data) {

        if (data != null && !data.containsKey(Queryable.key)) {

            generateKey();

            setMapperDateTimeConfiguration();

        }

        putAll(data);

    }



    public Queryable(String type) {

        this();

        setType(type);

    }



    /* Properties */



    public Queryable(String name, String type) {

        this();

        setName(name);

        setType(type);

    }



    public static <T extends Queryable> List<Queryable> toList(List<T> items) {

        return Lists.transform(items, new Function<T, Queryable>() {

            @Override

            public Queryable apply(T item) {

                return item;

            }

        });

    }



    public static <T extends Map, R extends Queryable> List<R> transformToList(List<T> items, Class<R> toClass) {

        try {

            List<R> synchronizedList = Collections.synchronizedList(new ArrayList<R>());

            if (items != null) {

                for (Map m : items) {

                    synchronizedList.add(toClass.getConstructor(Map.class).newInstance(m));

                }

            }

            return synchronizedList;

        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {

            LOGGER.error("Error when transformToList", e);

        }

        return null;

    }



    public static <T extends Queryable> List<T> fromList(List<Queryable> items) {

        return Lists.transform(items, new Function<Queryable, T>() {

            @Override

            public T apply(Queryable item) {

                return (T) item;

            }

        });

    }



    @NotNull

    public String getType() {

        return (String) get(Queryable.type);

    }



    public void setType(String type) {

        put(Queryable.type, type);

    }



    public String getId() {

        return (String) get(Queryable.key);

    }



    public void setId(String id) {

        put(Queryable.key, id);

    }



    public boolean hasId() {

        return containsKey(Queryable.key);

    }



    public DateTime getTimestamp() {

        Object value = get(Queryable.timestamp);

        if (value instanceof String) {

            return dateTimeFormatter.parseDateTime(value.toString());

        }

        if (value instanceof Long) {

            return new DateTime(value);

        }



        return (DateTime) get(Queryable.timestamp);

    }



    public void setTimestamp(DateTime timestamp) {

        put(Queryable.timestamp, timestamp);

    }



    public String getName() {

        return (String) get(Queryable.name);

    }



    public void setName(String name) {

        put(Queryable.name, name);

    }



    /* Utilities */



    public String getError() {

        return (String) get(Queryable.error);

    }



    public String getRuleTaskName() {

        return (String) get(Queryable.ruleTaskName);

    }





    public void setRuleTaskName(String ruleTaskName) {

         put(Queryable.ruleTaskName,ruleTaskName);

    }



    public void setError(String error) {

        put(Queryable.error, error);

    }



    public boolean hasError() {

        return containsKey(Queryable.error);

    }



    public Queryable copyFields(Queryable other, boolean overrideIfPresent, String... fieldsToCopy) {

        for (String field : fieldsToCopy) {

            copyField(other, overrideIfPresent, field, field);

        }

        return this;

    }



    public Queryable copyField(Queryable other, boolean overrideIfPresent, String destinationField, String fieldToCopy) {

        if (other.containsKey(fieldToCopy)) {

            if (this.getValue(destinationField) == null) {

                this.setValue(destinationField, other.getValue(fieldToCopy));

            } else if (overrideIfPresent) {

                if (!mergeValues(this.get(destinationField), other.getValue(fieldToCopy))) {

                    this.setValue(destinationField, other.getValue(fieldToCopy));

                }

            }

        }

        return this;

    }



    private boolean mergeValues(Object local, Object other) {

        if (local == null && other == null) {

            return true;

        }

        if (local == null || other == null) {

            return false;

        }



        if (local.getClass().equals(other.getClass())) {

            if (local instanceof Map) {

                Map localMap = (Map) local;

                Map otherMap = (Map) other;

                for (Object otherMapKey : otherMap.keySet()) {

                    if (!localMap.containsKey(otherMapKey)) {

                        localMap.put(otherMapKey, otherMap.get(otherMapKey));

                    } else if (!mergeValues(localMap.get(otherMapKey), otherMap.get(otherMapKey))) {

                        localMap.put(otherMapKey, otherMap.get(otherMapKey));

                    }

                }

                return true;

            } else if (local instanceof List) {

                List localList = (List) local;

                List otherList = (List) other;

                for (Object item : localList) {

                    if (!otherList.contains(item)) {

                        otherList.add(item);

                    }

                }

                return true;

            }

        }

        return false;

    }



    public void setValue(String key, Object value) {

        String[] keys = key.split("\\.");

        Map<String, Object> map = this;

        for (int i = 0; i < keys.length; i++) {

            if (i == keys.length - 1) {

                map.put(keys[i], value);

            } else {

                if (!map.containsKey(keys[i])) {

                    map.put(keys[i], Maps.newHashMap());

                }

                map = (Map<String, Object>) map.get(keys[i]);

            }

        }

    }



    public Object getValue(String key) {

        String[] items = key.split("\\.");



        Map map = this;

        for (int i = 0; i < items.length; i++) {

            if (!map.containsKey(items[i])) {

                return null;

            }

            Object found = map.get(items[i]);

            if (i == items.length - 1) {

                return found;

            }

            if (!(found instanceof Map)) {

                return null;

            }

            map = (Map) found;

        }

        return null; // never called

    }



    public DateTime getValueAsDateTime(String key) {

        Object val = getValue(key);

        if (null == val) {

            return null;

        }

        if (val instanceof DateTime) {

            return (DateTime) val;

        }

        return DateTime.parse(val.toString());

    }



    public LocalDate getValueAsDate(String key) {

        Object val = getValue(key);

        if (null == val) {

            return null;

        }

        if (val instanceof LocalDate) {

            return (LocalDate) val;

        }

        return LocalDate.parse(val.toString());

    }



    public Boolean getValueAsBoolean(String key) {

        return getValueAsBoolean(key, false);

    }



    public Boolean getValueAsBoolean(String key, Boolean defaultValue) {

        Object val = getValue(key);

        if (null == val) {

            return defaultValue;

        }

        if (val instanceof Boolean) {

            return (Boolean) val;

        }

        return new Boolean(val.toString());

    }



    /**

     * Import all criteria from the given query {@code query} if not null.

     *

     * @param query

     *            The {@link IQuery} instance.

     */

    public void importCriteria(IQuery query) {

        if (query != null) {

            for (QueryCriterion criterion : query.getCriteria()) {

                setValue(criterion.getField(), criterion.getValue());

            }

        }

    }



    // Equals & hashCode



    @Override

    public boolean equals(Object obj) {

        if (obj == null) {

            return false;

        }

        if (getClass() != obj.getClass()) {

            return false;

        }

        final Queryable other = (Queryable) obj;

        return com.google.common.base.Objects.equal(this.getId(), other.getId());

    }



    @Override

    public int hashCode() {

        return com.google.common.base.Objects.hashCode(this.getId());

    }



    // Convenient methods



    /**

     * Set a random unique ID as key.

     */

    private void generateKey() {

        this.setId(UUID.randomUUID().toString());

    }



    /**

     * This function return the current object in JSON format

     *

     * @return Current object in JSON format

     */

    public String toJSON() {

        try {



            return mapper.writeValueAsString(this);

        } catch (JsonProcessingException e) {

            LOGGER.error("Error on toJSON method", e);

            return null;

        }

    }



    private void setMapperDateTimeConfiguration()

    {

        if(mapper != null) {

            mapper.registerModule(new JodaModule());

            mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

            mapper.setTimeZone(TimeZone.getDefault());

        }

    }

    public long getVersion() {

        return (long) java.util.Optional.ofNullable(get(Queryable.version)).orElse(DEFAULT_VERSION);

    }



    public void setVersion(long version) {

        put(Queryable.version, version);

    }



    public void setCurrentTimeAsVersion() {

        put(Queryable.version, System.nanoTime());

    }

}

package sgcib.tmon.worker.common.model;



import java.util.Map;

import java.util.concurrent.TimeUnit;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;



import sgcib.tmon.worker.common.utils.OptionalObjectUtils;



/**

* Created by Stephane on 16/05/2015.

*/

public abstract class ServiceLevelAgreement extends Queryable implements IServiceLevelAgreement {



    // Max value in minutes (in IHM).

    private static final int CLOSE_QUIETLY_DEFAULT = 60;



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();

    public static String name = "name";

    public static String creationDate = "creationDate";

    public static String serviceLevelAgreement = "serviceLevelAgreement";

    public static String serviceLevelAgreementType = "serviceLevelAgreementType";

    public static String byInstance = "byInstance";

    public static String instanceName = "instanceName";

    public static String period = "period";

    public static String timeUnit = "timeUnit";

    public static String closeQuietly = "closeQuietly";



    private String publisherName;



    public ServiceLevelAgreement() {

        setCreationDate(DateTime.now());

        setType(ServiceLevelAgreement.serviceLevelAgreement);

    }



    public ServiceLevelAgreement(String name) {

        setName(name);

        setCreationDate(DateTime.now());

        setType(ServiceLevelAgreement.serviceLevelAgreement);

        put(ServiceLevelAgreement.key, name);

    }



    public ServiceLevelAgreement(Map data) {

        putAll(data);

        setType(ServiceLevelAgreement.serviceLevelAgreement);

    }



    public ServiceLevelAgreement(String name, DateTime creationDate) {

        setName(name);

        setCreationDate(creationDate);

        setType(ServiceLevelAgreement.serviceLevelAgreement);

        put(ServiceLevelAgreement.key, name);

    }



    @Override

    public DateTime getCreationDate() {

        Object value = get(ServiceLevelAgreement.creationDate);

        if (value instanceof String) {

            return dateTimeFormatter.parseDateTime(value.toString());

        } else {

            return (DateTime) get(ServiceLevelAgreement.creationDate);

        }

    }



    public void setCreationDate(DateTime timestamp) {

        put(ServiceLevelAgreement.creationDate, timestamp.toDateTimeISO().toString());

    }



    @Override

    public ServiceLevelAgreementType getServiceLevelAgreementType() {

        return (ServiceLevelAgreementType) get(ServiceLevelAgreement.serviceLevelAgreementType);

    }



    public void setServiceLevelAgreementType(ServiceLevelAgreementType serviceLevelAgreementType) {

        put(ServiceLevelAgreement.serviceLevelAgreementType, serviceLevelAgreementType);

    }



    public String getPublisherName() {

        return publisherName;

    }



    public void setPublisherName(String publisherName) {

        this.publisherName = publisherName;

    }



    public TimeUnit getTimeUnit() {

        return TimeUnit.valueOf((String) get(ServiceLevelAgreement.timeUnit));

    }



    public int getPeriod() {

        return OptionalObjectUtils.intValue(get(ServiceLevelAgreement.period), 0);

    }



    public int getCloseQuietly() {

        return OptionalObjectUtils.intValue(get(ServiceLevelAgreement.closeQuietly), CLOSE_QUIETLY_DEFAULT);

    }

}

package sgcib.tmon.worker.common.model;



import sgcib.tmon.worker.common.store.sla.IServiceLevelAgreementStore;



import java.util.List;



public class ServiceLevelAgreementFactory implements IServiceLevelAgreementFactory {

                private final IServiceLevelAgreementStore store;



                public ServiceLevelAgreementFactory(IServiceLevelAgreementStore store) {

                                this.store = store;

                }



                @Override

                public ServiceLevelAgreement build(String name) {

                                return store.read(name);

                }



                @Override

                public List<ServiceLevelAgreement> buildAll() {

                                return store.getAllAgreements();

                }



}

package sgcib.tmon.worker.common.model;



public enum ServiceLevelAgreementType {



    Basic("Basic");



    private String value;



    ServiceLevelAgreementType(String value) {

        this.value = value;

    }



    public String getValue() {

        return value;

    }



    @Override

    public String toString() {

        return this.getValue();

    }

}

package sgcib.tmon.worker.common.model;



public enum Severity {

    INFO,

    ERROR,

    WARNING

}

package sgcib.tmon.worker.common.model;



/**

* Created by adouangp012014 on 07/02/14.

*/

public enum StatusExecutionType {

    Ok, Error

}

package sgcib.tmon.worker.common.model;



import org.springframework.security.core.GrantedAuthority;

import org.springframework.security.core.authority.SimpleGrantedAuthority;

import org.springframework.security.core.userdetails.UserDetails;



import java.util.Collection;

import java.util.HashSet;

import java.util.Map;



/**

* Created by ekolonis120213 on 03/02/14.

*/

public class User extends Queryable implements UserDetails{



    public static String email = "email";

    public static String password = "password";

    public static String role = "role";

    public static String token = "token";

    public static Collection<SimpleGrantedAuthority> authorities = new HashSet<SimpleGrantedAuthority>();



    public User() {

        setType("user");

        setName("user");

    }



    public User(Map data) {

        putAll(data);

    }



    public User(String email, String password, String role, Collection<SimpleGrantedAuthority> grantedAuthorities) {

        this();

        setId(email);

        setEmail(email);

        setPassword(password); //TODO : manage crypting

        setRole(role);

        setAuthorities(grantedAuthorities);

    }



    public void setEmail(String email) {

        put(User.key, email);

        put(User.email, email);

    }



    //@NotNull

    public String getEmail() {

        return (String) get(User.email);

    }



    public void setPassword(String password) {

        put(User.password, password);

    }



    @Override

    public Collection<? extends GrantedAuthority> getAuthorities() {

        return null;

    }



    //@NotNull

    public String getPassword() {

    return (String) get(User.password);

    }



    public void setToken(String token) {

        put(User.token, token);

    }



    public String getToken() {

        return (String) get(User.token);

    }



    @Override

    public String getUsername() {

        return (String) get(User.email);

    }



    @Override

    public boolean isAccountNonExpired() {

        return true;

    }



    @Override

    public boolean isAccountNonLocked() {

        return true;

    }



    @Override

    public boolean isCredentialsNonExpired() {

        return true;

    }



    @Override

    public boolean isEnabled() {

        return true;

    }



    public void setRole(String role) {

        put(User.role, role);

    }



    public String getRole() {

        return (String) get(User.role);

    }



    public void setAuthorities(Collection<SimpleGrantedAuthority> authorities) {

        this.authorities = authorities;

    }

}

package sgcib.tmon.worker.common.model;



import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;



import javax.validation.constraints.NotNull;

import java.util.HashMap;



/**

* Created by tbarraul080910 on 25/08/2014.

*/

public class Worker extends HashMap<String, Object> {



    public static String name = "name";

    public static String status = "status";



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    public Worker() {



    }





    @NotNull

    public String getName() {

        return (String) get(Worker.name);

    }



    public void setName(String name) {

        put(Worker.name, name);

    }



    @NotNull

    public String getStatus() {

        return (String) get(Worker.status);

    }



    public void setStatus(String status) {

        put(Worker.status, status);

    }

}

package sgcib.tmon.worker.common.monitor;



/**

* Created by slopes041604 on 09/10/2015.

*/

public interface IHistogram {

    long start();

    void stop(long start);

}

package sgcib.tmon.worker.common.monitor;



import sgcib.tmon.worker.common.lifecycle.IManageable;



/**

* Created by slopes041604 on 09/10/2015.

*/

public interface IHistogramFactory {

    IHistogram build(IManageable manageable, String name);

}

package sgcib.tmon.worker.common.monitor;



import com.codahale.metrics.Histogram;

import com.codahale.metrics.MetricRegistry;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;



/**

* Created by slopes041604 on 09/10/2015.

*/

public class MetricHistogram implements IHistogram {

    private final Histogram histogram;



    public MetricHistogram(IManageable manageable, String name) {

        MetricRegistry registry = new MetricRegistry();

        if ( manageable != null) {

            this.histogram = registry.histogram(String.format("%s.%s", manageable.getName(), name));

        } else {

            this.histogram = null;

        }

    }



    @Override

    public long start() {

        return System.nanoTime();

    }



    @Override

    public void stop(long start) {

        long stop = System.nanoTime();

        if ( histogram != null) {

            histogram.update((stop - start) / 1000000);

        }

    }

}

package sgcib.tmon.worker.common.monitor;



import sgcib.tmon.worker.common.lifecycle.IManageable;



/**

* Created by slopes041604 on 09/10/2015.

*/

public class MetricHistogramFactory implements IHistogramFactory {

    @Override

    public IHistogram build(IManageable manageable, String name) {

        return new MetricHistogram(manageable,name);

    }

}

package sgcib.tmon.worker.common.processor;



import java.util.concurrent.Callable;



public class AsyncProcessor<T> implements Callable<AsyncProcessorResult> {



    private final IProcessor<T> processor;

    private final T item;



    public AsyncProcessor(IProcessor<T> processor, T item) {

        this.processor = processor;

        this.item = item;

    }



    @Override

    public AsyncProcessorResult call() throws Exception {

        if (this.processor != null) {

            try {

                this.processor.process(this.item);

                return new AsyncProcessorResult(this.processor.getName(), true, null);

            } catch (Exception error) {

                return new AsyncProcessorResult(this.processor.getName(), false, error);

            }

        } else {

            return new AsyncProcessorResult("unknown", false, null);

        }

    }

}

package sgcib.tmon.worker.common.processor;



public class AsyncProcessorResult {

    private final String name;

    private final boolean occurred;

    private final Exception error;



    public AsyncProcessorResult(String name, boolean occurred, Exception error) {

        this.name = name;

        this.occurred = occurred;

        this.error = error;

    }



    public String getName() {

        return name;

    }



    public boolean hasOccurred() {

        return occurred;

    }





    public Exception getError() {

        return error;

    }

}

package sgcib.tmon.worker.common.processor;



import java.util.Collection;



public abstract class CompositeProcessorBase<T> extends ProcessorBase<T> {



    private final Collection<IProcessor<T>> processors;



    protected CompositeProcessorBase(String name, Collection<IProcessor<T>> processors) {

        super(name);

        this.processors = processors;

    }



    @Override

    protected void doProcess(T item) {

        if (this.processors != null) {

               doCompose(this.processors,item);

        }

    }



    public long getFlags() {

        long flags = 0;

        for (IProcessor<T> processor : this.processors)

        {

            flags |= processor.getFlags();

        }

        return flags;

    }



    protected abstract void doCompose(Collection<IProcessor<T>> processors,final T item);





}

package sgcib.tmon.worker.common.processor;



import sgcib.tmon.worker.common.lifecycle.IManageable;



public interface IProcessor<T> extends IManageable {

    void process(final T item);

    String getName();

    long getFlags();

    void setFlags(long flags);

}

package sgcib.tmon.worker.common.processor;



public class LoggerProcessor<T> extends ProcessorBase<T> {



    public LoggerProcessor(String name) {

       super(name);

    }



    @Override

    protected void doProcess(T item) {

        this.getLogger().trace(item.toString());

    }



    @Override

    protected void doCreate() {



    }



    @Override

    protected void doDestroy() {



    }

}

package sgcib.tmon.worker.common.processor;



import com.google.common.util.concurrent.ListeningExecutorService;

import com.google.common.util.concurrent.MoreExecutors;



import java.util.ArrayList;

import java.util.Collection;

import java.util.List;

import java.util.concurrent.*;





public class ParallelProcessor<T> extends CompositeProcessorBase<T> {



    private final int poolSize;

    private final long timeout;

    private final TimeUnit timeoutUnit;

    private ListeningExecutorService pool;



    public ParallelProcessor(String name, Collection<IProcessor<T>> processors, int poolSize, long timeout, TimeUnit timeoutUnit) {

        super(name, processors);

        this.poolSize = poolSize;

        this.timeout = timeout;

        this.timeoutUnit = timeoutUnit;

    }



    @Override

    protected void doCompose(Collection<IProcessor<T>> processors, final T item) {



        final List<Callable<AsyncProcessorResult>> tasks = new ArrayList<Callable<AsyncProcessorResult>>();

        for (final IProcessor processor : processors) {

            tasks.add(new AsyncProcessor<T>(processor, item));

        }



        List<Future<AsyncProcessorResult>> futures = null;



        try {

            try {

                futures = pool.invokeAll(tasks, timeout, timeoutUnit);

            } catch (InterruptedException error) {

                getLogger().error("Processing cancelled !!!", error);

            }

            for (Future<AsyncProcessorResult> future : futures) {

                AsyncProcessorResult result = future.get();

                if (result.hasOccurred()) {

                    getLogger().trace("Processing occurred for processor {} ", result.getName());

                } else {

                    if (result.getError() != null) {

                        getLogger().error("Processing failed for processor {} ", result.getName(), result.getError());

                    }



                }

            }

        } catch (ExecutionException executionError) {

            getLogger().trace("Processing failed !!!", executionError);

        } catch (InterruptedException cancellationError) {

            getLogger().error("Processing cancelled !!!", cancellationError);

        }





    }



    @Override

    protected void doCreate() {

        this.pool = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(this.poolSize));

    }



    @Override

    protected void doDestroy() {

        this.pool.shutdown();

    }







}

package sgcib.tmon.worker.common.processor;





import sgcib.tmon.worker.common.exception.WorkerException;



public class ProcessingException extends WorkerException {



    private final String processor;



    public ProcessingException(String processor) {

        super();    //To change body of overridden methods use File | Settings | File Templates.

        this.processor = processor;

    }



    public ProcessingException(String message, String processor) {

        super(message);    //To change body of overridden methods use File | Settings | File Templates.

        this.processor = processor;

    }



    public ProcessingException(Throwable cause, String processor) {

        super(cause);    //To change body of overridden methods use File | Settings | File Templates.

        this.processor = processor;

    }



    public ProcessingException(String message, Throwable cause, String processor) {

        super(message, cause);    //To change body of overridden methods use File | Settings | File Templates.

        this.processor = processor;

    }



    public ProcessingException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace, String processor) {

        super(message, cause, enableSuppression, writableStackTrace);    //To change body of overridden methods use File | Settings | File Templates.

        this.processor = processor;

    }

}

package sgcib.tmon.worker.common.processor;



import org.apache.commons.lang3.StringUtils;

import org.elasticsearch.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.monitor.IHistogram;



import java.util.List;





public abstract class ProcessorBase<T> extends ManageableBase implements IProcessor<T> {



    protected long flags;





    protected ProcessorBase(String name) {

        super(name);

        if (!StringUtils.isNotBlank(name)) {

            throw new IllegalArgumentException("Blank or empty name are not valid");

        }

    }



    public long getFlags() {

        return this.flags;

    }



    public void setFlags(long flags) {

        this.flags = flags;

    }



    @Override

    public void process(final T item) {



        getLogger().trace("Start processing item ...");

        try {

            if (item != null) {

                doProcess(item);

            } else {

                getLogger().trace("Null item processed.");

            }

        } catch (WorkerException error) {

            getLogger().error("... item processing failed", error);

        } finally {

            getLogger().debug("... item processing done");



        }

    }



    protected abstract void doProcess(final T item) throws WorkerException;



    @Override

    public void start() throws WorkerException {

        getLogger().trace("Start creating processor ...");

        try {

            doCreate();

        } catch (WorkerException error) {

            getLogger().error("... creation of processor failed", error);

        } finally {

            getLogger().trace("... processor created");

        }

    }



    protected abstract void doCreate() throws WorkerException;



    @Override

    public void stop() throws WorkerException {

        getLogger().trace("Start destroying processor ...");

        try {

            doDestroy();

        } catch (WorkerException error) {

            getLogger().error("... destruction of processor failed", error);

        } finally {

            getLogger().trace("... processor destroyed");

        }

    }



    protected abstract void doDestroy() throws WorkerException;





}



package sgcib.tmon.worker.common.processor;



import java.util.EnumSet;

import java.util.Set;





public enum ProcessorFlag {

    NONE(1 << 0),

    CREATE(1 << 1),

    READ(1 << 2),

    UPDATE(1 << 3),

    DELETE(1 << 4),

    CHECK(1 << 5),

    CUSTOM(1 << 6);

    private final long flagValue;



    ProcessorFlag(long flagValue) {

        this.flagValue = flagValue;

    }



    /**

     * Translates a numeric status code into a Set of ProcessorFlag enums

     *

     * @param flagValue

     * @return EnumSet representing a documents status

     */

    public static EnumSet<ProcessorFlag> toSet(long flagValue) {

        EnumSet flags = EnumSet.noneOf(ProcessorFlag.class);

        for (ProcessorFlag flag : ProcessorFlag.values()) {

            if ((flagValue & flag.getFlagValue()) == flagValue) {

                flags.add(flag);

            }

        }

        return flags;

    }



    /**

     * Translates a set of ProcessorFlag enums into a numeric status code

     *

     * @param flags if statusFlags

     * @return numeric representation of the document status

     */

    public static long fromSet(Set<ProcessorFlag> flags) {

        if (flags == null) return 0;

        long value = 0;

        for (ProcessorFlag flag : flags) {

            value |= flag.getFlagValue();

        }

        return value;

    }



    public long getFlagValue() {

        return flagValue;

    }



}

package sgcib.tmon.worker.common.processor;



import java.util.Collection;

import java.util.List;



public class SequentialProcessor<T> extends CompositeProcessorBase<T> {



    protected SequentialProcessor(String name, List<IProcessor<T>> processors) {

        super(name, processors);

    }



    @Override

    protected void doCompose(Collection<IProcessor<T>> processors, T item) {

        for (IProcessor<T> processor : processors) {

            if (processor != null) {

                processor.process(item);

            }

        }

    }



       @Override

    protected void doCreate() {

        //To change body of implemented methods use File | Settings | File Templates.

    }



    @Override

    protected void doDestroy() {

        //To change body of implemented methods use File | Settings | File Templates.

    }

}

package sgcib.tmon.worker.common.store;



import sgcib.tmon.worker.common.lifecycle.IManageable;






package sgcib.tmon.worker.common.store;



import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.store.alert.IAlertStore;

import sgcib.tmon.worker.common.store.chain.IChainStore;

import sgcib.tmon.worker.common.store.configuration.ITaskConfigurationStore;

import sgcib.tmon.worker.common.store.error.ITaskErrorStore;

import sgcib.tmon.worker.common.store.feature.IFeatureStore;

import sgcib.tmon.worker.common.store.job.IJobStore;

import sgcib.tmon.worker.common.store.metric.IMetricStore;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;



/**

* Created by Stephane on 15/02/2015.

*/

public interface IStoreManager extends IManageable {



    ITaskConfigurationStore getTaskConfigurationStore();



    IQueryableStore getStore(String storeName);



    ITaskErrorStore getTaskErrorStore();



    IAlertStore getAlertStore();



    IChainStore getChainStore();



    IFeatureStore getFeatureStore();



    IJobStore getJobStore();



    IMetricStore getMetricStore();



    IChainStore getAsyncChainStore();

}

package sgcib.tmon.worker.common.store;



import com.google.common.collect.ImmutableList;

import sgcib.tmon.worker.common.exception.WorkerException;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



/**

* Created by Stephane on 05/01/2015.

*/

public class MemoryStore<T> {

    private final Map<String, T> items;



    public MemoryStore() {

        this.items = new ConcurrentHashMap<String, T>();

    }



    public List<T> readAll() {

        if (this.items.size() == 0) {

            return new ArrayList<T>();

        }

        return ImmutableList.copyOf(this.items.values());

    }



    public T read(String id) {

        if (id == null || id.isEmpty()) {

            return null;

        }

        if (this.items.containsKey(id)) {

            return this.items.get(id);

        }

        return null;

    }



    public void save(String id, T item) throws WorkerException {

        if (item == null || id == null || id.isEmpty()) {

            return;

        }

        this.items.put(id, item);

    }



    public void update(String id, T item) throws WorkerException {

        save(id, item);



    }



    public void delete(String id) throws WorkerException {

        if (id == null || id.isEmpty()) {

            return;

        }

        if (this.items.containsKey(id)) {

            this.items.remove(id);

        }

    }



    public int size() throws WorkerException {

       return this.items.size();

    }

}

package sgcib.tmon.worker.common.store;



import org.apache.commons.lang.StringUtils;

import org.elasticsearch.ElasticsearchException;

import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;

import org.elasticsearch.action.admin.indices.alias.IndicesAliasesResponse;

import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;

import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;

import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;

import org.elasticsearch.action.admin.indices.delete.DeleteIndexResponse;

import org.elasticsearch.action.admin.indices.mapping.put.PutMappingResponse;

import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;

import org.elasticsearch.client.Client;

import org.elasticsearch.client.IndicesAdminClient;

import org.elasticsearch.client.transport.TransportClient;

import org.elasticsearch.cluster.ClusterState;

import org.elasticsearch.cluster.metadata.IndexMetaData;

import org.elasticsearch.cluster.metadata.MappingMetaData;

import org.elasticsearch.common.settings.ImmutableSettings;

import org.elasticsearch.common.settings.Settings;

import org.elasticsearch.common.transport.InetSocketTransportAddress;

import org.elasticsearch.common.xcontent.XContentBuilder;

import org.elasticsearch.common.xcontent.XContentFactory;

import org.elasticsearch.node.Node;

import org.elasticsearch.node.NodeBuilder;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.configuration.StorageConfiguration;



import java.io.IOException;

import java.net.InetAddress;

import java.net.UnknownHostException;

import java.util.*;



public class StorageManager extends ManageableBase {



    private final StorageConfiguration configuration;

    private Client client;



    public StorageManager(String name) {

        super(name);

        if (getConfiguration() != null) {

            configuration = getConfiguration().getStorageConfiguration();

            if (configuration == null) {

                getLogger().warn("Storage configuration is null");

            }

        } else {

            configuration = null;

            getLogger().warn("Storage cannot be configured");

        }

    }



    public StorageManager(String name, StorageConfiguration configuration) {

        super(name);

        this.configuration = configuration;

    }



    public StorageManager(String name, Client client) {

        super(name);

        this.configuration = null;

        this.client = client;

    }



    @Override

    public void start() throws WorkerException {



        if (configuration == null) {

            getLogger().error("Storage configuration is null.");

            return;

        }

        String clusterName = configuration.getCluster();

        boolean isEmbedded = configuration.isEmbedded();



        if (isEmbedded) {

            ImmutableSettings.Builder settings = ImmutableSettings.settingsBuilder();

            try {

                settings.put("node.name", "tmon-worker-" + InetAddress.getLocalHost().getHostName());

            } catch (UnknownHostException error) {

                settings.put("node.name", "tmon-worker-" + UUID.randomUUID().toString());

            }

            settings.put("cluster.name", clusterName);

            settings.put("http.cors.allow-origin", "*");

            settings.put("http.cors.enabled", "true");



            // Override Elasticsearch data path

            String data = configuration.getDataPath();

            if (StringUtils.isNotBlank(data)) {

                settings.put("path.data", data.trim());

            }



            List<String> parameters = configuration.getParameters();

            if (parameters != null && parameters.size() > 0) {

                for (String parameter : parameters) {

                    String[] keyValue = parameter.split("=");

                    // settings.put("path.data", "/data/index");

                    // settings.put("http.enabled", true);

                    settings.put(keyValue[0], keyValue[1]);

                }

            }



            Node node = NodeBuilder.nodeBuilder().settings(settings).clusterName(clusterName).data(true).local(false).node();

            this.client = node.client();

        } else {

            Settings settings = ImmutableSettings.settingsBuilder().put("cluster.name", clusterName).build();

            TransportClient transportClient = new TransportClient(settings);

            List<String> nodes = getConfiguration().getStorageConfiguration().getStorageHosts();

            // Check nodes first

            if (nodes == null) {

                getLogger().error("storageHosts property is null. Check your configuration.");

                return;

            }

            for (String node : nodes) {

                String[] nodeInfo = node.trim().split(":");

                transportClient.addTransportAddress(new InetSocketTransportAddress(nodeInfo[0], Integer.parseInt(nodeInfo[1])));

            }

            this.client = transportClient;

        }

    }



    @Override

    public void stop() throws WorkerException {

        if (configuration == null) {

            return;

        }

        if (this.client != null) {

            this.client.close();

        }

    }



    public Client getClient() {

        return client;

    }



    public Map getMappings(String index, String type) {

        try {

            // TODO old ClusterState clusterState =

            // client.admin().cluster().prepareState().setFilterIndices(index).execute().actionGet().getState();

            ClusterState clusterState = client.admin().cluster().prepareState().setIndices(index).execute().actionGet().getState();

            if (clusterState != null) {



                MappingMetaData metadata = clusterState.getMetaData().index(index).mapping(type);

                if (metadata != null) {

                    return metadata.getSourceAsMap();

                }

            }

        } catch (Exception error) {

            getLogger().error("Mapping request failed !", error);

            throw new WorkerException("Mapping request failed !", error);

        }

        return null;

    }



    public void createIndex(String index) {

        if (client == null) {

            getLogger().warn("Client is null : can not create index {}", index);

            return;

        }

        CreateIndexResponse response = client.admin().indices().create(new CreateIndexRequest(index)).actionGet();

        if (!response.isAcknowledged()) {

            throw new WorkerException("Index creation failed !");

        }

    }



    public void addAlias(String index, String alias) {

        if (client == null) {

            getLogger().warn("Client is null : can not add alias {}", alias);

            return;

        }

        IndicesAliasesResponse response = client.admin().indices().prepareAliases().addAlias(index, alias).execute().actionGet();

        if (!response.isAcknowledged()) {

            throw new WorkerException("Index creation failed !");

        }

    }



    public void createMapping(String index, String type, Map<String, String> fieldsToMap) {

        PutMappingResponse response = null;

        try {

            XContentBuilder mapping = buildMappings(fieldsToMap);

            response = client.admin().indices().preparePutMapping(index).setType(type).setSource(mapping).execute().actionGet();

            if (!response.isAcknowledged()) {

                throw new WorkerException("Mapping creation failed !");

            }

        } catch (ElasticsearchException error) {

            getLogger().error("Mapping creation failed !", error);

            throw new WorkerException("Mapping creation failed !", error);

        }

    }



    public void updateMapping(String index, String type, Map<String, String> fieldsToMap) {

        PutMappingResponse response = null;

        try {

            XContentBuilder mapping = updateMappings(fieldsToMap);

            response = client.admin().indices().preparePutMapping(index).setType(type).setSource(mapping).execute().actionGet();

            if (!response.isAcknowledged()) {

                throw new WorkerException("Mapping creation failed !");

            }

        } catch (ElasticsearchException error) {

            getLogger().error("Mapping creation failed !", error);

            throw new WorkerException("Mapping creation failed !", error);

        }

    }



    public boolean isMappingExist(Client client, String index, String mappingName) {

        ClusterState clusterState = client.admin().cluster().prepareState().setIndices(index).execute().actionGet().getState();

        IndexMetaData indexMetadata = clusterState.getMetaData().index(index);

        if (indexMetadata == null) {

            return false;

        }

        MappingMetaData mapping = indexMetadata.mapping(mappingName);

        return (mapping != null);

    }



    private XContentBuilder buildMappings(Map<String, String> fieldsToMap) {

        XContentBuilder builder = null;

        try {

            builder = XContentFactory.jsonBuilder();

            builder = builder.startObject().startObject("properties");



            for (Map.Entry<String, String> field : fieldsToMap.entrySet()) {

                builder.startObject(field.getKey()).field("type", field.getValue()).field("store", "yes").field("index", "analyzed").endObject();

            }

            builder.endObject().endObject();

        } catch (IOException error) {

            getLogger().error("Mapping building failed !", error);

            throw new WorkerException("Mapping building failed !", error);

        }

        return builder;

    }



    private XContentBuilder updateMappings(Map<String, String> fieldsToMap) {

        XContentBuilder builder = null;

        try {

            builder = XContentFactory.jsonBuilder();

            builder = builder.startObject().startObject("properties");



            for (Map.Entry<String, String> field : fieldsToMap.entrySet()) {

                builder.startObject(field.getKey()).field("type", field.getValue()).field("store", "yes").field("index", "not_analyzed").endObject();

            }

            builder.endObject().endObject();

        } catch (IOException error) {

            getLogger().error("Mapping building failed !", error);

            throw new WorkerException("Mapping building failed !", error);

        }

        return builder;

    }



    public void deleteIndex(String index) {

        try {

            DeleteIndexResponse response = client.admin().indices().delete(new DeleteIndexRequest(index)).actionGet();

            if (!response.isAcknowledged()) {

                throw new WorkerException("Index deletion failed !");

            }

        } catch (Exception error) {

            getLogger().error("Index deletion failed !", error);

            throw new WorkerException("Index deletion failed !", error);

        }

    }



    public boolean isIndexExist(String index) {

        if (client == null) {

            getLogger().warn("Client is null : can not check index {}", index);

            return false;

        }

        client.admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();

        ClusterStateResponse response = client.admin().cluster().prepareState().execute().actionGet();

        return response.getState().metaData().hasIndex(index);

    }



    public Set<String> getIndexes() {

        if (client == null) {

            getLogger().warn("Client is null : can not get indexes");

            return Collections.emptySet();

        }

        try {

            IndicesAdminClient indicesClient = client.admin().indices();

            if (indicesClient != null) {

                IndicesStatsResponse response = indicesClient.prepareStats().execute().actionGet();

                return response.getIndices().keySet();

            }

        } catch (Exception error) {

            getLogger().error("Get indices failed !", error);

            throw new WorkerException("Get indices failed !", error);

        }

        return Collections.emptySet();

    }

}package sgcib.tmon.worker.common.store;



import java.util.Comparator;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;



import com.fasterxml.jackson.core.JsonProcessingException;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.fasterxml.jackson.datatype.joda.JodaModule;



/**

* Created by Stephane on 11/01/2015.

*/

public abstract class StoreBase extends ManageableBase implements IStore {



    // Limit the number of drained events from blocking queue used in

    // asynchronous store.

    protected static final int MAX_EVENTS = 500;



    private final ObjectMapper mapper;

    private final StorageManager storageManager;

    private final Comparator<StoredQueryable> versionComparator;



    public StoreBase(String name, StorageManager storageManager) {

        super(name);

        this.mapper = new ObjectMapper();

        mapper.registerModule(new JodaModule());

        mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

        this.storageManager = storageManager;

        this.versionComparator = Comparator.comparing(StoredQueryable::getVersion);

    }



    public StorageManager getStorageManager() {

        return storageManager;

    }



    public ObjectMapper getMapper() {

        return mapper;

    }



    /**

     * Return the comparator used to find max version of StoredQueryable.

     */

    protected Comparator<StoredQueryable> getVersionComparator() {

        return versionComparator;

    }



    /**

     * Wrapper used to perform serialization on {@link Queryable} item.

     */

    protected class StoredQueryable {



        private final String id;

        private final long version;

        private final Queryable item;

        private final String itemAsString;



        public StoredQueryable(Queryable item) {

            this.id = item.getId();

            this.version = item.getVersion();

            this.item = item;

            try {

                this.itemAsString = getMapper().writeValueAsString(item);

            } catch (JsonProcessingException e) {

                throw new WorkerException(e);

            }

        }



        public String getId() {

            return id;

        }



        public Queryable getItem() {

            return item;

        }



        public String getItemAsString() {

            return itemAsString;

        }



        public long getVersion() {

            return version;

        }

    }

}

package sgcib.tmon.worker.common.store;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.alert.IAlertStore;

import sgcib.tmon.worker.common.store.alert.MemoryAlertStore;

import sgcib.tmon.worker.common.store.chain.IChainStore;

import sgcib.tmon.worker.common.store.chain.MemoryChainStore;

import sgcib.tmon.worker.common.store.configuration.ApplicationSettings;

import sgcib.tmon.worker.common.store.configuration.ITaskConfigurationStore;

import sgcib.tmon.worker.common.store.configuration.MemoryTaskConfigurationStore;

import sgcib.tmon.worker.common.store.error.ITaskErrorStore;

import sgcib.tmon.worker.common.store.error.MemoryTaskErrorStore;

import sgcib.tmon.worker.common.store.feature.IFeatureStore;

import sgcib.tmon.worker.common.store.job.IJobStore;

import sgcib.tmon.worker.common.store.job.MemoryJobStore;

import sgcib.tmon.worker.common.store.metric.IMetricStore;

import sgcib.tmon.worker.common.store.metric.MemoryMetricStore;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;

import sgcib.tmon.worker.common.store.queryable.MemoryQueryableStore;

import sgcib.tmon.worker.configuration.SettingsConfiguration;



import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



public class StoreManager extends ManageableBase implements IStoreManager {

    private final ITaskConfigurationStore configurationStore;

    private final Map<String, IQueryableStore> itemStores;

    private final ITaskErrorStore taskErrorStore;

    private final IChainStore chainStore;

    private final IAlertStore alertStore;

    private final IFeatureStore featureStore;

    private final IJobStore jobStore;

    private final IMetricStore metricStore;

    private final IChainStore asyncChainStore;





    public StoreManager(ITaskConfigurationStore configurationStore, Map<String, IQueryableStore> itemStores, ITaskErrorStore taskErrorStore, IChainStore chainStore, IAlertStore alertStore, IFeatureStore featureStore, IJobStore jobStore,

            IMetricStore metricStore, IChainStore asyncChainStore) {

        super("StoreManager");

        this.configurationStore = configurationStore;

        this.itemStores = itemStores;

        this.taskErrorStore = taskErrorStore;

        this.chainStore = chainStore;

        this.alertStore = alertStore;

        this.featureStore = featureStore;

        this.jobStore = jobStore;

        this.metricStore = metricStore;

        this.asyncChainStore = asyncChainStore;

    }



    public StoreManager() {

        super("StoreManager");

        this.chainStore = new MemoryChainStore();

        this.configurationStore = new MemoryTaskConfigurationStore();

        this.itemStores = new ConcurrentHashMap<String, IQueryableStore>();

       this.itemStores.put("MemoryQueryableStore", new MemoryQueryableStore());

        this.taskErrorStore = new MemoryTaskErrorStore();

        this.alertStore = new MemoryAlertStore();

        this.jobStore = new MemoryJobStore();

        this.metricStore = new MemoryMetricStore();

        this.asyncChainStore = new MemoryChainStore();

        this.featureStore = null;

    }



    @Override

    public void start() throws WorkerException {

        loadSettings();

    }



    private void loadSettings() {

        String environment = getConfiguration().getEnvironment();

        Queryable conf = configurationStore.readConfiguration(environment + ".Settings");

        SettingsConfiguration settings = null;

        if (conf != null) {

            settings = new SettingsConfiguration(conf);

        }

        if (settings != null) {

            ApplicationSettings.setConfiguration(settings);

        }

    }



    @Override

    public void stop() throws WorkerException {

    }



    @Override

    public ITaskConfigurationStore getTaskConfigurationStore() {

        return configurationStore;

    }



    @Override

    public IQueryableStore getStore(String storeName) {

        return itemStores.get(storeName);

    }



    @Override

    public ITaskErrorStore getTaskErrorStore() {

        return taskErrorStore;

    }



    @Override

    public IAlertStore getAlertStore() {

        return alertStore;

    }



    @Override

    public IChainStore getChainStore() {

        return chainStore;

    }



    @Override

    public IFeatureStore getFeatureStore() {

        return featureStore;

    }



    @Override

    public IJobStore getJobStore() {

        return jobStore;

    }



    @Override

    public IMetricStore getMetricStore() {

        return metricStore;

    }



    @Override

    public IChainStore getAsyncChainStore() {

        return asyncChainStore;

    }

}

package sgcib.tmon.worker.common.task;



/**

* Created by Stephane on 19/03/2015.

*/

public enum BoundType {

    cpu,

    network,

    io

}

package sgcib.tmon.worker.common.task;



import com.codahale.metrics.annotation.Timed;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.ConverterConfiguration;



import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 27/02/2015.

*/

public class ConverterTask extends TaskBase {

    private final Map<String, SupportedType> fieldsToConvert;



    public enum SupportedType {

        Integer,

        Double,

        String,

        Boolean

    }



    public ConverterTask(ConverterConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        ConverterConfiguration converterConfiguration = new ConverterConfiguration(configuration);

        this.fieldsToConvert = new ConcurrentHashMap<String, SupportedType>();

        if (converterConfiguration.getFieldsToConvert() != null) {

            for (Map.Entry<String, String> fieldToConvert : converterConfiguration.getFieldsToConvert().entrySet()) {

                if (fieldToConvert != null && fieldToConvert.getKey() != null && fieldToConvert.getValue() != null) {

                    try {

                        this.fieldsToConvert.put(fieldToConvert.getKey(), SupportedType.valueOf(fieldToConvert.getValue()));

                    } catch (Exception error) {

                        getLogger().error("Field conversion is not valid", error);

                    }

                }

            }

        }

    }



    @Override

    protected boolean canProcess() {

        return (this.fieldsToConvert != null);

    }



    @Override

    @Timed(name = "ConverterTask.doProcess")

    protected Queryable doProcess(Queryable item) {

        if (item == null) return item;

        for (Map.Entry<String, SupportedType> field : fieldsToConvert.entrySet()) {

            if (field != null && field.getKey() != null && field.getValue() != null) {

                String fieldKey = field.getKey();

                if (item.containsKey(fieldKey)) {

                    Object value = item.get(fieldKey);

                    if (value != null) {

                        switch (field.getValue()) {

                            case Integer:

                                item.put(fieldKey, Integer.parseInt(value.toString()));

                                break;

                            case Double:

                                item.put(fieldKey, Double.parseDouble(value.toString()));

                                break;

                            case String:

                                item.put(fieldKey, value.toString());

                                break;

                            case Boolean:

                                item.put(fieldKey, Boolean.parseBoolean(value.toString()));

                                break;

                        }

                    }

                }

            }

        }

        return item;

    }





    @Override

    public String getErrorField() {

        return "converterError";

    }





    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }





}

package sgcib.tmon.worker.common.task;



import java.io.IOException;

import java.util.Map;

import java.util.concurrent.ExecutorService;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.eventschecker.EventTypeChecker;

import sgcib.tmon.worker.common.eventschecker.EventTypeDeclaration;

import sgcib.tmon.worker.common.eventschecker.EventTypes;

import sgcib.tmon.worker.common.eventschecker.GlobalTypes;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Query;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.DropConfiguration;

import java.util.*;



import com.codahale.metrics.annotation.Timed;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.google.common.collect.Maps;



public class DropTask extends TaskBase {



    private final Map<String, Query> dropQueries;

    private EventTypeChecker eventTypeChecker;



    public DropTask(DropConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        DropConfiguration dropConfiguration = new DropConfiguration(configuration);

        dropQueries = getDropConditions(dropConfiguration.getDropQuery());

        eventTypeChecker = createEventTypeChecker(dropConfiguration.getEventDeclaration());

    }



    private EventTypeChecker createEventTypeChecker(ArrayList<String> eventDeclarationXmlFiles){

        if(eventDeclarationXmlFiles == null || eventDeclarationXmlFiles.size() == 0) return  null;

        EventTypes type = new EventTypes();

        for(String path:eventDeclarationXmlFiles) {



            EventTypes result =  EventTypeChecker.GetTypesDefination(path);



            if(result.getGlobals() != null) {

                if(type.getGlobals() == null) type.setGlobals(new GlobalTypes());

                for(Object ob:result.getGlobals().getEnumOrStructure() )

                type.getGlobals().getEnumOrStructure().add(ob);

            }



            for(EventTypeDeclaration dec:result.getEvent())

            {

                type.getEvent().add(dec);

            }

        }

        return new EventTypeChecker(type);

    }



    private Map<String, Query> getDropConditions(Map<String, String> dropQueries) {

        ObjectMapper mapper = new ObjectMapper();

        Map<String, Query> queriesByType = Maps.newHashMap();

        if (dropQueries != null) {

            for (String key : dropQueries.keySet()) {

                try {

                    Query cond = mapper.readValue(dropQueries.get(key), Query.class);

                    queriesByType.put(key, cond);

                } catch (IOException error) {

                    getLogger().error("Cannot deserialize query" + dropQueries.get(key), error);

                }

            }

        }

        return queriesByType;

    }



    @Override

    protected boolean canProcess() {

        return true;

    }



    @Override

    @Timed(name = "DropTask.doProcess")

    protected Queryable doProcess(Queryable item) {

        if (item == null) {

            return item;

        }

        item.put(Queryable.drop, false);

        if(!checkEventDeclaration(item))

        {

            item.put(Queryable.drop, true);

            return item;

        }

        for (String key : dropQueries.keySet()) {

            Query dropQueryCondition = dropQueries.get(key);

            if ((dropQueryCondition != null && dropQueryCondition.match(item))) {

                item.put(Queryable.drop, true);

                getLogger().info("Dropping event : " + item);

                break;

            }

        }

        return item;

    }



    private Boolean checkEventDeclaration(Queryable item) {

        if (eventTypeChecker == null) {

            return true;

        }



        Boolean result = false;

        try {

            eventTypeChecker.DoCheckType(item);

            result = true;

        } catch (Exception e) {

            getLogger().error(String.format("Error on checkEventDeclaration : %s for item : %s ", e,item));



        }

        return result;

    }



    @Override

    public String getErrorField() {

        return "dropError";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }

}

package sgcib.tmon.worker.common.task;



import com.codahale.metrics.annotation.Timed;

import com.google.common.collect.ImmutableList;

import org.apache.commons.lang3.StringUtils;

import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Feature;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.feature.IFeatureStore;

import sgcib.tmon.worker.configuration.FeatureTrackingConfiguration;



import java.util.*;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.ExecutorService;



/**

* Created by slopes041604 on 29/05/2015.

*/

public class FeatureTrackingTask extends TaskBase {

    private final IFeatureStore store;

    private DateTime lastCheck;

    private final Map<String, Feature> features;

    private Timer timer;



    private static DateTimeFormatter dateTimeFormatter = ISODateTimeFormat.dateTimeParser();



    public FeatureTrackingTask(FeatureTrackingConfiguration configuration, IFeatureStore store, IAlertManager alertManager) {

        super(configuration, alertManager);

        this.store = store;

        this.features = new ConcurrentHashMap<String, Feature>();

    }



    @Override

    protected boolean canProcess() {

        return (getTaskConfiguration() != null);

    }



    @Override

    @Timed(name = "FeatureTrackingTask.doProcess")

    protected Queryable doProcess(Queryable item) {

        return item;

    }



    @Override

    public String getErrorField() {

        return "featureError";

    }



    @Override

    public void start() throws WorkerException {

        store.start();



        if (timer == null) {

            this.timer = new Timer();



            TimerTask task = new TimerTask() {

                @Override

                public void run() {

                    loadData();

                }

            };

            FeatureTrackingConfiguration configuration = (FeatureTrackingConfiguration) getTaskConfiguration();

            timer.scheduleAtFixedRate(task, 0, configuration.getSynchroFrequencyInHour() * 3600 * 1000);

        }

    }



    private void loadFeature() {

        List<Feature> storedFeatures = store.getFeatures();



        if (features != null) {

            for (Feature feature : storedFeatures) {

                if (feature != null) {

                    if (lastCheck == null || lastCheck.isAfter(feature.getTimestamp())) {

                        lastCheck = feature.getTimestamp();

                    }

                    features.put(feature.getName(), feature);

                }

            }

        }

    }



    @Override

    public void stop() throws WorkerException {

        store.stop();

        if (timer != null) {

            timer.cancel();

        }

    }



    public boolean loadData() {



        loadFeature();



        Map<String, Feature> ticketFollowUps = loadFollowUp();

        FeatureTrackingConfiguration configuration = (FeatureTrackingConfiguration) getTaskConfiguration();

        List<Queryable> tickets = store.loadTicket(lastCheck, configuration.getTicketEventName());

        Collections.sort(tickets, Queryable.orderByTimestamp);

        for (Queryable ticket : tickets) {



            String ticketKey = (String) ticket.getValue("ticketKey");

            String featureName = (String) ticket.getValue("feature");



            if (ticketKey != null) {

                Feature ticketFollowUp = ticketFollowUps.get(ticketKey);



                if (ticketFollowUp == null) {

                    ticketFollowUp = new Feature(ticketKey);

                    ticketFollowUp.setType("ticketFollowUp");

                    ticketFollowUp.setId(ticketKey);

                    ticketFollowUp.setTimestamp(DateTime.now());

                    ticketFollowUps.put(ticketKey, ticketFollowUp);

                    ticketFollowUps.remove("tickets");

                }



                String action = (String) ticket.getValue("action");



                if (action != null) {

                    DateTime date = ticketFollowUp.getValueAsDateTime(action);

                    if (date != null) {

                        if (date == null || date.isAfter(ticket.getTimestamp())) {

                            ticketFollowUp.setValue(action, ticket.getTimestamp());

                        }

                    } else {

                        ticketFollowUp.setValue(action, ticket.getTimestamp());

                    }

                }



                ticketFollowUp.setValue("feature", featureName);

            }



            if (StringUtils.isNotBlank(featureName)) {

                featureName = featureName.trim();



                Feature feature = features.get(featureName);



                if (feature == null) {

                    feature = new Feature(featureName);

                    feature.setId(featureName);

                    features.put(featureName, feature);

                }



                feature.addTiket(ticketKey);



                if (feature.getCreationDate() == null || ticket.getTimestamp().isBefore(feature.getCreationDate())) {

                    feature.setCreationDate(ticket.getTimestamp());

                }



                if (feature.getLastModificationDate() == null || ticket.getTimestamp().isAfter(feature.getLastModificationDate())) {

                    feature.setLastModificationDate(ticket.getTimestamp());

                }



            }

        }



        for (Feature ticketFollowUp : ticketFollowUps.values()) {

            DateTime initialDate = ticketFollowUp.getValueAsDateTime(configuration.getInitialStatus());

            DateTime deliveryDate = ticketFollowUp.getValueAsDateTime(configuration.getReleaseStatus());



            if (initialDate != null && deliveryDate != null && deliveryDate.isAfter(initialDate)) {

                ticketFollowUp.setValue("timeToDelivery", (deliveryDate.getMillis() - initialDate.getMillis()) / (24 * 3600 * 1000));

            }



            if (deliveryDate != null) {

                String featureName = (String) ticketFollowUp.getValue("feature");

                if (featureName != null) {

                    Feature feature = features.get(featureName);

                    if (feature != null) {

                        feature.setTimeToDeliveryInDays(deliveryDate);

                    }

                }

            }



        }



        for (Feature feature : features.values()) {

            if (feature.getReleaseDate() == null) {

                String featureName = feature.getName().trim();

                DateTime releaseDate = store.loadFeatureData(featureName, feature.getCreationDate(), configuration.getDataEventType(), configuration.getDataEventField());



                if (releaseDate != null) {

                    feature.setReleaseDate(releaseDate);

                }

            }

        }



        store.saveFeatures(ImmutableList.copyOf(features.values()));



        store.saveFeatures(ImmutableList.copyOf(ticketFollowUps.values()));



        return true;

    }



    private Map<String, Feature> loadFollowUp() {

        Map<String, Feature> ticketFollowUps = new ConcurrentHashMap<>();

        List<Feature> followUps = store.loadTicketFollowUp();

        for (Feature followUp : followUps) {

            ticketFollowUps.put(followUp.getId(), followUp);

        }

        return ticketFollowUps;

    }



}package sgcib.tmon.worker.common.task;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.FilterConfiguration;



import java.util.List;

import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 27/02/2015.

*/

public class FilterTask extends TaskBase {

    private final List<String> fieldsToFilter;



    public FilterTask(FilterConfiguration configuration,IAlertManager alertManager) {

        super(configuration,alertManager);

        FilterConfiguration filterConfiguration = new FilterConfiguration(configuration);

        this.fieldsToFilter = filterConfiguration.getFieldsToFilter();

    }



    @Override

    protected boolean canProcess() {

        return (fieldsToFilter!= null);

    }



    @Override

    protected Queryable doProcess(Queryable item) {

        if (item == null) return item;

        for (String field : fieldsToFilter) {

            if (field != null) {

                if (item.containsKey(field)) {

                    item.remove(field);

                }

            }

        }

        return item;

    }



    @Override

    public String getErrorField() {

        return "filterError";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }









}

package sgcib.tmon.worker.common.task;



import com.google.common.util.concurrent.ListenableFuture;

import rx.Observable;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Queryable;



import java.util.List;

import java.util.concurrent.Future;



/**

* Created by Stephane on 31/01/2015.

*/



package sgcib.tmon.worker.common.task;



import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import java.util.Map;



/**

* Created by Stephane on 14/02/2015.

*/

public interface ITaskFactory {

    ITask build(String taskName) throws WorkerException;

    Map<String,ITask> buildAll(TaskType taskType) throws WorkerException;

    ITask build(TaskConfiguration configuration);

}

package sgcib.tmon.worker.common.task;



import rx.Observable;

import sgcib.tmon.worker.common.lifecycle.IManageable;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import java.util.List;

import java.util.concurrent.ExecutorService;



/**

* Created by slopes041604 on 11/06/2015.

*/

public interface ITaskManager extends IManageable {



    void process(Queryable item, String taskName, int timeoutInSeconds);



    void processMultiple(List<Queryable> items, String taskName, int timeoutInSeconds);



    void deleteTask(TaskConfiguration configuration);



    ITask updateTask(TaskConfiguration configuration);



    ITask createTask(TaskConfiguration configuration);



    ITask getTask(String taskName);



}

package sgcib.tmon.worker.common.task;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.MapperConfiguration;



import java.util.Map;

import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 27/02/2015.

*/

public class MapperTask extends TaskBase {

    private final Map<String, String> fieldsToMap;



    public MapperTask(MapperConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        MapperConfiguration mapperConfiguration = new MapperConfiguration(configuration);

        this.fieldsToMap = mapperConfiguration.getFieldsToMap();

    }



    @Override

    protected boolean canProcess() {

        return (fieldsToMap != null);

    }



    @Override

    protected Queryable doProcess(Queryable item) {

        if (item == null) return item;

        for (Map.Entry<String, String> mapping : fieldsToMap.entrySet()) {

            if (mapping != null && mapping.getKey() != null && mapping.getValue() != null) {

                String sourceKey = mapping.getKey();

                if (item.containsKey(sourceKey)) {

                    Object value = item.get(sourceKey);

                    String destinationKey = mapping.getValue();

                    item.put(destinationKey, value);

                }

            }

        }

        return item;

    }



    @Override

    public String getErrorField() {

        return "mapperError";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }





}





package sgcib.tmon.worker.common.task;



import rx.Observer;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.error.ITaskErrorStore;



import java.util.List;



/**

* Created by slopes041604 on 19/10/2015.

*/

public class MultipleTaskErrorManager extends ManageableBase implements Observer<List<Queryable>> {

    private final ITaskErrorStore errorStore;



    public MultipleTaskErrorManager(String name, ITaskErrorStore errorStore) {

        super(name);

        this.errorStore = errorStore;



    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }



    @Override

    public void onCompleted() {



    }



    @Override

    public void onError(Throwable throwable) {

        if (errorStore != null) {

            TaskError error = new TaskError(getName(),TaskAction.ProcessMultiple,throwable.getMessage());

            errorStore.registerError(error);

        }

    }



    @Override

    public void onNext(List<Queryable> queryables) {



    }

}

package sgcib.tmon.worker.common.task;



import java.util.ArrayList;

import java.util.List;

import java.util.Timer;

import java.util.TimerTask;

import java.util.concurrent.atomic.AtomicBoolean;



import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Event;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.QueueConfiguration;



import com.fasterxml.jackson.databind.ObjectMapper;

import com.fasterxml.jackson.datatype.joda.JodaModule;

import com.google.common.collect.ImmutableList;

import com.hazelcast.core.IQueue;

import com.hazelcast.monitor.LocalQueueStats;



/**

* Created by Stephane on 21/06/2015.

*/

public class QueueTask extends TaskBase {



    protected static final int MAX_EVENTS_PER_PERIOD = 500;



    private final ITaskManager taskManager;

    private final IClusterManager clusterManager;

    private final String task;

    private final int pollingPeriod;

    private final int timeout;

    private final int backUpCount;

    private final int queueMaxSize;

    private final int maxEventsPerPeriod;

    private AtomicBoolean isProcessing;

    private Thread processThread;

    private Timer monitorTimer;

    private IQueue<Queryable> queue;



    protected QueueTask(QueueConfiguration configuration, ITaskManager taskManager, IClusterManager clusterManager, IAlertManager alertManager) {

        super(configuration, alertManager);

        this.taskManager = taskManager;

        this.clusterManager = clusterManager;

        this.task = configuration.getTask();

        this.pollingPeriod = configuration.getPollingPeriodInMilliseconds();

        this.timeout = configuration.getTimeoutInSeconds();

        this.maxEventsPerPeriod = configuration.getMaxEventsPerPeriod();

        this.backUpCount = configuration.getBackupCount();

        this.queueMaxSize = configuration.getQueueMaxSize();

        this.isProcessing = new AtomicBoolean(false);

    }



    @Override

    protected boolean canProcess() {

        return (getTaskConfiguration() != null);

    }



    @Override

    protected Queryable doProcess(Queryable item) throws WorkerException {

        if (this.queue != null) {

            Event event = new Event("queueTaskData", "workerData");

            event.setValue("action", "offer");

            long startTime = System.nanoTime();

            try {

                if (this.queue.offer(item)) {

                    return item;

                }

            } finally {

                long duration = (System.nanoTime() - startTime) / 1000000;

                event.setValue("processingTime", duration);

                ManageableBase.publish(event);

            }

            throw new WorkerException("Unable to add item " + item.getName());

        }

        return item;

    }



    @Override

    protected List<Queryable> doProcessMultiple(List<Queryable> items) throws WorkerException {

        if (this.queue != null) {

            Event event = new Event("queueTaskData", "workerData");

            event.setValue("action", "offer");

            long startTime = System.nanoTime();

            try {

                if (this.queue.addAll(ImmutableList.copyOf(items))) {

                    return items;

                }

            } finally {

                long duration = (System.nanoTime() - startTime) / 1000000;

                event.setValue("processingTime", duration);

                ManageableBase.publish(event);

            }

            throw new WorkerException("Unable to add items " + items.size());

        }

        return items;

    }



    @Override

    public String getErrorField() {

        return "eventQueueError";

    }



    @Override

    public void start() throws WorkerException {

        this.queue = clusterManager.getQueue(getName(), this.queueMaxSize, this.backUpCount);

        if (this.queue != null) {

            if (this.processThread == null) {



                this.isProcessing.set(true);



                this.processThread = new Thread() {

                    @Override

                    public void run() {

                        try {

                            do {

                                long duration = 0;

                                if (clusterManager.isMaster()) {

                                    long startTime = System.nanoTime();

                                    Event event = new Event("queueTaskData", "workerData");

                                   event.setValue("status", "success");

                                    event.setValue("task", getName());

                                    event.setValue("action", "poll");

                                    try {

                                       List<Queryable> items = new ArrayList<Queryable>();

                                        queue.drainTo(items, maxEventsPerPeriod);

                                        if (items.size() > 0) {

                                            taskManager.processMultiple(items, task, -1);

                                        }

                                        event.setValue("itemCount", items.size());

                                    } catch (Throwable error) {

                                        getLogger().error("Failed processing items ", error);

                                        event.setValue("status", "error");

                                        event.setValue("error", error.getMessage());

                                    } finally {

                                        duration = (System.nanoTime() - startTime) / 1000000;

                                        event.setValue("processingTime", duration);

                                        ManageableBase.publish(event);

                                    }

                                }

                                if (duration < pollingPeriod) {

                                    Thread.sleep(pollingPeriod - duration);

                                }



                            } while (isProcessing.get());

                        } catch (Exception error) {

                            getLogger().error("Interrupting processing thread", error);

                        } finally {

                            getLogger().error("Queue processing done :" + getName());

                        }

                    }

                };

                this.processThread.setName(String.format("%s.%s", getName(), "processingThread"));

                this.processThread.start();

            }



            if (this.monitorTimer == null) {

                this.monitorTimer = new Timer();

                TimerTask timerTask = new TimerTask() {

                    @Override

                    public void run() {

                        saveStatistics();

                    }

                };

                monitorTimer.scheduleAtFixedRate(timerTask, 0, 30000);

            }

        }

    }



    private void saveStatistics() {

        LocalQueueStats statistics = queue.getLocalQueueStats();

        Event event = new Event("queueData", "workerData");

        event.setValue("queue", getName());

        event.put("ownedItemCount", statistics.getOwnedItemCount());

        event.put("backupItemCount", statistics.getBackupItemCount());

        event.put("minAge", statistics.getMinAge());

        event.put("maxAge", statistics.getMaxAge());

        event.put("creationTime", statistics.getCreationTime());

        event.put("eventOperationCount", statistics.getEventOperationCount());

        event.put("avgAge", statistics.getAvgAge());

        event.put("rejectedOfferOperationCount", statistics.getRejectedOfferOperationCount());

        event.put("offerOperationCount", statistics.getOfferOperationCount());

        event.put("pollOperationCount", statistics.getPollOperationCount());

        event.put("emptyPollOperationCount", statistics.getEmptyPollOperationCount());

        event.put("otherOperationsCount", statistics.getOtherOperationsCount());

        ManageableBase.publish(event);

    }



    @Override

    public void stop() throws WorkerException {

        this.isProcessing.set(false);

        try {

            this.processThread.join(pollingPeriod * 10);

        } catch (InterruptedException error) {

            getLogger().error("Error queue processing thread", error);

        }

    }



    public String dump() {

        StringBuilder builder = new StringBuilder();

        if (queue != null) {

            List<Object> objects = ImmutableList.copyOf(queue);

            ObjectMapper mapper = new ObjectMapper();

            mapper.registerModule(new JodaModule());

            mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

            try {

                builder.append(mapper.writeValueAsString(objects));

            } catch (Exception error) {

                getLogger().error("Cannot dump memory", getName());

            }



        }

        return builder.toString();

    }

}

package sgcib.tmon.worker.common.task;



import com.google.common.collect.ImmutableList;

import com.google.common.util.concurrent.AsyncFunction;

import com.google.common.util.concurrent.Futures;

import com.google.common.util.concurrent.ListenableFuture;

import org.eclipse.jetty.util.ArrayQueue;

import rx.Observable;

import rx.Observer;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.monitor.IHistogram;

import sgcib.tmon.worker.configuration.SequenceConfiguration;



import java.util.List;

import java.util.Queue;

import java.util.concurrent.ConcurrentLinkedDeque;

import java.util.concurrent.ExecutorService;



/**

* Created by Stephane on 22/02/2015.

*/

public class SequenceTask extends TaskBase {

    private final List<String> tasks;

    private final ITaskManager taskManager;



    public SequenceTask(SequenceConfiguration configuration, ITaskManager taskManager, IAlertManager alertManager) {

        super(configuration, alertManager);

        if (configuration != null && configuration.getTaskConfigurations() != null) {

            this.tasks = ImmutableList.copyOf(configuration.getTaskConfigurations().values());

            this.taskManager = taskManager;

        } else {

            this.tasks = null;

            this.taskManager = null;

        }

    }



    @Override

    protected boolean canProcess() {

        return true;

    }



    @Override

    protected Queryable doProcess(Queryable item) {

        return item;

    }





    @Override

    protected List<Queryable> doProcessMultiple(List<Queryable> item) {

        return item;

    }



    protected class ProcessOsberver implements Observer<Queryable> {



        private final Queue<String> tasks;

        private final ITaskManager taskManager;



        public ProcessOsberver(Queue<String> tasks, ITaskManager taskManager) {

            this.tasks = tasks;

            this.taskManager = taskManager;

        }



        @Override

        public void onCompleted() {



        }



        @Override

        public void onError(Throwable throwable) {

            getLogger().error("Cannot null process task " + getName(), throwable);

        }



        @Override

        public void onNext(Queryable item) {

            if (!tasks.isEmpty()) {

                String taskName = tasks.poll();

                if (taskName != null) {

                    ITask task = taskManager.getTask(taskName);

                    if (task != null) {

                        Observable<Queryable> next = task.process(item);

                        next.subscribe(this);

                    }

                }

            }

        }

    }



    @Override

    public Observable<Queryable> process(Queryable item) {

        Queue<String> tasks = new ConcurrentLinkedDeque<>(this.tasks);

        String taskName = tasks.poll();

        if (taskName != null) {

            ITask task = this.taskManager.getTask(taskName);

            if (task != null) {

                Observable<Queryable> next = task.process(item);

                next.subscribe(new ProcessOsberver(tasks,this.taskManager));

                return next;

            }

        }

        return Observable.just(item);

    }





    protected class ProcessMultipleOsberver implements Observer<List<Queryable>> {



        private final Queue<String> tasks;

        private final ITaskManager taskManager;



        public ProcessMultipleOsberver(Queue<String> tasks, ITaskManager taskManager) {

            this.tasks = tasks;

            this.taskManager = taskManager;

        }



        @Override

        public void onCompleted() {



        }



        @Override

        public void onError(Throwable throwable) {

            getLogger().error("Cannot null process task " + getName(), throwable);

        }



        @Override

        public void onNext(List<Queryable> items) {

            if (!tasks.isEmpty()) {

                String taskName = tasks.poll();

                if (taskName != null) {

                    ITask task = taskManager.getTask(taskName);

                    if (task != null) {

                        Observable<List<Queryable>> next = task.processMultiple(items);

                        next.subscribe(this);

                    }

                }

            }

        }

    }



    @Override

    public Observable<List<Queryable>> processMultiple(List<Queryable> items) {

        Queue<String> tasks = new ConcurrentLinkedDeque<>(this.tasks);

        String taskName = tasks.poll();

        if (taskName != null) {

            ITask task = this.taskManager.getTask(taskName);

            if (task != null) {

                Observable<List<Queryable>> next = task.processMultiple(items);

                next.subscribe(new ProcessMultipleOsberver(tasks,this.taskManager));

                return next;

            }

        }

        return Observable.just(items);

    }



    @Override

    public String getErrorField() {

        return "sequenceError";

    }



    @Override

    public void start() throws WorkerException {

    }



    @Override

    public void stop() throws WorkerException {

    }

}

package sgcib.tmon.worker.common.task;



import java.util.List;

import java.util.stream.Collectors;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.queryable.IQueryableStore;

import sgcib.tmon.worker.configuration.StoreConfiguration;



/**

* Created by Stephane on 19/02/2015.

*/

public class StoreTask extends TaskBase {



    private final IQueryableStore store;



    public StoreTask(IQueryableStore store, StoreConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        this.store = store;

    }



    @Override

    protected boolean canProcess() {

        return (store != null);

    }



    @Override

    protected Queryable doProcess(Queryable item) {



        try {

            store.save(item);

        } catch (WorkerException error) {

            getLogger().error(error.getMessage(), error);

            item.put(getErrorField(), error.getMessage());

        }

        return item;

    }



    @Override

    protected List<Queryable> doProcessMultiple(List<Queryable> items) {



        List<Queryable> filteredItems = items.stream().filter(item -> isNotDroppable(item)).collect(Collectors.toList());



        try {

            store.save(filteredItems);

        } catch (WorkerException error) {

            getLogger().error(error.getMessage(), error);

            filteredItems.stream().forEach(i -> i.put(getErrorField(), error.getMessage()));

        }

        return filteredItems;

    }



    @Override

    public String getErrorField() {

        return "storeError";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }

}

package sgcib.tmon.worker.common.task;



import java.util.List;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.store.IStoreManager;

import sgcib.tmon.worker.common.task.publisher.EmsPublisherTask;

import sgcib.tmon.worker.common.task.publisher.GeneosPublisherTask;

import sgcib.tmon.worker.common.task.publisher.KafkaPublisherTask;

import sgcib.tmon.worker.common.task.publisher.MailPublisherTask;

import sgcib.tmon.worker.common.task.publisher.RvPublisherTask;

import sgcib.tmon.worker.common.task.publisher.bem.BemPublisherTask;

import sgcib.tmon.worker.common.task.rules.ChainRuleTask;

import sgcib.tmon.worker.common.task.rules.RuleTask;

import sgcib.tmon.worker.configuration.ChainRuleConfiguration;

import sgcib.tmon.worker.configuration.ConverterConfiguration;

import sgcib.tmon.worker.configuration.DropConfiguration;

import sgcib.tmon.worker.configuration.FeatureTrackingConfiguration;

import sgcib.tmon.worker.configuration.FilterConfiguration;

import sgcib.tmon.worker.configuration.MapperConfiguration;

import sgcib.tmon.worker.configuration.PublisherConfiguration;

import sgcib.tmon.worker.configuration.QueueConfiguration;

import sgcib.tmon.worker.configuration.RuleConfiguration;

import sgcib.tmon.worker.configuration.SequenceConfiguration;

import sgcib.tmon.worker.configuration.StoreConfiguration;

import sgcib.tmon.worker.configuration.TaskConfiguration;

import sgcib.tmon.worker.configuration.TransformConfiguration;

import sgcib.tmon.worker.configuration.UserAgentParserConfiguration;



import com.google.common.collect.ImmutableMap;

import sgcib.tmon.worker.extension.IExtensionManager;

import sgcib.tmon.worker.extension.ITaskFactoryBuilder;



/**

* Created by Stephane on 14/02/2015.

*/

public class StoredTaskFactory implements ITaskFactory {



    public static String defaultFactory = "default";



    private final IExtensionManager extensionManager;

    private final IStoreManager storeManager;

    private final ITaskManager taskManager;

    private final IClusterManager clusterManager;

    private final IAlertManager alertManager;

    private final Logger logger;

    private final Map<String, ITaskFactory> factories;





    public StoredTaskFactory(IStoreManager storeManager, ITaskManager taskManager, IClusterManager clusterManager, IAlertManager alertManager, IExtensionManager extensionManager) {

        this.storeManager = storeManager;

        this.taskManager = taskManager;

        this.clusterManager = clusterManager;

        this.alertManager = alertManager;

        this.logger = LoggerFactory.getLogger("StoredTaskFactory");

        this.extensionManager = extensionManager;

        this.factories = new ConcurrentHashMap<>();

        if ( extensionManager != null) {

            List<ITaskFactoryBuilder> builders = extensionManager.getExtensions(ITaskFactoryBuilder.class);

            builders.stream().forEach(b -> {

                this.factories.put(b.getName(), b.build(storeManager, taskManager, clusterManager, alertManager));

            });

        }

    }



    @Override

    public ITask build(String taskName) throws WorkerException {

        TaskConfiguration configuration = storeManager.getTaskConfigurationStore().readConfiguration(taskName);

        return build(configuration);

    }



    @Override

    public Map<String, ITask> buildAll(TaskType taskType) throws WorkerException {

        List<TaskConfiguration> configurations = storeManager.getTaskConfigurationStore().readAll(taskType);

        if (configurations != null && configurations.size() > 0) {

            ImmutableMap.Builder<String, ITask> builder = ImmutableMap.builder();



            for (TaskConfiguration configuration : configurations) {

                if (configuration != null) {

                    try {

                        ITask task =  build(configuration);

                        if (task != null) {

                            builder.put(configuration.getName(),task );

                        }

                    } catch (Exception error) {

                        this.logger.error("Cannot start task " + configuration.getName(), error);



                    }

                }

            }

            return builder.build();

        }

        return null;

    }



    @Override

    public ITask build(TaskConfiguration configuration) {

        ITask task = null;

        if (configuration != null) {

            switch (configuration.getTaskType()) {

                case Transform:

                    task = new TransformTask(new TransformConfiguration(configuration), this.alertManager);

                    break;

                case Store:

                    StoreConfiguration storeTaskConfiguration = new StoreConfiguration(configuration);

                    task = new StoreTask(storeManager.getStore(storeTaskConfiguration.getStore()), storeTaskConfiguration, this.alertManager);

                    break;

                case Convert:

                    task = new ConverterTask(new ConverterConfiguration(configuration), this.alertManager);

                    break;

                case Filter:

                    task = new FilterTask(new FilterConfiguration(configuration), this.alertManager);

                    break;

                case Map:

                    task = new MapperTask(new MapperConfiguration(configuration), this.alertManager);

                    break;

                case Sequence:

                    task = new SequenceTask(new SequenceConfiguration(configuration), taskManager, this.alertManager);

                    break;

                case UserAgent:

                    task = new UserAgentParserTask(new UserAgentParserConfiguration(configuration), this.alertManager);

                    break;

                case Rule:

                    task = new RuleTask(new RuleConfiguration(configuration), this.alertManager);

                    break;

                case ChainRule:

                    task = new ChainRuleTask(new ChainRuleConfiguration(configuration), this.storeManager, this.alertManager);

                    break;

                case Publisher:

                    PublisherConfiguration publisherConfiguration = new PublisherConfiguration(configuration);

                    switch (publisherConfiguration.getPublisherType()) {

                        case Kafka:

                            task = new KafkaPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        case Rv:

                            task = new RvPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        case Mail:

                            task = new MailPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        case Ems:

                            task = new EmsPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        case Geneos:

                            task = new GeneosPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        case Bem:

                            task = new BemPublisherTask(publisherConfiguration, this.alertManager);

                            break;

                        default:

                            break;

                    }

                    break;

                case FeatureTracking:

                    task = new FeatureTrackingTask(new FeatureTrackingConfiguration(configuration), this.storeManager.getFeatureStore(), this.alertManager);

                    break;

                case Drop:

                    task = new DropTask(new DropConfiguration(configuration), this.alertManager);

                    break;

                case Queue:

                    task = new QueueTask(new QueueConfiguration(configuration), taskManager, clusterManager, this.alertManager);

                    break;

                case Custom:

                    String factory = configuration.getFactory();

                    if (extensionManager != null ) {

                        ITaskFactory taskFactory = this.factories.get(factory);

                        if ( taskFactory != null ) {

                            task = taskFactory.build(configuration);

                        }

                    }

                    break;

                default:

                    throw new WorkerException("invalid task type: " + configuration.getTaskType());

            }



        }



        return task;

    }





}

package sgcib.tmon.worker.common.task;



/**

* Created by Stephane on 14/03/2015.

*/

public enum TaskAction {

    None,

    Process,

    ProcessMultiple

}

package sgcib.tmon.worker.common.task;



/**

* Created by slopes041604 on 22/05/2015.

*/

public enum TaskAffinity {

    None,

    Event,

    ChainStep,

    Chain,

    Alert,

    Metric

}

package sgcib.tmon.worker.common.task;



import java.util.List;



import rx.Observable;

import sgcib.tmon.worker.cluster.WorkerContext;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.TaskConfiguration;



import com.google.common.collect.ImmutableList;

import com.netflix.hystrix.HystrixCommand;

import com.netflix.hystrix.HystrixCommandGroupKey;

import com.netflix.hystrix.HystrixCommandKey;

import com.netflix.hystrix.HystrixThreadPoolKey;

import com.netflix.hystrix.HystrixThreadPoolProperties;



public abstract class TaskBase extends ManageableBase implements ITask {



    private final TaskAffinity affinity;

    private final TaskConfiguration configuration;

    protected IAlertManager alertManager;



    protected TaskBase(TaskConfiguration configuration, IAlertManager alertManager) {

        super(configuration.getName());

        this.configuration = configuration;

        this.affinity = configuration.getAffinity();

    }



    protected abstract boolean canProcess();



    protected Queryable doFallback(Queryable item) {

        return item;

    }



    protected List<Queryable> doFallback(List<Queryable> items) {

        return items;

    }



    protected boolean checkRunOnMaster() {

        if (configuration.runOnMaster()) {

            return WorkerContext.getInstance().isMaster();

        }

        return true;

    }



    /**

     * Only not droppable queryable {@code item} can be processed (i.e : drop

     * key != true).

     *

     * @param item

     *            The given {@link Queryable} instance.

     */

    protected boolean isNotDroppable(Queryable item) {



        if (item == null) {

            return true;

        }



        if (item.containsKey(Queryable.drop)) {

            return (item.get(Queryable.drop) == null || !(boolean) item.get(Queryable.drop));

        }



        return true;

    }



    protected abstract Queryable doProcess(Queryable item) throws WorkerException;



    protected List<Queryable> doProcessMultiple(List<Queryable> items) throws WorkerException {

        ImmutableList.Builder<Queryable> builder = new ImmutableList.Builder<Queryable>();

        for (Queryable item : items) {

            builder.add(doProcess(item));

        }

        return builder.build();

    }



    @Override

    public Observable<Queryable> process(Queryable item) {

        if (canProcess() && checkRunOnMaster() && isNotDroppable(item)) {

            return new DoProcess(item).observe();

        } else {

            return Observable.just(item);

        }

    }



    @Override

    public Observable<List<Queryable>> processMultiple(List<Queryable> items) {

        if (canProcess() && checkRunOnMaster()) {

            return new DoProcessMultiple(items).observe();

        } else {

            return Observable.just(items);

        }

    }



    @Override

    public TaskAffinity getAffinity() {

        return affinity;

    }



    private class DoProcess extends HystrixCommand<Queryable> {

        private final Queryable item;



        public DoProcess(Queryable item) {

            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(configuration.getName())).andCommandKey(HystrixCommandKey.Factory.asKey(String.format("%s.%s", configuration.getName(), "s")))

                    .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(configuration.getProcessPoolSize())).andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(configuration.getTaskType().toString())));



            this.item = item;

        }



        @Override

        protected Queryable run() throws Exception {

            try {

                return doProcess(item);

            } catch (Exception error) {

                getLogger().error("Failed to  send message", error);

                throw error;

            }

        }



        @Override

        protected Queryable getFallback() {

            return doFallback(this.item);

        }

    }



    private class DoProcessMultiple extends HystrixCommand<List<Queryable>> {

        private final List<Queryable> items;



        public DoProcessMultiple(List<Queryable> items) {

            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(configuration.getName())).andCommandKey(HystrixCommandKey.Factory.asKey(String.format("%s.%s", configuration.getName(), "m")))

                    .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(configuration.getProcessMultiplePoolSize())).andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(configuration.getTaskType().toString())));

            this.items = items;

        }



        @Override

        protected List<Queryable> run() throws Exception {

            return doProcessMultiple(items);

        }



        @Override

        protected List<Queryable> getFallback() {

            return doFallback(this.items);

        }

    }



    public TaskConfiguration getTaskConfiguration() {

        return configuration;

    }



}

package sgcib.tmon.worker.common.task;



import org.joda.time.DateTime;

import sgcib.tmon.worker.common.model.Queryable;



import java.io.Serializable;

import java.util.Map;

import java.util.UUID;



/**

* Created by Stephane on 09/03/2015.

*/

public class TaskError extends Queryable implements Serializable {



    public static String action = "action";

    public static String taskName = "taskName";

    public static String errorMessage = "errorMessage";



    public TaskError(Map data) {

        super(data);

    }



    public TaskError(String taskName, TaskAction action, String errorMessage) {

        setValue(TaskError.action, action.toString());

        setValue(TaskError.taskName, taskName);

        setValue(TaskError.errorMessage, errorMessage);

        setId(UUID.randomUUID().toString());

        setTimestamp(DateTime.now());

        setType("taskError");

    }



    public String getTaskName() {

        return (String) get(TaskError.taskName);

    }



    public String getErrorMessage() {

        return (String) get(TaskError.errorMessage);

    }



    public TaskAction getAction() {

        return TaskAction.valueOf(getValue(TaskError.action).toString());

    }



}

package sgcib.tmon.worker.common.task;



import rx.Observer;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Metric;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.error.ITaskErrorStore;



import java.util.List;



/**

* Created by Stephane on 14/03/2015.

*/

public class TaskErrorManager extends ManageableBase implements Observer<Queryable>{

    private final ITaskErrorStore errorStore;



    public TaskErrorManager(String name, ITaskErrorStore errorStore) {

        super(name);

        this.errorStore = errorStore;



    }



    @Override

    public void start() throws WorkerException {

    }



    @Override

    public void stop() throws WorkerException {

    }





    @Override

    public void onCompleted() {



    }



    @Override

    public void onError(Throwable throwable) {

        if (errorStore != null) {

            TaskError error = new TaskError(getName(),TaskAction.Process,throwable.getMessage());

            errorStore.registerError(error);

        }

    }



    @Override

   public void onNext(Queryable queryable) {



    }

}

package sgcib.tmon.worker.common.task;



import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;



/**

* Created by Stephane on 14/03/2015.

*/

public class TaskErrorStatus {

    private final String statusMessage;

    private final Map<String, Long> errorsMap;



    public TaskErrorStatus(String statusMessage) {

        this.statusMessage = statusMessage;

        this.errorsMap = new ConcurrentHashMap<String, Long>();

    }



    public void addError(String taskName, long retryCount) {

        if (!errorsMap.containsKey(taskName)) {

            errorsMap.put(taskName, 0L);

        }

        errorsMap.put(taskName, errorsMap.get(taskName) + retryCount);

    }



    public Map<String, Long> getErrorsMap() {

        return errorsMap;

    }



    public String getStatusMessage() {

        return statusMessage;

    }

}

package sgcib.tmon.worker.common.task;



import rx.Observable;

import sgcib.tmon.worker.cluster.IClusterManager;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.common.store.IStoreManager;

import sgcib.tmon.worker.common.store.error.ITaskErrorStore;

import sgcib.tmon.worker.common.store.metric.IMetricStore;

import sgcib.tmon.worker.configuration.TaskConfiguration;

import sgcib.tmon.worker.extension.IExtensionManager;



import java.util.List;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.atomic.AtomicReference;



/**

* Created by Stephane on 14/03/2015.

*/

public class TaskManager extends ManageableBase implements ITaskManager {

    private final ITaskFactory taskFactory;

    private Map<String, ITask> tasks;

    private IMetricStore metricStore;

    private ITaskErrorStore errorStore;





    public TaskManager(IStoreManager storeManager, IAlertManager alertManager, IClusterManager clusterManager, IExtensionManager extensionManager) {

        super("TaskManager");



        if (storeManager != null) {

            this.tasks = new ConcurrentHashMap<String, ITask>();

            this.taskFactory = new StoredTaskFactory(storeManager, this, clusterManager, alertManager, extensionManager);

            this.metricStore = storeManager.getMetricStore();

            this.errorStore = storeManager.getTaskErrorStore();

            alertManager.setTaskManager(this);



        } else {

            this.tasks = null;

            this.taskFactory = null;

        }



    }



    @Override

    public void start() throws WorkerException {



        if (tasks != null) {

            for (TaskType type : TaskType.values()) {

                Map<String, ITask> typedTasks = this.taskFactory.buildAll(type);

                if (typedTasks != null && typedTasks.size() > 0) {

                    for (Map.Entry<String, ITask> typedTask : typedTasks.entrySet()) {

                        this.tasks.put(typedTask.getKey(), typedTask.getValue());

                    }

                }

            }

            for (ITask task : this.tasks.values()) {

                try {

                    task.start();

                } catch (Exception error) {

                    getLogger().error("Cannot start task " + task.getName(), error);

                }

            }

        }

    }



    @Override

    public void stop() throws WorkerException {

        if (tasks != null) {

            for (ITask task : this.tasks.values()) {

                task.stop();

            }

        }

    }





    @Override

    public void process(Queryable item, String taskName, int timeoutInSeconds) {

        if (tasks != null) {

            if (tasks.containsKey(taskName)) {

                ITask task = tasks.get(taskName);

                if (task != null) {

                    TaskErrorManager errorManager = new TaskErrorManager(taskName, this.errorStore);

                    try {

                        Observable<Queryable> result = task.process(item);

                        if (timeoutInSeconds == -1) {

                            result.toBlocking().single();

                        } else {

                            result.subscribe(errorManager);

                        }

                    } catch (Exception error) {

                        String errorMessage = String.format("Failed to  process item with task %s : %s ", taskName, error.getMessage());

                        errorManager.onError(error);

                        getLogger().error(errorMessage, error);

                    }

                }

            }

        }

    }



    @Override

    public void processMultiple(List<Queryable> items, String taskName, int timeoutInSeconds) {

        if (tasks != null) {

            if (tasks.containsKey(taskName)) {

                ITask task = tasks.get(taskName);

                if (task != null) {

                    MultipleTaskErrorManager errorManager = new MultipleTaskErrorManager(taskName, this.errorStore);

                    try {

                        Observable<List<Queryable>> result = task.processMultiple(items);

                        if (timeoutInSeconds == -1) {

                            result.toBlocking().single();

                        } else {

                            result.subscribe(errorManager);

                        }

                    } catch (Exception error) {

                        String errorMessage = String.format("Failed to  process multiple items with task %s : %s ", taskName, error.getMessage());

                        errorManager.onError(error);

                        getLogger().error(errorMessage, error);

                    }

                }

            }

        }

    }



    @Override

    public void deleteTask(TaskConfiguration configuration) {

        if (this.tasks != null) {

            if (this.tasks.containsKey(configuration.getName())) {

                this.tasks.remove(configuration.getName());

            }

        }

    }



    @Override

    public ITask updateTask(TaskConfiguration configuration) {

        if (this.tasks != null && taskFactory != null) {

            if (this.tasks.containsKey(configuration.getName())) {

                ITask oldTask = this.tasks.get(configuration.getName());

                ITask newTask = taskFactory.build(configuration);

                newTask.start();

                this.tasks.put(configuration.getName(), newTask);

                if (oldTask != null) {

                    oldTask.stop();

                }

                return newTask;

            } else {

                return createTask(configuration);

            }

        }

        return null;

    }



    @Override

    public ITask createTask(TaskConfiguration configuration) {

        if (this.tasks != null && taskFactory != null) {

            if (!this.tasks.containsKey(configuration.getName())) {

                ITask newTask = taskFactory.build(configuration);

                newTask.start();

                this.tasks.put(configuration.getName(), newTask);

                return newTask;

            } else {

                return updateTask(configuration);

            }

        }

        return null;

    }



    @Override

    public ITask getTask(String taskName) {

        if (this.tasks != null) {

            ITask task = tasks.get(taskName);

            if (task != null) {

                return task;

            }

        }

        return null;

    }



}

package sgcib.tmon.worker.common.task;



/**

* Created by Stephane on 15/02/2015.

*/

public class TaskMessage {

    private final TaskType taskType;



    public TaskMessage(TaskType taskType) {

        this.taskType = taskType;

    }





    public TaskType getTaskType() {

        return taskType;

    }

}

package sgcib.tmon.worker.common.task;

/**

* Created by Stephane on 14/02/2015.

*/

public enum TaskType {

    Transform,

    Store,

    Sequence,

    UserAgent,

    Map,

    Filter,

    Convert,

    Rule,

    Publisher,

    ChainRule,

    FeatureTracking,

    Drop,

               Queue,

    Custom

}

package sgcib.tmon.worker.common.task;



import java.io.StringWriter;

import java.util.concurrent.ExecutorService;



import org.apache.velocity.VelocityContext;

import org.apache.velocity.app.VelocityEngine;



import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.TransformConfiguration;



import com.codahale.metrics.annotation.Timed;



/**

* Created by Stephane on 07/12/2014.

*/

public class TransformTask extends TaskBase {

    private VelocityEngine engine;

    private final String template;



    public TransformTask(TransformConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        TransformConfiguration transformConfiguration = new TransformConfiguration(configuration);

        this.template = transformConfiguration.getTemplate();

    }



    @Override

    protected boolean canProcess() {

        return (engine != null);

    }



    @Override

    @Timed(name = "TransformTask.doProcess")

    protected Queryable doProcess(Queryable item) {

        try {

            StringWriter writer = new StringWriter();

            VelocityContext context = new VelocityContext();

            context.put("item", item);

            engine.evaluate(context, writer, getName(), template);



        } catch (Exception error) {

            getLogger().error(error.getMessage(), error);

            item.put(getErrorField(), error.getMessage());

        }

        return item;

    }



    @Override

    public String getErrorField() {

        return "transformError";

    }



    @Override

    public void start() throws WorkerException {

        engine = new VelocityEngine();

        engine.init();

    }



    @Override

    public void stop() throws WorkerException {

        engine = null;

    }



}

package sgcib.tmon.worker.common.task;



import com.google.common.cache.Cache;

import com.google.common.cache.CacheBuilder;

import net.sf.uadetector.ReadableUserAgent;

import net.sf.uadetector.UserAgentStringParser;

import net.sf.uadetector.service.UADetectorServiceFactory;

import sgcib.tmon.worker.common.alert.IAlertManager;

import sgcib.tmon.worker.common.exception.WorkerException;

import sgcib.tmon.worker.common.model.Queryable;

import sgcib.tmon.worker.configuration.UserAgentParserConfiguration;



import java.util.concurrent.ExecutorService;

import java.util.concurrent.TimeUnit;



/**

* Created by Stephane on 27/02/2015.

*/

public class UserAgentParserTask extends TaskBase {

    private final String userAgentField;

    private final UserAgentStringParser parser;

    private final Cache<String, ReadableUserAgent> cache;



    public UserAgentParserTask(UserAgentParserConfiguration configuration, IAlertManager alertManager) {

        super(configuration, alertManager);

        UserAgentParserConfiguration userAgentParserConfiguration = new UserAgentParserConfiguration(configuration);

        this.userAgentField = userAgentParserConfiguration.getUserAgentField();

        this.parser = UADetectorServiceFactory.getCachingAndUpdatingParser();

        this.cache = CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.HOURS).build();

    }



    @Override

    protected boolean canProcess() {

        return (userAgentField != null);

    }



    @Override

    protected Queryable doProcess(Queryable item) {

        if (item == null) return item;

        if (item.containsKey(userAgentField)) {

            Object value = item.get(userAgentField);

            if (value != null) {

                String userAgentString = value.toString();

                ReadableUserAgent result = cache.getIfPresent(userAgentString);

                if (result == null) {

                    result = parser.parse(userAgentString);

                    cache.put(userAgentString, result);

                }

                item.put("userAgentDeviceCategory", result.getDeviceCategory().getCategory());

                item.put("userAgentName", result.getName());

                item.put("userAgentOperatingSystem", result.getOperatingSystem().getName());

                item.put("userAgentOperatingSystemVersion", result.getOperatingSystem().getVersionNumber().toVersionString());

                item.put("userAgentProducer", result.getProducer());

                item.put("userAgentType", result.getType().getName());

                item.put("userAgentVersion", result.getVersionNumber().toVersionString());

            }

        }

        return item;

    }



    @Override

    public String getErrorField() {

        return "userAgentParserError";

    }



    @Override

    public void start() throws WorkerException {



    }



    @Override

    public void stop() throws WorkerException {



    }





}

package sgcib.tmon.worker.common.utils;



import sgcib.tmon.worker.common.model.Alert;

import sgcib.tmon.worker.common.model.AlertStatus;



/**

* @author ablaszcz120213

*

*/

public class AlertUtils {



    /**

     * Return {@code true} if the given alert {@code alert} is closed or

     * cancelled, {@code false} otherwise.

     *

     * @param alert

     *            Instance of {@link Alert}

     */

    public static boolean isClosedOrCancelled(Alert alert) {

        return AlertStatus.Closed.equals(alert.getStatus()) || AlertStatus.Cancelled.equals(alert.getStatus());

    }

}

package sgcib.tmon.worker.common.utils;



/**

* Created by adouangp012014 on 16/06/2015.

*/

public class CheckResult {



    private boolean valid;

    private Exception error;



    public CheckResult() {

        this.valid = true;

    }



    public boolean isValid() {

        return valid;

    }



    public void setValid(boolean valid) {

        this.valid = valid;

    }



    public Exception getError() {

        return error;

    }



    public void setError(Exception error) {

        setValid(false);

        this.error = error;

    }

}

package sgcib.tmon.worker.common.utils;



import org.joda.time.DateTime;

import org.joda.time.DateTimeZone;



public class DateUtils {



                public static DateTime getUTCDate() {

                                return new DateTime().withZone(DateTimeZone.UTC);

                }

}





package sgcib.tmon.worker.common.utils;



import java.util.List;



public class StringUtils {

                /**

                * Concatenates the contents of a list in a string using ', ' between each list entry

                * @param list the list to concatenate

                * @return a string containing the list entries separated by ', '

                */

                public static String concatenateList(List<String> list) {

                                return concatenateList(list, ",");

                }



                /**

                * Concatenates the contents of a list in a string using the given separator between each list entry

                * @param list the list to concatenate

                * @param separator the separator used to separate each list entry

                * @return a string containing the list entries separated by the given separator

                */

                public static String concatenateList(List<String> list, String separator) {

                                if (list == null) {

                                                throw new IllegalArgumentException("list cannot be null");

                                }



                                if (separator == null || separator.length() == 0) {

                                                throw new IllegalArgumentException("separator cannot be null or empty");

                                }



                                if (list.size() == 0) {

                                                return "";

                                }



                                StringBuilder buf = new StringBuilder();

                                boolean first = true;



                                for (String elt : list) {

                                                if (first) {

                                                                first = false;

                                                }

                                                else {

                                                                buf.append(separator);

                                                }



                                                buf.append(elt.trim());

                                }



                                return buf.toString();

                }

}

package sgcib.tmon.worker.common.utils;



import java.util.Map;

import java.util.UUID;



import org.joda.time.DateTime;



import sgcib.tmon.worker.service.DataContext;

import sgcib.tmon.worker.service.DataService;



import com.google.common.collect.Maps;



/**

* Created with IntelliJ IDEA. User: adouangp012014 Date: 22/05/14 Time: 16:41

* To change this template use File | Settings | File Templates.

*/

public class TokenUtils {



    public static String create(DataService dataService, String email) {



        DataContext dataContext = new DataContext();

        String[] indices = new String[1];

        indices[0] = "configuration";

        dataContext.setIndices(indices);

        dataContext.setType("token");



        Map<String, Object> tokenExist = null;

        String token = "";



        Map<String, Object> items = Maps.newHashMap();



        do {



            UUID uuid = UUID.randomUUID();

            token = uuid.toString();

            dataContext.setId(token);



            items.put("email", email);



            dataContext.setItem(items);



            tokenExist = dataService.read(dataContext);



        } while (tokenExist != null);



        items.put("@timestamp", new DateTime());



        dataService.create(dataContext);



        return token;

    }



    public static String check(DataService dataService, String token) {



        String email = null;



        if (token == null) {

            return email;

        }



        DataContext dataContext = new DataContext();

        String[] indices = new String[1];

        indices[0] = "configuration";

        dataContext.setIndices(indices);

        dataContext.setType("token");

        dataContext.setId(token);



        Map<String, Object> tokenExist = dataService.read(dataContext);



        if (tokenExist != null) {

            email = tokenExist.get("email").toString();

        }



        return email;

    }



    public static boolean delete(DataService dataService, String token) {

        if (token == null) {

            return false;

        }



        DataContext dataContext = new DataContext();

        String[] indices = new String[1];

        indices[0] = "configuration";

        dataContext.setIndices(indices);

        dataContext.setType("token");

        dataContext.setId(token);



        return dataService.delete(dataContext);

    }



}

package sgcib.tmon.worker.common.utils;



import org.apache.velocity.VelocityContext;

import org.apache.velocity.app.Velocity;



import java.io.StringWriter;



/**

* Created by adouangp012014 on 16/06/2015.

*/

public class VelocityUtils {



    private static VelocityContext context = new VelocityContext();

    private static StringWriter writer = new StringWriter();

    private static String logTag = "VALIDATE_SYNTAX";



    /**

     *

     * @param template

     */

    public static void validate(String template) {

        Velocity.evaluate(context,

                writer,

                logTag,  // used for logging

                template);

    }

}

package sgcib.tmon.worker.common.utils;



import java.util.Optional;



import sgcib.arc.eai.jms.emswrapper.EMSWrapper;

import sgcib.tmon.worker.common.task.TaskType;

import sgcib.tmon.worker.common.task.publisher.EmsWrapperConfiguration;

import sgcib.tmon.worker.common.task.publisher.IEmsConstant;

import sgcib.tmon.worker.configuration.PublisherConfiguration;

import sgcib.tmon.worker.configuration.PublisherConfigurationType;

import sgcib.tmon.worker.configuration.TaskConfiguration;



/**

* @author ablaszcz120213

*

*/

public class WorkerConfigurationUtils implements IEmsConstant {



    /**

     * Return an optional instance of EMS Wrapper {@link EMSWrapper} from the

     * given configuration {@link TaskConfiguration}. Note that only publisher

     * task contains EMS configuration type.

     *

     * @param configuration

     *            Instance of {@link TaskConfiguration}.

     */

    public static Optional<EMSWrapper> emsWrapper(TaskConfiguration configuration) {



        Optional<TaskConfiguration> opt = Optional.ofNullable(configuration);



        if (opt.isPresent()) {



            if (TaskType.Publisher.equals(configuration.getTaskType())) {



                PublisherConfiguration publisherConfiguration = new PublisherConfiguration(opt.get());



                if (PublisherConfigurationType.Ems.equals(publisherConfiguration.getPublisherType())) {



                    EmsWrapperConfiguration emsWrapperConfiguration = new EmsWrapperConfiguration() //

                            .setAppName((String) publisherConfiguration.get(appNameField)) //

                            .setTopic(publisherConfiguration.getTopic()) //

                            .setVersion((String) publisherConfiguration.get(versionField)) //

                            .setCertificatePath((String) publisherConfiguration.get(certificatePathField)) //

                            .setLogin((String) publisherConfiguration.get(loginField)) //

                            .setPassword((String) publisherConfiguration.get(passwordField)) //

                            .setReplyPrefix((String) publisherConfiguration.get(replyPrefixField)) //

                            .setConnectionFactoryName((String) publisherConfiguration.get(connectionFactoryNameField)) //

                            .setOther((String) publisherConfiguration.get(otherField)) //

                            .setJavaNamingFactoryInitial((String) publisherConfiguration.get(javaNamingFactoryInitialField)) //

                            .setTibjmsUrlList((String) publisherConfiguration.get(tibjmsUrlListField)) //

                            .setTibjmsSslVendor((String) publisherConfiguration.get(tibjmsSslVendorField)) //

                            .setTibjmsSecurityProtocol((String) publisherConfiguration.get(tibjmsSecurityProtocolField)) //

                            .setTibjmsSslDebugTrace((String) publisherConfiguration.get(tibjmsSslDebugTraceField)) //

                            .setTibjmsSslEnableVerifyHost((String) publisherConfiguration.get(tibjmsSslEnableVerifyHostField)) //

                            .setTibjmsSslEnableVerifyHostname((String) publisherConfiguration.get(tibjmsSslEnableVerifyHostnameField)) //

                            .setTibjmsSslExpectedHostname((String) publisherConfiguration.get(tibjmsSslExpectedHostnameField)) //

                            .setTibjmsSslCipherSuites((String) publisherConfiguration.get(tibjmsSslCipherSuitesField));



                    EMSWrapper emsWrapper = new EMSWrapper(false);

                    emsWrapper.setAppName(emsWrapperConfiguration.getAppName());

                    emsWrapper.setVersion(emsWrapperConfiguration.getVersion());

                    emsWrapper.setCertificatePath(emsWrapperConfiguration.getCertificatePath());

                    emsWrapper.setLogin(emsWrapperConfiguration.getLogin());

                    emsWrapper.setPassword(emsWrapperConfiguration.getPassword());

                    emsWrapper.setReplyPrefix(emsWrapperConfiguration.getReplyPrefix());

                    emsWrapper.setConnectionFactoryName(emsWrapperConfiguration.getConnectionFactoryName());

                    emsWrapper.setOther(emsWrapperConfiguration.getOther());

                    emsWrapper.setJndiProps(emsWrapperConfiguration.getJndiProps());



                    return Optional.of(emsWrapper);

                }

            }

        }



        return Optional.empty();

    }

}

package sgcib.tmon.worker.drools.util;



public class Activation {



    /**

     * The name of the rule which was activated.

     */

    private String ruleName;



    /**

     * Default no-args constructor.

     */

    public Activation() {

    }



    /**

     * Simple constructor for just noting a rule name for an activation.

     *

     * @param ruleName

     *            The name of the rule which was activated.

     */

    public Activation(String ruleName) {

        this.ruleName = ruleName;

    }



    /**

     * @return The name of the rule which was activated.

     */

    public String getRuleName() {

        return ruleName;

    }



    /**

     * @param ruleName

     *            The name of the rule which was activated.

     */

    public void setRuleName(String ruleName) {

        this.ruleName = ruleName;

    }



    @Override

    public String toString() {

        StringBuilder sb = new StringBuilder();

        sb.append("Activation[ruleName=" + ruleName);

        sb.append("]");

        return sb.toString();

    }

}

package sgcib.tmon.worker.drools.util;



import java.lang.reflect.InvocationTargetException;

import java.util.Map;



import org.apache.commons.beanutils.BeanUtils;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



import com.google.common.collect.Maps;



public class BeanMatcher {



    private static Logger log = LoggerFactory.getLogger(BeanMatcher.class);



    /**

     * Can all key/value pairs in the filters be found in the bean properties?

     * If any filter is not in the bean properties or the value differs, then

     * this will return false.

     *

     * The filters should be defined as an array of String, where each property

     * name/value pair is a String, like so:

     *

     * <pre>

     * String[] filters = { &quot;uncle=Bob&quot;, &quot;aunt=Fanny&quot; };

     * </pre>

     *

     * This is a convenience method so that matchers can be defined with minimal

     * LOC.

     */

    public boolean matches(Object bean, String[] filters) {

        if (filters.length == 0) {

            return true;

        }

        return matches(bean, parseFilters(filters));

    }



    /**

     * Can all key/value pairs in the filters be found in the bean properties?

     * If any filter is not in the bean properties or the value differs, then

     * this will return false.

     *

     * @param bean

     *            The bean to examine.

     * @param filters

     *            Vararg list of filters.

     * @return True if all the filter properties match on the bean.

     */

    public boolean matches(Object bean, BeanPropertyFilter... filters) {

        if (filters.length == 0) {

            return true;

        }

        Map<String, Object> filtermap = Maps.newHashMap();

        for (BeanPropertyFilter filter : filters) {

            filtermap.put(filter.getPropertyName(), filter.getPropertyValue());

        }

        return matches(bean, filtermap);

    }



    /**

     * Can all key/value pairs in the filters be found in the bean properties?

     * If any filter is not in the bean properties or the value differs, then

     * this will return false.

     */

    @SuppressWarnings("unchecked")

    public boolean matches(Object bean, Map<String, Object> filters) {

        if (filters.size() == 0) {

            return true;

        }

        try {

            return matches(BeanUtils.describe(bean), filters);

        } catch (IllegalAccessException e) {

            return false;

        } catch (InvocationTargetException e) {

            return false;

        } catch (NoSuchMethodException e) {

            return false;

        }

    }



    /**

     * Can all key/value pairs in the filters be found in the bean properties?

     * If any filter is not in the bean properties or the value differs, then

     * this will return false.

     */

    public boolean matches(Map<String, Object> beanProperties, Map<String, Object> filters) {

        if (filters.size() == 0) {

            return true;

        }

        if (log.isDebugEnabled()) {

            logComparison(beanProperties, filters);

        }

        for (String key : filters.keySet()) {

            if (!beanProperties.containsKey(key) || !isEquivalent(filters.get(key), beanProperties.get(key))) {

                return false;

            }

        }

        // None of the filters failed to match, so it must be okay.

        return true;

    }



    /**

     * This method will log the bean properties and the filter properties at

     * debug level.

     *

     * @param beanProperties

     *            The field names and their values for a bean.

     * @param filters

     *            The filters we are looking to match.

     */

    private void logComparison(Map<String, Object> beanProperties, Map<String, Object> filters) {

        StringBuilder filterValues = new StringBuilder();

        StringBuilder beanValues = new StringBuilder();



        for (String key : filters.keySet()) {

            filterValues.append(key + "=" + filters.get(key) + ",");

            if (beanProperties.containsKey(key)) {

                beanValues.append(key + "=" + beanProperties.get(key) + ",");

            } else {

                beanValues.append("No property.");

            }

        }



        log.debug("Matching filters: " + filterValues.toString() + "\nto bean properties:" + beanValues.toString());

    }



    /**

     * When a fact is retrieved from the working memory as a bean and we parse

     * its get/set methods, all properties have their first letter in lower case

     * in the usual Java Bean convention. This is usually fine, but if the first

     * letter of a fact property should be upper-case, it's much more readable

     * (particularly in the tests) if we define the field we're looking for with

     * the same text as that associated with the fact. So we lower-case the

     * first letter of the property defined in the filters.

     * <p>

     * We're deliberately losing the ability to perform case-sensitive matches

     * where the first letter makes a difference.

     * </p>

     */

    protected String lowercaseFirstLetter(String text) {

        if (text == null || text.length() == 0) {

            return text;

        } else {

            return text.substring(0, 1).toLowerCase() + text.substring(1, text.length());

        }

    }



    /**

     * Takes an array of <code>String</code> defined like so:

     *

     * <pre>

     * String[] filters = { &quot;uncle=Bob&quot;, &quot;aunt=Fanny&quot; };

     * </pre>

     *

     * Converts this into a Map of String keys to Object values by splitting

     * each element on the "=" symbol.

     */

    private Map<String, Object> parseFilters(String[] filters) {

        Map<String, Object> map = Maps.newHashMap();

        for (String filter : filters) {

            String[] keyval = filter.split("=");

            if (keyval.length != 2) {

                throw new IllegalArgumentException("Filter [" + filter + "] does not parse to a key/value pair.");

            }

            map.put(lowercaseFirstLetter(keyval[0]), keyval[1]);

        }

        return map;

    }



    /**

     * As the commons BeanUtils give us the String value of each property, we

     * match on whether that String value is the same, rather than being able to

     * test whether one object truly equals the other.

     */

    protected boolean isEquivalent(Object o1, Object o2) {

        log.debug("    matching: " + o1 + " and " + o2);

        if (o1 == null && o2 == null) {

            return true;

        }

        if (o1 == o2) {

            return true;

        }

        if (o1.toString().equals(o2.toString())) {

            return true;

        }

        return false;

    }

}

package sgcib.tmon.worker.drools.util;



public class BeanPropertyFilter {



    private String propertyName;

    private Object propertyValue;



    /**

     * Void constructor.

     */

    public BeanPropertyFilter() {

        propertyName = null;

        propertyValue = null;

    }



    /**

     *

     * @param propertyName

     *            The name of the property we are filtering on. i.e. There

     *            should be a "get" method.

     * @param propertyValue

     *            The expected value of the property we are filtering on.

     */

    public BeanPropertyFilter(String propertyName, Object propertyValue) {

        this.propertyName = propertyName;

        this.propertyValue = propertyValue;

    }



    /**

     * The name of the property we are filtering on. i.e. There should be a

     * "get" method.

     */

    public String getPropertyName() {

        return propertyName;

    }



    /**

     * Set the name of the property we are filtering on. i.e. There should be a

     * "get" method.

     */

    public void setPropertyName(String name) {

        this.propertyName = name;

    }



    /**

     * The expected value of the property we are filtering on.

     */

    public Object getPropertyValue() {

        return propertyValue;

    }



    /**

     * Set the expected value of the property we are filtering on.

     */

    public void setPropertyValue(Object value) {

        this.propertyValue = value;

    }



    @Override

    public String toString() {

        return "BeanProperty:{name=" + propertyName + ", value=" + propertyValue + "}";

    }

}

package sgcib.tmon.worker.drools.util;



import org.kie.api.io.ResourceType;



public class DroolsResource {



    private String path;

    private ResourcePathType pathType;

    private ResourceType type;

    private String username = null;

    private String password = null;



    /**

     *

     * @param path

     *            The path to this resource.

     * @param pathType

     *            The type of path (FILE, URL, etc).

     * @param type

     *            The type of resource (DRL, Binary package, DSL, etc)

     */

    public DroolsResource(String path, ResourcePathType pathType, ResourceType type) {

        this.path = path;

        this.pathType = pathType;

        this.type = type;

    }



    /**

     * Constructor for when the resource is secured. i.e. When the resource is a

     * Guvnor package being accessed via the REST API, and Guvnor requires a

     * user name and password to connect.

     *

     * @param path

     *            The path to this resource.

     * @param pathType

     *            The type of path (FILE, URL, etc).

     * @param type

     *            The type of resource (DRL, Binary package, DSL, etc)

     * @param username

     *            The user name for connecting to the resource.

     * @param password

     *            The password for connecting to the resource.

     */

    public DroolsResource(String path, ResourcePathType pathType, ResourceType type, String username, String password) {

        this.path = path;

        this.pathType = pathType;

        this.type = type;

        this.username = username;

        this.password = password;

    }



    /**

     * @return The path to this resource.

     */

    public String getPath() {

        return path;

    }



    /**

     * @param path

     *            The path to this resource.

     */

    public void setPath(String path) {

        this.path = path;

    }



    /**

     * @return The type of path (FILE, URL, etc).

     */

    public ResourcePathType getPathType() {

        return pathType;

    }



    /**

     * @param pathType

     *            The type of path (FILE, URL, etc).

     */

    public void setPathType(ResourcePathType pathType) {

        this.pathType = pathType;

    }



    /**

     * @return The type of resource (DRL, Binary package, DSL, etc)

     */

    public ResourceType getType() {

        return type;

    }



    /**

     * @param type

     *            The type of resource (DRL, Binary package, DSL, etc)

     */

    public void setType(ResourceType type) {

        this.type = type;

    }



    /**

     * @return The user name for connecting to the resource.

     */

    public String getUsername() {

        return username;

    }



    /**

     * @param username

     *            The user name for connecting to the resource.

     */

    public void setUsername(String username) {

        this.username = username;

    }



    /**

     * @return The password for connecting to the resource.

     */

    public String getPassword() {

        return password;

    }



    /**

     * @param password

     *            The password for connecting to the resource.

     */

    public void setPassword(String password) {

        this.password = password;

    }

}

package sgcib.tmon.worker.drools.util;



import java.lang.reflect.InvocationTargetException;

import java.util.Collection;

import java.util.List;

import java.util.Map;



import org.apache.commons.beanutils.BeanUtils;

import org.drools.core.io.impl.UrlResource;

import org.kie.api.KieBase;

import org.kie.api.KieBaseConfiguration;

import org.kie.api.conf.EventProcessingOption;

import org.kie.api.definition.KiePackage;

import org.kie.api.definition.rule.Rule;

import org.kie.api.event.rule.ObjectInsertedEvent;

import org.kie.internal.KnowledgeBaseFactory;

import org.kie.internal.builder.KnowledgeBuilder;

import org.kie.internal.builder.KnowledgeBuilderFactory;

import org.kie.internal.io.ResourceFactory;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



public class DroolsUtil {



    private static Logger log = LoggerFactory.getLogger(DroolsUtil.class);



    private static BeanMatcher matcher = new BeanMatcher();



    public static KieBase createKnowledgeBase(DroolsResource[] resources) {

        return createKnowledgeBase(resources, EventProcessingOption.STREAM);

    }



    /**

     * Creates a new knowledge base using a collection of resources.

     *

     * @param resources

     *            An array of {@link DroolsResource} indicating where the

     *            various resources should be loaded from. These could be

     *            classpath, file or URL resources.

     * @return A new knowledge base.

     */

    public static KieBase createKnowledgeBase(DroolsResource[] resources, EventProcessingOption eventProcessingOption) {

        KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();



        for (DroolsResource resource : resources) {

            log.info("Resource: " + resource.getType() + ", path type=" + resource.getPathType() + ", path=" + resource.getPath());

            switch (resource.getPathType()) {

            case CLASSPATH:

                builder.add(ResourceFactory.newClassPathResource(resource.getPath()), resource.getType());

                break;

            case FILE:

                builder.add(ResourceFactory.newFileResource(resource.getPath()), resource.getType());

                break;

            case URL:

                UrlResource urlResource = (UrlResource) ResourceFactory.newUrlResource(resource.getPath());



                if (resource.getUsername() != null) {

                    log.info("Setting authentication for: " + resource.getUsername());

                    urlResource.setBasicAuthentication("enabled");

                    urlResource.setUsername(resource.getUsername());

                    urlResource.setPassword(resource.getPassword());

                }



                builder.add(urlResource, resource.getType());



                break;

            default:

                throw new IllegalArgumentException("Unable to build this resource path type.");

            }

        }



        if (builder.hasErrors()) {

            throw new RuntimeException(builder.getErrors().toString());

        }



        KieBaseConfiguration conf = KnowledgeBaseFactory.newKnowledgeBaseConfiguration();

        conf.setOption(eventProcessingOption);



        KieBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase(conf);

        knowledgeBase.getKiePackages().addAll(builder.getKnowledgePackages());



        // Output the packages in this knowledge base.

        Collection<KiePackage> packages = knowledgeBase.getKiePackages();



        StringBuilder sb = new StringBuilder();

        for (KiePackage p : packages) {

            sb.append("\n  Package : " + p.getName());

            for (Rule r : p.getRules()) {

                sb.append("\n    Rule: " + r.getName());

            }

        }

        log.info("Knowledge base built with packages: " + sb.toString());



        return knowledgeBase;

    }



    /**

     * Return a string containing the packages used to build the knowledge base.

     */

    public static String knowledgeBaseDetails(KieBase kbase) {

        if (kbase == null) {

            return "Knowledge Base is null.";

        } else {

            StringBuilder sb = new StringBuilder("Knowledge base built from the following packages:");

            Collection<KiePackage> packages = kbase.getKiePackages();

            for (KiePackage kp : packages) {

                sb.append("\n    Package: [" + kp.getName() + "]");

                for (Rule rule : kp.getRules()) {

                    sb.append("\n        Rule: [" + rule.getName() + "]");

                }

            }

            return sb.toString();

        }

    }



    public static String objectDetails(Object o) {

        StringBuilder sb = new StringBuilder(o.getClass().getSimpleName());



        try {

            @SuppressWarnings("unchecked")

            Map<String, Object> objectProperties = BeanUtils.describe(o);

            for (String k : objectProperties.keySet()) {

                sb.append(", " + k + "=\"" + objectProperties.get(k) + "\"");

            }

        } catch (IllegalAccessException e) {

            return "IllegalAccessException attempting to parse object.";

        } catch (InvocationTargetException e) {

            return "InvocationTargetException attempting to parse object.";

        } catch (NoSuchMethodException e) {

            return "NoSuchMethodException attempting to parse object.";

        }



        return sb.toString();

    }



    public static Object findInsertedFact(List<ObjectInsertedEvent> insertions, String factType, String[] filters) {

        for (ObjectInsertedEvent event : insertions) {

            Object fact = event.getObject();



            if (factType.equals(fact.getClass().getSimpleName())) {

                if (matcher.matches(fact, filters)) {

                    return fact;

                }

            }

        }

        return null;

    }



    /**

     * Search for an activation by rule name. Note that when using decision

     * tables, the rule name is generated as <code>Row N Rule_Name</code>. This

     * means that we can't just search for exact matches. This method will

     * therefore return true if an activation ends with the ruleName argument.

     *

     * @param ruleName

     *            The name of the rule we're looking for.

     */

    public static boolean ruleFired(List<Activation> activations, String ruleName) {

        for (Activation activation : activations) {

            if (activation.getRuleName().toUpperCase().endsWith(ruleName.toUpperCase())) {

                return true;

            }

        }

        return false;

    }



    /**

     * Given a list of rule activations and a list of rule names, did all of the

     * rules in the list provided get fired? This is a utility method designed

     * primarily to help with testing.

     *

     * @param ruleName

     *            The list of rule names we're looking for.

     */

    public static boolean allRulesFired(List<Activation> activations, String[] ruleNames) {

        for (String ruleName : ruleNames) {

            if (!ruleFired(activations, ruleName)) {

                return false;

            }

        }

        return true;

    }



    /**

     * Returns a <code>String</code> showing the rule names that were expected

     * to fire, and whether or not they fired, ready to be logged.

     *

     * @param ruleName

     *            The list of rule names we're looking for.

     */

    public static String prettyRulesFired(List<Activation> activations, String[] ruleNames) {

        StringBuilder sb = new StringBuilder();

        for (String ruleName : ruleNames) {

            sb.append("\n    " + ruleName + " : " + (ruleFired(activations, ruleName) ? "Y" : "N"));

        }

        return sb.toString();

    }



}package sgcib.tmon.worker.drools.util;



public enum ResourcePathType {

    CLASSPATH, FILE, URL;

}

package sgcib.tmon.worker.drools.util;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;



import org.kie.api.definition.rule.Rule;

import org.kie.api.event.rule.AfterMatchFiredEvent;

import org.kie.api.event.rule.AgendaEventListener;

import org.kie.api.event.rule.AgendaGroupPoppedEvent;

import org.kie.api.event.rule.AgendaGroupPushedEvent;

import org.kie.api.event.rule.BeforeMatchFiredEvent;

import org.kie.api.event.rule.MatchCancelledEvent;

import org.kie.api.event.rule.MatchCreatedEvent;

import org.kie.api.event.rule.RuleFlowGroupActivatedEvent;

import org.kie.api.event.rule.RuleFlowGroupDeactivatedEvent;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



public class TrackingAgendaEventListener implements AgendaEventListener {



    private static Logger log = LoggerFactory.getLogger(TrackingAgendaEventListener.class);



    private List<Activation> activationList = new ArrayList<Activation>();



    @Override

    public void afterMatchFired(AfterMatchFiredEvent event) {

        Rule rule = event.getMatch().getRule();



        String ruleName = rule.getName();

        Map<String, Object> ruleMetaDataMap = rule.getMetaData();



        activationList.add(new Activation(ruleName));

        StringBuilder sb = new StringBuilder("Rule fired: " + ruleName);



        if (ruleMetaDataMap.size() > 0) {

            sb.append("\n  With [" + ruleMetaDataMap.size() + "] meta-data:");

            for (String key : ruleMetaDataMap.keySet()) {

                sb.append("\n    key=" + key + ", value=" + ruleMetaDataMap.get(key));

            }

        }



        log.debug(sb.toString());

    }



    public boolean isRuleFired(String ruleName) {

        for (Activation a : activationList) {

            if (a.getRuleName().equals(ruleName)) {

                return true;

            }

        }

        return false;

    }



    public void reset() {

        activationList.clear();

    }



    public final List<Activation> getActivationList() {

        return activationList;

    }



    public String activationsToString() {

        if (activationList.size() == 0) {

            return "No activations occurred.";

        } else {

            StringBuilder sb = new StringBuilder("Activations: ");

            for (Activation activation : activationList) {

                sb.append("\n  rule: ").append(activation.getRuleName());

            }

            return sb.toString();

        }

    }



    @Override

    public void matchCreated(MatchCreatedEvent event) {

    }



    @Override

    public void matchCancelled(MatchCancelledEvent event) {

    }



    @Override

    public void beforeMatchFired(BeforeMatchFiredEvent event) {

    }



    @Override

    public void agendaGroupPopped(AgendaGroupPoppedEvent event) {

    }



    @Override

    public void agendaGroupPushed(AgendaGroupPushedEvent event) {

    }



    @Override

    public void beforeRuleFlowGroupActivated(RuleFlowGroupActivatedEvent event) {

    }



    @Override

    public void afterRuleFlowGroupActivated(RuleFlowGroupActivatedEvent event) {

    }



    @Override

    public void beforeRuleFlowGroupDeactivated(RuleFlowGroupDeactivatedEvent event) {

    }



    @Override

    public void afterRuleFlowGroupDeactivated(RuleFlowGroupDeactivatedEvent event) {

    }

}package sgcib.tmon.worker.drools.util;



import java.util.ArrayList;

import java.util.List;

import java.util.Map;



import org.apache.commons.beanutils.BeanUtils;

import org.kie.api.event.rule.ObjectDeletedEvent;

import org.kie.api.event.rule.ObjectInsertedEvent;

import org.kie.api.event.rule.ObjectUpdatedEvent;

import org.kie.api.event.rule.RuleRuntimeEvent;

import org.kie.api.event.rule.RuleRuntimeEventListener;

import org.kie.api.runtime.rule.FactHandle;

import org.slf4j.Logger;

import org.slf4j.LoggerFactory;



public class TrackingWorkingMemoryEventListener implements RuleRuntimeEventListener {



    private static Logger log = LoggerFactory.getLogger(TrackingWorkingMemoryEventListener.class);



    private List<RuleRuntimeEvent> allEvents = new ArrayList<RuleRuntimeEvent>();

    private List<ObjectInsertedEvent> insertions = new ArrayList<ObjectInsertedEvent>();

    private List<ObjectDeletedEvent> retractions = new ArrayList<ObjectDeletedEvent>();

    private List<ObjectUpdatedEvent> updates = new ArrayList<ObjectUpdatedEvent>();



    private List<Map<String, Object>> factChanges = new ArrayList<Map<String, Object>>();



    private FactHandle handleFilter;

    private Class<?> classFilter;



    /**

     * Void constructor sets the listener to record all working memory events

     * with no filtering.

     */

    public TrackingWorkingMemoryEventListener() {

        this.handleFilter = null;

    }



    /**

     * Constructor which sets up an event filter. The listener will only record

     * events when the event {@link FactHandle} matches the constructor

     * argument.

     *

     * @param handle

     *            The {@link FactHandle} to filter on.

     */

    public TrackingWorkingMemoryEventListener(FactHandle handle) {

        this.handleFilter = handle;

    }



    public TrackingWorkingMemoryEventListener(Class<?> classFilter) {

        this.handleFilter = null;

        this.classFilter = classFilter;

    }



    @Override

    public void objectInserted(final ObjectInsertedEvent event) {

        if ((handleFilter == null && classFilter == null) || event.getFactHandle() == handleFilter || event.getObject().getClass().equals(classFilter)) {

            insertions.add(event);

           allEvents.add(event);

            log.trace("Insertion: " + DroolsUtil.objectDetails(event.getObject()));

        }

    }



    @Override

    public void objectDeleted(final ObjectDeletedEvent event) {

        if ((handleFilter == null && classFilter == null) || event.getFactHandle() == handleFilter || event.getOldObject().getClass().equals(classFilter)) {

            retractions.add(event);

            allEvents.add(event);

            log.trace("Retraction: " + DroolsUtil.objectDetails(event.getOldObject()));

        }

    }



    @SuppressWarnings("unchecked")

    @Override

    public void objectUpdated(final ObjectUpdatedEvent event) {

        if ((handleFilter == null && classFilter == null) || event.getFactHandle() == handleFilter || event.getObject().getClass().equals(classFilter)) {

            updates.add(event);

            allEvents.add(event);



            Object fact = event.getObject();

            try {

                factChanges.add(BeanUtils.describe(fact));

            } catch (Exception e) {

                log.error("Unable to get object details for tracking: " + DroolsUtil.objectDetails(fact), e);

            }

            log.trace("Update: " + DroolsUtil.objectDetails(event.getObject()));

        }

    }



    public List<RuleRuntimeEvent> getAllEvents() {

        return allEvents;

    }



    public List<ObjectInsertedEvent> getInsertions() {

        return insertions;

    }



    public List<ObjectDeletedEvent> getRetractions() {

        return retractions;

    }



    public List<ObjectUpdatedEvent> getUpdates() {

        return updates;

    }



    public List<Map<String, Object>> getFactChanges() {

        return factChanges;

    }



    public String getPrintableSummary() {

        return "TrackingWorkingMemoryEventListener: " + "insertions=[" + insertions.size() + "], " + "retractions=[" + retractions.size() + "], " + "updates=[" + updates.size() + "]";

    }



    public String getPrintableDetail() {

        StringBuilder report = new StringBuilder("TrackingWorkingMemoryEventListener: " + "insertions=[" + insertions.size() + "], " + "retractions=[" + retractions.size() + "], " + "updates=[" + updates.size() + "]");



        for (ObjectInsertedEvent event : insertions) {

            report.append("\n" + DroolsUtil.objectDetails(event.getObject()));

        }

        for (ObjectDeletedEvent event : retractions) {

            report.append("\n" + DroolsUtil.objectDetails(event.getOldObject()));

        }

       for (ObjectUpdatedEvent event : updates) {

            report.append("\n" + DroolsUtil.objectDetails(event.getObject()));

        }



        return report.toString();

    }

}/**

* Drools memory's listeners.

*/

package sgcib.tmon.worker.drools.util;package sgcib.tmon.worker.service.chain;



/**

* Created by slopes041604 on 27/10/2015.

*/

public class ChainEdge {

    private int to;

    private int from;

    private long duration;





    public ChainEdge(int to, int from, long duration) {

        this.to = to;

        this.from = from;

        this.duration = duration;

    }



    public int getTo() {

        return to;

    }



    public void setTo(int to) {

        this.to = to;

    }



    public int getFrom() {

        return from;

    }



    public void setFrom(int from) {

        this.from = from;

    }



    public long getDuration() {

        return duration;

    }



    public void setDuration(long duration) {

        this.duration = duration;

    }

}

package sgcib.tmon.worker.service.chain;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormat;

import org.joda.time.format.DateTimeFormatter;

import org.joda.time.format.ISODateTimeFormat;

import sgcib.tmon.worker.chain.Chain;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;



import java.util.ArrayList;

import java.util.List;



/**

* Created by slopes041604 on 27/10/2015.

*/

public class ChainGraph {

    private final List<ChainNode> nodes;

    private final List<ChainEdge> edges;

    private final ChainNode chainNode;



    public ChainGraph(Chain chain, List<ChainStep> chainSteps) {

        nodes = new ArrayList<>();

        edges = new ArrayList<>();



        this.chainNode = new ChainNode();

        this.chainNode.setId(1);



        if (chain.getName() != null) {

            this.chainNode.setLabel(chain.getName());

            this.chainNode.setContent(chain.getName());

        } else {

            Object dealId = chain.getValue("deal.contractid");

            if (dealId != null) {

                this.chainNode.setLabel(dealId.toString());

                this.chainNode.setContent(dealId.toString());

            } else {

                this.chainNode.setLabel("chain");

                this.chainNode.setContent("chain");

            }

        }



        DateTime start = chain.getValueAsDateTime("startDate");

        if (start != null) {

            DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss.SSS");

            this.chainNode.setChainStepUrl(ManageableBase.getConfiguration().getChainDataUrl(chain.getId(), start));

            this.chainNode.setStart(formatter.print(start));

        }





        nodes.add(this.chainNode);

        build(chainSteps);





    }



    private void build(List<ChainStep> chainSteps) {



        for (ChainStep chainStep : chainSteps) {

            ChainNode chainNode = new ChainNode(chainStep);

            nodes.add(chainNode);

            chainNode.setId(nodes.size());

        }





        for (ChainNode child : nodes) {

            for (ChainNode parent : nodes) {

                if (child.getParent() != null && parent.getStep() != null && parent.getStep().equals(child.getParent())) {

                    ChainEdge edge = new ChainEdge(child.getId(), parent.getId(), child.getDurationFromStart());

                    edges.add(edge);

                }

            }



            if (child.getParent() == null && child.getId() != 1) {

                ChainEdge edge = new ChainEdge(child.getId(), this.chainNode.getId(), child.getDurationFromStart());

                edges.add(edge);

            }

        }

    }



    public List<ChainNode> getNodes() {

        return nodes;

    }



    public List<ChainEdge> getEdges() {

        return edges;

    }

}

package sgcib.tmon.worker.service.chain;



import org.joda.time.DateTime;

import org.joda.time.format.DateTimeFormat;

import org.joda.time.format.DateTimeFormatter;

import sgcib.tmon.worker.chain.ChainStep;

import sgcib.tmon.worker.common.lifecycle.ManageableBase;

import sgcib.tmon.worker.configuration.WorkerConfiguration;

import sgcib.tmon.worker.service.WorkerService;



/**

* Created by slopes041604 on 27/10/2015.

*/

public class ChainNode {

    private int id;

    private String step;

    private String content;

    private String label;

    private String end;

    private String start;

    private String parent;

    private long duration;

    private long durationFromStart;

    private String chainStepUrl;

    private String alertUrl;

    private String color;



    public ChainNode() {



    }



    public ChainNode(ChainStep chainStep) {

        DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss.SSS");

        this.step = chainStep.getId();

        this.label = chainStep.getName();

        this.parent = chainStep.getParent();

        this.content = chainStep.getName();

        this.start = formatter.print(chainStep.getStart());

        this.duration = chainStep.getDuration();

        if (chainStep.containsKey("durationFromChainStart")) {

            this.durationFromStart = Long.parseLong(chainStep.getValue("durationFromChainStart").toString());

        }



        Object alertId = chainStep.getValue("alert.id");

        if (alertId != null) {

            this.alertUrl = ManageableBase.getConfiguration().getAlertDataUrl(alertId.toString(), chainStep.getTimestamp());

        }



        this.chainStepUrl = ManageableBase.getConfiguration().getChainStepDataUrl(chainStep.getId(), chainStep.getTimestamp());





        Object status = chainStep.getStatus();



        if (status != null) {

            if (status.equals("closed")) {

                this.color = "lightgrey";

            }

            if (status.equals("running")) {

                this.color = "lightblue";

            }

            if (status.equals("error")) {

                this.color = "red";

            }

        }

    }





    public void setStep(String step) {

        this.step = step;

    }



    public void setContent(String content) {

        this.content = content;

    }



    public void setLabel(String label) {

        this.label = label;

    }



    public void setEnd(String end) {

        this.end = end;

    }



    public void setStart(String start) {

        this.start = start;

    }



    public void setParent(String parent) {

        this.parent = parent;

    }



    public void setDuration(long duration) {

        this.duration = duration;

    }



    public void setDurationFromStart(long durationFromStart) {

        this.durationFromStart = durationFromStart;

    }



    public void setChainStepUrl(String chainStepUrl) {

        this.chainStepUrl = chainStepUrl;

    }



    public void setAlertUrl(String alertUrl) {

        this.alertUrl = alertUrl;

    }



    public void setColor(String color) {

        this.color = color;

    }



    public int getId() {

        return id;

    }



    public void setId(int id) {

        this.id = id;

    }



    public String getLabel() {

        return label;

    }



    public String getStart() {

        return start;

    }



    public String getParent() {

        return parent;

    }



    public String getStep() {

        return step;

    }



    public long getDuration() {

        return duration;

    }



    public long getDurationFromStart() {

        return durationFromStart;

    }



    public String getContent() {

        return content;

    }



    public String getChainStepUrl() {

        return chainStepUrl;

    }



    public String getAlertUrl() {

        return alertUrl;

    }



    public String getEnd() {

        return end;

    }



    public String getColor() {

        return color;

    }

}

*************************************************************************
This message and any attachments (the "message") are confidential, intended solely for the addresse(s), and may contain legally privileged information.
Any unauthorized use or dissemination is prohibited. E-mails are susceptible to alteration.
Neither SOCIETE GENERALE nor any of its subsidiaries or affiliates shall be liable for the message if altered, changed or
falsified.
Please visit http://swapdisclosure.sgcib.com for important information with respect to derivative products.
                              ************
Ce message et toutes les pieces jointes (ci-apres le "message") sont confidentiels et susceptibles de contenir des informations couvertes
par le secret professionnel.
Ce message est etabli a l'intention exclusive de ses destinataires. Toute utilisation ou diffusion non autorisee est interdite.
Tout message electronique est susceptible d'alteration.
La SOCIETE GENERALE et ses filiales declinent toute responsabilite au titre de ce message s'il a ete altere, deforme ou falsifie.
Veuillez consulter le site http://swapdisclosure.sgcib.com afin de recueillir d'importantes informations sur les produits derives.
*************************************************************************